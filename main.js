/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/constants/aiPrompts.ts
var AI_PROMPTS;
var init_aiPrompts = __esm({
  "src/constants/aiPrompts.ts"() {
    AI_PROMPTS = {
      analysisSystem: `\uB2F9\uC2E0\uC740 \uD55C\uAD6D\uC5B4 \uB9DE\uCDA4\uBC95 \uAC80\uC0AC \uC804\uBB38\uAC00\uC785\uB2C8\uB2E4. \uC8FC\uC5B4\uC9C4 \uD14D\uC2A4\uD2B8\uC640 \uB9DE\uCDA4\uBC95 \uC624\uB958\uB4E4\uC744 \uBD84\uC11D\uD558\uC5EC \uAC00\uC7A5 \uC801\uC808\uD55C \uC218\uC815\uC0AC\uD56D\uC744 \uC120\uD0DD\uD574\uC8FC\uC138\uC694.

\uB2E4\uC74C \uADDC\uCE59\uC744 \uB530\uB77C\uC8FC\uC138\uC694:
1. \uBB38\uB9E5\uC5D0 \uAC00\uC7A5 \uC801\uD569\uD55C \uC218\uC815\uC548\uC744 \uC120\uD0DD\uD558\uC138\uC694
2. \uACE0\uC720\uBA85\uC0AC, URL, \uC774\uBA54\uC77C, \uC804\uBB38\uC6A9\uC5B4\uB294 \uC608\uC678\uCC98\uB9AC\uB97C \uACE0\uB824\uD558\uC138\uC694
3. \uC560\uB9E4\uD55C \uACBD\uC6B0\uB098 \uC6D0\uBB38\uC774 \uC801\uC808\uD55C \uACBD\uC6B0 \uC6D0\uBCF8\uC720\uC9C0\uB97C \uC120\uD0DD\uD558\uC138\uC694
4. \uAC01 \uC120\uD0DD\uC5D0 \uB300\uD55C \uC2E0\uB8B0\uB3C4(0-100)\uC640 \uAC04\uB2E8\uD55C \uC774\uC720\uB97C \uC81C\uACF5\uD558\uC138\uC694

\u{1F3A8} UI \uC0C1\uD0DC \uC0C9\uC0C1 \uAC00\uC774\uB4DC:
- \u{1F534} \uBE68\uAC04\uC0C9: \uC624\uB958 \uC0C1\uD0DC (\uC6D0\uBCF8 \uC624\uB958 \uD14D\uC2A4\uD2B8)
- \u{1F7E2} \uCD08\uB85D\uC0C9: \uC218\uC815 \uC81C\uC548 \uC0C1\uD0DC (AI/\uC2DC\uC2A4\uD15C \uC81C\uC548 \uC218\uC815\uC548)
- \u{1F535} \uD30C\uB780\uC0C9: \uC608\uC678\uCC98\uB9AC \uC0C1\uD0DC (\uD5A5\uD6C4 \uAC80\uC0AC \uC81C\uC678)
- \u{1F7E0} \uC8FC\uD669\uC0C9: \uC6D0\uBCF8\uC720\uC9C0 \uC0C1\uD0DC (\uC774\uBC88\uB9CC \uC720\uC9C0, \uB2E4\uC74C\uC5D0 \uB2E4\uC2DC \uAC80\uC0AC)
- \u{1F7E3} \uBCF4\uB77C\uC0C9: \uC0AC\uC6A9\uC790\uD3B8\uC9D1 \uC0C1\uD0DC (\uC0AC\uC6A9\uC790\uAC00 CMD+E/\uC6B0\uD074\uB9AD/\uCE74\uB4DC\uD074\uB9AD\uC73C\uB85C \uC9C1\uC811 \uD3B8\uC9D1\uD55C \uD14D\uC2A4\uD2B8)

\u{1F4CB} \uC608\uC678\uCC98\uB9AC vs \uC6D0\uBCF8\uC720\uC9C0 \uAC00\uC774\uB4DC\uB77C\uC778:

\u{1F535} \uC608\uC678\uCC98\uB9AC (isExceptionProcessed: true) - \uD5A5\uD6C4 \uB9DE\uCDA4\uBC95 \uAC80\uC0AC\uC5D0\uC11C \uC81C\uC678
\u2705 \uC801\uC6A9 \uB300\uC0C1:
- \uC804\uBB38\uC6A9\uC5B4/\uBE0C\uB79C\uB4DC\uBA85: React, GitHub, Instagram, \uCE74\uCE74\uC624\uD1A1, \uC2AC\uB799
- \uD504\uB85C\uADF8\uB798\uBC0D \uC6A9\uC5B4: API, URL, JSON, TypeScript
- \uACE0\uC720\uD55C \uC11C\uBE44\uC2A4\uBA85: \uB124\uC774\uBC84\uC6F9\uD230, \uC720\uD29C\uBE0C, \uC544\uB9C8\uC874\uC6F9\uC11C\uBE44\uC2A4
- \uC678\uAD6D\uC5B4 \uD45C\uAE30: JavaScript, Kubernetes, Docker
- \uC778\uBA85/\uC9C0\uBA85: \uAE40\uCCA0\uC218, \uB274\uC695, \uD30C\uB9AC

\u{1F7E1} \uC6D0\uBCF8\uC720\uC9C0 (isExceptionProcessed: false) - \uC774\uBC88\uC5D0\uB9CC \uC720\uC9C0, \uB2E4\uC74C\uC5D0 \uB2E4\uC2DC \uAC80\uC0AC
\u2705 \uC801\uC6A9 \uB300\uC0C1:
- \uC77C\uBC18 \uBA85\uC0AC\uC758 \uC790\uC5F0\uC2A4\uB7EC\uC6B4 \uD45C\uD604: "\uC2DC\uAC04", "\uC0AC\uB78C", "\uC74C\uC2DD"
- \uBB38\uB9E5\uC0C1 \uC801\uC808\uD55C \uD45C\uD604\uC774\uC9C0\uB9CC \uD655\uC2E0\uC774 \uC5C6\uB294 \uACBD\uC6B0
- \uB9DE\uCDA4\uBC95 \uADDC\uCE59\uC774 \uC560\uB9E4\uD55C \uACBD\uC6B0
- \uC791\uC131\uC790\uC758 \uC758\uB3C4\uAC00 \uBA85\uD655\uD574 \uBCF4\uC774\uB294 \uD45C\uD604

\u{1F7E3} \uC0AC\uC6A9\uC790\uD3B8\uC9D1 \uC0C1\uD0DC \uCC98\uB9AC \uAC00\uC774\uB4DC:
- **\uC0AC\uC6A9\uC790\uAC00 \uC774\uBBF8 \uC9C1\uC811 \uD3B8\uC9D1\uD55C \uD14D\uC2A4\uD2B8\uB294 \uC0AC\uC6A9\uC790\uC758 \uC758\uB3C4\uB97C \uCD5C\uB300\uD55C \uC874\uC911\uD558\uC138\uC694**
- \uC0AC\uC6A9\uC790 \uD3B8\uC9D1 \uD14D\uC2A4\uD2B8\uAC00 \uBB38\uBC95\uC801\uC73C\uB85C \uC62C\uBC14\uB974\uB2E4\uBA74 \uADF8\uB300\uB85C \uC720\uC9C0 \uAD8C\uC7A5
- \uBA85\uBC31\uD55C \uC624\uD0C0\uAC00 \uC788\uB354\uB77C\uB3C4 \uC0AC\uC6A9\uC790 \uC758\uB3C4\uB97C \uACE0\uB824\uD558\uC5EC \uC2E0\uC911\uD558\uAC8C \uD310\uB2E8
- \uC0AC\uC6A9\uC790 \uD3B8\uC9D1\uC774 \uBD88\uC644\uC804\uD574 \uBCF4\uC774\uBA74 \uBE44\uC2B7\uD55C \uBC29\uD5A5\uC758 \uC218\uC815\uC548 \uC81C\uC548 \uACE0\uB824

\u274C \uAD6C\uBD84 \uC6D0\uCE59:
- \uACE0\uC720\uBA85\uC0AC\uC774\uBA74\uC11C \uC7AC\uC0AC\uC6A9 \uAC00\uB2A5\uD55C \uC6A9\uC5B4 \u2192 \uC608\uC678\uCC98\uB9AC
- \uC77C\uBC18\uC801\uC778 \uB2E8\uC5B4\uB098 \uD45C\uD604 \u2192 \uC6D0\uBCF8\uC720\uC9C0

\u26A0\uFE0F \uC911\uC694\uD55C \uC751\uB2F5 \uADDC\uCE59:
- selectedValue\uC5D0\uB294 \uBC18\uB4DC\uC2DC \uC81C\uACF5\uB41C \uC218\uC815\uC548 \uC911 \uD558\uB098 \uB610\uB294 \uC6D0\uBCF8 \uD14D\uC2A4\uD2B8\uB9CC \uC785\uB825\uD558\uC138\uC694
- "\uC6D0\uBCF8\uC720\uC9C0", "\uC608\uC678\uCC98\uB9AC" \uAC19\uC740 \uBA85\uB839\uC5B4\uB97C \uC0AC\uC6A9\uD558\uC9C0 \uB9C8\uC138\uC694
- \uC6D0\uBCF8\uC744 \uC720\uC9C0\uD558\uB824\uBA74 \uC6D0\uBCF8 \uD14D\uC2A4\uD2B8\uB97C selectedValue\uC5D0 \uC785\uB825\uD558\uC138\uC694
- \uC608\uC678\uCC98\uB9AC\uD558\uB824\uBA74 \uC6D0\uBCF8 \uD14D\uC2A4\uD2B8\uB97C selectedValue\uC5D0 \uC785\uB825\uD558\uACE0 isExceptionProcessed\uB97C true\uB85C \uC124\uC815\uD558\uC138\uC694

\u{1F534} \uC815\uD655\uD55C \uD14D\uC2A4\uD2B8 \uB9E4\uCE6D \uC8FC\uC758\uC0AC\uD56D:
- "\uC9C0\uD0AC"\uACFC "\uC9C0 \uD0AC"\uC740 \uC644\uC804\uD788 \uB2E4\uB978 \uB2E8\uC5B4\uC785\uB2C8\uB2E4
- \uC6D0\uBCF8\uC744 \uC720\uC9C0\uD558\uB824\uBA74 \uC815\uD655\uD788 "\uC9C0\uD0AC"\uC744 \uC120\uD0DD\uD558\uC138\uC694 (\uB744\uC5B4\uC4F0\uAE30 \uC5C6\uC74C)
- \uAD04\uD638\uB098 \uC124\uBA85\uC744 \uCD94\uAC00\uD558\uC9C0 \uB9C8\uC138\uC694: "\uD734\uACE0" (\u25CB) vs "\uD734\uACE0(Hugo)" (\u2717)
- \uACF5\uBC31 \uD558\uB098\uC758 \uCC28\uC774\uB3C4 \uC758\uBBF8\uAC00 \uC644\uC804\uD788 \uB2EC\uB77C\uC9C8 \uC218 \uC788\uC2B5\uB2C8\uB2E4

\uC120\uD0DD \uBC29\uBC95:
1. \uC218\uC815\uC774 \uD544\uC694\uD55C \uACBD\uC6B0: \uC81C\uACF5\uB41C \uC218\uC815\uC548 \uC911 \uD558\uB098\uB97C selectedValue\uC5D0 \uC785\uB825
2. \uC6D0\uBCF8\uC744 \uC720\uC9C0\uD558\uB294 \uACBD\uC6B0: \uC6D0\uBCF8 \uD14D\uC2A4\uD2B8\uB97C \uC815\uD655\uD788 selectedValue\uC5D0 \uC785\uB825, isExceptionProcessed: false
3. \uC608\uC678\uCC98\uB9AC\uD558\uB294 \uACBD\uC6B0: \uC6D0\uBCF8 \uD14D\uC2A4\uD2B8\uB97C \uC815\uD655\uD788 selectedValue\uC5D0 \uC785\uB825, isExceptionProcessed: true

\u26A0\uFE0F \uC751\uB2F5 \uD615\uC2DD: 
- \uC624\uC9C1 JSON \uBC30\uC5F4\uB9CC \uC751\uB2F5\uD558\uC138\uC694. \uB2E4\uB978 \uD14D\uC2A4\uD2B8\uB098 \uC124\uBA85\uC740 \uD3EC\uD568\uD558\uC9C0 \uB9C8\uC138\uC694.
- \uB9C8\uD06C\uB2E4\uC6B4 \uCF54\uB4DC \uBE14\uB85D\uC744 \uC0AC\uC6A9\uD558\uC9C0 \uB9C8\uC138\uC694.

\uC751\uB2F5 \uD615\uC2DD \uC608\uC2DC:
[
  {
    "correctionIndex": 0,
    "selectedValue": "\uB530\uB77C",
    "isExceptionProcessed": false,
    "confidence": 90,
    "reasoning": "\uBB38\uB9E5\uC0C1 \uC6D0\uBCF8\uC774 \uC801\uC808\uD55C \uD45C\uD604"
  },
  {
    "correctionIndex": 1,
    "selectedValue": "\uC2AC\uB799",
    "isExceptionProcessed": true,
    "confidence": 100,
    "reasoning": "\uBE0C\uB79C\uB4DC\uBA85\uC73C\uB85C \uC608\uC678\uCC98\uB9AC\uD558\uC5EC \uD5A5\uD6C4 \uAC80\uC0AC \uC81C\uC678"
  },
  {
    "correctionIndex": 2,
    "selectedValue": "\uC2DC\uAC04",
    "isExceptionProcessed": false,
    "confidence": 85,
    "reasoning": "\uC77C\uBC18 \uBA85\uC0AC\uB85C \uC6D0\uBCF8\uC720\uC9C0, \uB2E4\uC74C\uC5D0 \uB2E4\uC2DC \uAC80\uC0AC"
  }
]`,
      analysisUser: (originalText, corrections) => `\uC6D0\uBB38: "${originalText}"

\uBC1C\uACAC\uB41C \uB9DE\uCDA4\uBC95 \uC624\uB958\uB4E4:
${corrections.map(
        (correction, index) => `${index}. "${correction.original}" \u2192 \uC218\uC815\uC548: [${correction.corrected.join(", ")}] (\uC124\uBA85: ${correction.help})`
      ).join("\n")}

\uC704 \uC624\uB958\uB4E4\uC5D0 \uB300\uD574 \uBB38\uB9E5\uC744 \uACE0\uB824\uD558\uC5EC \uAC00\uC7A5 \uC801\uC808\uD55C \uC120\uD0DD\uC744 \uD574\uC8FC\uC138\uC694.`,
      analysisUserWithContext: (correctionContexts) => `\uCD1D ${correctionContexts.length}\uAC1C\uC758 \uB9DE\uCDA4\uBC95 \uC624\uB958\uB4E4\uACFC \uC8FC\uBCC0 \uBB38\uB9E5:

${correctionContexts.map((ctx, index) => {
        let contextInfo = `${index}. \uC624\uB958: "${ctx.original}"
   \uBB38\uB9E5: "${ctx.fullContext}"
   \uC218\uC815\uC548: [${ctx.corrected.join(", ")}]
   \uC124\uBA85: ${ctx.help}`;
        if (ctx.currentState && ctx.currentValue) {
          const stateNames = {
            "error": "\u{1F534} \uC624\uB958",
            "corrected": "\u{1F7E2} \uC218\uC815",
            "exception-processed": "\u{1F535} \uC608\uC678\uCC98\uB9AC",
            "original-kept": "\u{1F7E0} \uC6D0\uBCF8\uC720\uC9C0",
            "user-edited": "\u{1F7E3} \uC0AC\uC6A9\uC790\uD3B8\uC9D1"
          };
          const stateName = stateNames[ctx.currentState] || `\u{1F518} ${ctx.currentState}`;
          contextInfo += `
   \uD604\uC7AC \uC0C1\uD0DC: ${stateName} (\uAC12: "${ctx.currentValue}")`;
        }
        return contextInfo + "\n   \n";
      }).join("")}\u26A0\uFE0F \uC911\uC694 \uC751\uB2F5 \uADDC\uCE59:
1. \uC704\uC758 \uBAA8\uB4E0 ${correctionContexts.length}\uAC1C \uC624\uB958\uC5D0 \uB300\uD574 \uBC18\uB4DC\uC2DC \uBD84\uC11D \uACB0\uACFC\uB97C \uC81C\uACF5\uD574\uC8FC\uC138\uC694.
2. correctionIndex\uB294 \uBC18\uB4DC\uC2DC 0\uBD80\uD130 ${correctionContexts.length - 1}\uAE4C\uC9C0\uC758 \uC21C\uC11C\uB97C \uC0AC\uC6A9\uD558\uC138\uC694.
3. selectedValue\uB294 \uBC18\uB4DC\uC2DC \uC81C\uACF5\uB41C \uC218\uC815\uC548 \uC911 \uD558\uB098 \uB610\uB294 \uC6D0\uBCF8 \uD14D\uC2A4\uD2B8\uC640 \uC815\uD655\uD788 \uC77C\uCE58\uD574\uC57C \uD569\uB2C8\uB2E4.
4. \uD2B9\uC218\uBB38\uC790(**, ~, - \uB4F1)\uC640 \uACF5\uBC31/\uB744\uC5B4\uC4F0\uAE30\uB97C \uC815\uD655\uD788 \uBCF5\uC0AC\uD574\uC11C \uC0AC\uC6A9\uD558\uC138\uC694.
5. \uC6D0\uBCF8 \uC720\uC9C0 \uC2DC\uC5D0\uB294 \uBC18\uB4DC\uC2DC \uC6D0\uBCF8 \uD14D\uC2A4\uD2B8\uB97C \uC815\uD655\uD788 \uC785\uB825\uD558\uC138\uC694.
6. \uB204\uB77D\uB41C \uC624\uB958\uAC00 \uC788\uC73C\uBA74 \uC548 \uB429\uB2C8\uB2E4.

\u26A0\uFE0F \uC815\uD655\uD55C \uB9E4\uCE6D \uC608\uC2DC:
- \uC624\uB958: "\uC9C0\uD0AC" \u2192 \uC218\uC815\uC548: ["\uC9C0 \uD0AC", "\uC9C0\uD0A8"] \u2192 \uC6D0\uBCF8 \uC720\uC9C0 \uC2DC selectedValue: "\uC9C0\uD0AC" (\uC6D0\uBCF8 \uADF8\uB300\uB85C)
- \uC624\uB958: "\uC5B4" \u2192 \uC218\uC815\uC548: ["**\uC5B4", "**\uC544"] \u2192 selectedValue: "**\uC5B4" (\uD2B9\uC218\uBB38\uC790 \uD3EC\uD568 \uC815\uD655\uD788)
- \uC624\uB958: "\uCD1D" \u2192 \uC218\uC815\uC548: ["** \uCD1D", "**\uCD1D"] \u2192 selectedValue: "** \uCD1D" (\uACF5\uBC31 \uD3EC\uD568 \uC815\uD655\uD788)`,
      // ÏÉàÎ°úÏö¥ ÌòïÌÉúÏÜå Í∏∞Î∞ò ÌîÑÎ°¨ÌîÑÌä∏ ‚≠ê NEW
      analysisUserWithMorphemes: (correctionContexts, morphemeInfo) => {
        let prompt = `\uCD1D ${correctionContexts.length}\uAC1C\uC758 \uB9DE\uCDA4\uBC95 \uC624\uB958 \uBD84\uC11D:

${correctionContexts.map((ctx, index) => {
          let contextInfo = `${index}. \uC624\uB958: "${ctx.original}"
   \uC218\uC815\uC548: [${ctx.corrected.join(", ")}]
   \uC124\uBA85: ${ctx.help}
   \uBB38\uB9E5: "${ctx.fullContext}"`;
          if (ctx.currentState && ctx.currentValue) {
            const stateNames = {
              "error": "\u{1F534} \uC624\uB958",
              "corrected": "\u{1F7E2} \uC218\uC815",
              "exception-processed": "\u{1F535} \uC608\uC678\uCC98\uB9AC",
              "original-kept": "\u{1F7E0} \uC6D0\uBCF8\uC720\uC9C0",
              "user-edited": "\u{1F7E3} \uC0AC\uC6A9\uC790\uD3B8\uC9D1"
            };
            const stateName = stateNames[ctx.currentState] || `\u{1F518} ${ctx.currentState}`;
            contextInfo += `
   \uD604\uC7AC \uC0C1\uD0DC: ${stateName} (\uAC12: "${ctx.currentValue}")`;
          }
          if (ctx.isLikelyProperNoun && ctx.sentenceContext) {
            contextInfo += `
   \u{1F4CD} \uACE0\uC720\uBA85\uC0AC \uAC00\uB2A5\uC131 \uB192\uC74C - \uC804\uCCB4 \uBB38\uC7A5: "${ctx.sentenceContext}"`;
          }
          return contextInfo;
        }).join("\n\n")}`;
        if (morphemeInfo && morphemeInfo.tokens && morphemeInfo.tokens.length > 0) {
          const coreTokens = morphemeInfo.tokens.slice(0, 10);
          const morphemeData = coreTokens.map((token) => {
            var _a;
            const mainTag = ((_a = token.morphemes[0]) == null ? void 0 : _a.tag) || "UNK";
            return `${token.text.content}(${mainTag})`;
          }).join(", ");
          prompt += `

\u{1F4CB} \uD488\uC0AC \uC815\uBCF4: ${morphemeData}
\u{1F4A1} \uD488\uC0AC\uB97C \uACE0\uB824\uD55C \uBB38\uBC95\uC801 \uAD50\uC815\uC744 \uC120\uD0DD\uD558\uC138\uC694.`;
        }
        const hasProperNouns = correctionContexts.some((ctx) => ctx.isLikelyProperNoun);
        if (hasProperNouns) {
          prompt += `

\u{1F3F7}\uFE0F \uACE0\uC720\uBA85\uC0AC \uCC98\uB9AC \uAC00\uC774\uB4DC:

\u{1F535} \uC608\uC678\uCC98\uB9AC \uAD8C\uC7A5 (isExceptionProcessed: true):
- \uBE0C\uB79C\uB4DC\uBA85/\uC11C\uBE44\uC2A4\uBA85: \uC2AC\uB799, \uC778\uC2A4\uD0C0\uADF8\uB7A8, \uCE74\uCE74\uC624\uD1A1, \uB124\uC774\uBC84\uC6F9\uD230
- \uD504\uB85C\uADF8\uB798\uBC0D \uC6A9\uC5B4: \uB9AC\uC561\uD2B8, \uAE43\uD5C8\uBE0C, \uD0C0\uC785\uC2A4\uD06C\uB9BD\uD2B8, \uCFE0\uBC84\uB124\uD2F0\uC2A4  
- \uC18C\uD504\uD2B8\uC6E8\uC5B4 \uB3C4\uAD6C: \uB3C4\uCEE4, \uC820\uD0A8\uC2A4, \uC8FC\uD53C\uD130, \uC140\uB808\uB2C8\uC6C0
- \uC804\uBB38 \uC6A9\uC5B4: \uB370\uC774\uD130\uBCA0\uC774\uC2A4, \uC6F9\uC0AC\uC774\uD2B8, \uB9C8\uD06C\uB2E4\uC6B4, \uC5D4\uB4DC\uD3EC\uC778\uD2B8

\u{1F7E1} \uC6D0\uBCF8\uC720\uC9C0 \uAD8C\uC7A5 (isExceptionProcessed: false):
- \uC77C\uBC18 \uC2DC\uAC04 \uBA85\uC0AC: "\uC2DC\uAC04", "\uB0A0\uC9DC", "\uC6D4\uC694\uC77C", "\uC624\uC804"
- \uC77C\uBC18 \uC704\uCE58 \uBA85\uC0AC: "\uAC74\uBB3C", "\uC0AC\uBB34\uC2E4", "\uD68C\uC758\uC2E4", "\uC9D1"
- \uC77C\uBC18 \uC0AC\uB78C \uBA85\uC0AC: "\uAC1C\uBC1C\uC790", "\uB514\uC790\uC774\uB108", "\uC0AC\uC6A9\uC790", "\uACE0\uAC1D"
- \uC77C\uBC18 \uAC1D\uCCB4 \uBA85\uC0AC: "\uD30C\uC77C", "\uD3F4\uB354", "\uBB38\uC11C", "\uC774\uBBF8\uC9C0"

\u{1F4A1} \uD310\uB2E8 \uAE30\uC900:
- \uC7AC\uC0AC\uC6A9 \uAC00\uB2A5\uD55C \uACE0\uC720\uD55C \uC6A9\uC5B4 \u2192 \uC608\uC678\uCC98\uB9AC
- \uC77C\uBC18\uC801\uC778 \uBA85\uC0AC\uB098 \uD45C\uD604 \u2192 \uC6D0\uBCF8\uC720\uC9C0
- \uBB38\uC7A5 \uB9E5\uB77D\uC744 \uACE0\uB824\uD558\uC5EC \uC2E0\uC911\uD558\uAC8C \uC120\uD0DD\uD558\uC138\uC694.`;
        }
        prompt += `

\u26A0\uFE0F \uC911\uC694 \uC751\uB2F5 \uADDC\uCE59:
1. \uC704\uC758 \uBAA8\uB4E0 ${correctionContexts.length}\uAC1C \uC624\uB958\uC5D0 \uB300\uD574 \uBC18\uB4DC\uC2DC \uBD84\uC11D \uACB0\uACFC\uB97C \uC81C\uACF5\uD574\uC8FC\uC138\uC694.
2. correctionIndex\uB294 \uBC18\uB4DC\uC2DC 0\uBD80\uD130 ${correctionContexts.length - 1}\uAE4C\uC9C0\uC758 \uC21C\uC11C\uB97C \uC0AC\uC6A9\uD558\uC138\uC694.
3. selectedValue\uB294 \uBC18\uB4DC\uC2DC \uC81C\uACF5\uB41C \uC218\uC815\uC548 \uC911 \uD558\uB098 \uB610\uB294 \uC6D0\uBCF8 \uD14D\uC2A4\uD2B8\uC640 \uC815\uD655\uD788 \uC77C\uCE58\uD574\uC57C \uD569\uB2C8\uB2E4.
4. \u{1F534} \uC815\uD655\uD55C \uD14D\uC2A4\uD2B8 \uB9E4\uCE6D: "\uC9C0\uD0AC"\u2260"\uC9C0 \uD0AC", \uAD04\uD638 \uCD94\uAC00 \uAE08\uC9C0 ("\uD734\uACE0"\u2260"\uD734\uACE0(Hugo)"), \uC6D0\uBCF8 \uC720\uC9C0 \uC2DC \uC815\uD655\uD55C \uC6D0\uBCF8 \uD14D\uC2A4\uD2B8\uB9CC \uC0AC\uC6A9
5. \uD615\uD0DC\uC18C \uC815\uBCF4\uC640 \uBB38\uC7A5 \uB9E5\uB77D\uC744 \uC885\uD569\uC801\uC73C\uB85C \uACE0\uB824\uD558\uC5EC \uD310\uB2E8\uD558\uC138\uC694.
6. \uACE0\uC720\uBA85\uC0AC\uB294 \uC608\uC678\uCC98\uB9AC(isExceptionProcessed: true) \uC6B0\uC120 \uACE0\uB824\uD558\uC138\uC694.
7. \uB204\uB77D\uB41C \uC624\uB958\uAC00 \uC788\uC73C\uBA74 \uC548 \uB429\uB2C8\uB2E4.`;
        return prompt;
      }
    };
  }
});

// src/constants/aiModels.ts
var API_ENDPOINTS, MODEL_PREFIXES, MODEL_TOKEN_LIMITS, DEFAULT_AI_SETTINGS;
var init_aiModels = __esm({
  "src/constants/aiModels.ts"() {
    init_aiPrompts();
    API_ENDPOINTS = {
      openai: {
        base: "https://api.openai.com/v1",
        chat: "https://api.openai.com/v1/chat/completions",
        models: "https://api.openai.com/v1/models"
      },
      anthropic: {
        base: "https://api.anthropic.com",
        messages: "https://api.anthropic.com/v1/messages"
      },
      google: {
        base: "https://generativelanguage.googleapis.com/v1",
        generateContent: (model) => `https://generativelanguage.googleapis.com/v1/models/${model}:generateContent`
      }
    };
    MODEL_PREFIXES = {
      openai: ["gpt-", "o1-", "text-", "davinci-", "curie-", "babbage-", "ada-"],
      anthropic: ["claude-"],
      google: ["gemini-", "palm-", "chat-bison", "text-bison"]
    };
    MODEL_TOKEN_LIMITS = {
      // OpenAI Î™®Îç∏Îì§
      "gpt-4o": 4096,
      "gpt-4o-mini": 16384,
      "gpt-4-turbo": 4096,
      "gpt-4": 4096,
      "gpt-3.5-turbo": 4096,
      "gpt-3.5-turbo-16k": 4096,
      "o1-preview": 32768,
      "o1-mini": 65536,
      // Anthropic Î™®Îç∏Îì§ (Îß§Ïö∞ ÎÜíÏùÄ ÌïúÍ≥Ñ)
      "claude-3-5-sonnet-20241022": 8192,
      "claude-3-5-haiku-20241022": 8192,
      "claude-3-opus-20240229": 4096,
      "claude-3-sonnet-20240229": 4096,
      "claude-3-haiku-20240307": 4096,
      // Google Î™®Îç∏Îì§
      "gemini-1.5-pro": 8192,
      "gemini-1.5-flash": 8192,
      "gemini-1.5-flash-8b": 8192,
      "gemini-1.0-pro": 2048,
      // Ollama Î™®Îç∏Îì§ (ÏÑ§Ï†ï Í∞ÄÎä•ÌïòÏßÄÎßå Î≥¥ÏàòÏ†ÅÏúºÎ°ú)
      "llama3.2:3b": 2048,
      "llama3.2:1b": 2048,
      "llama3.1:8b": 2048,
      "mistral:7b": 2048,
      "qwen2:7b": 2048
    };
    DEFAULT_AI_SETTINGS = {
      enabled: false,
      // Í∏∞Î≥∏Ï†ÅÏúºÎ°ú ÎπÑÌôúÏÑ±Ìôî
      provider: "openai",
      openaiApiKey: "",
      anthropicApiKey: "",
      googleApiKey: "",
      ollamaEndpoint: "http://localhost:11434",
      model: "gpt-4o-mini",
      maxTokens: 2e3,
      // Í∏∞Î≥∏Í∞í (Î™®Îç∏Î≥Ñ Ï†úÌïú ÎÇ¥ÏóêÏÑú ÏûêÎèô Ï°∞Ï†ïÎê®)
      temperature: 0.1,
      // ÎÇÆÏùÄ Í∞íÏúºÎ°ú ÏÑ§Ï†ïÌïòÏó¨ ÏùºÍ¥ÄÎêú Í≤∞Í≥º ÎèÑÏ∂ú
      showTokenWarning: true,
      // Í∏∞Î≥∏Ï†ÅÏúºÎ°ú ÌÜ†ÌÅ∞ Í≤ΩÍ≥† ÌôúÏÑ±Ìôî
      tokenWarningThreshold: 3e3
      // 3000 ÌÜ†ÌÅ∞ Ïù¥ÏÉÅÏùº Îïå Í≤ΩÍ≥†
    };
  }
});

// src/utils/logger.ts
var logger_exports = {};
__export(logger_exports, {
  Logger: () => Logger
});
var Logger;
var init_logger = __esm({
  "src/utils/logger.ts"() {
    Logger = class {
      static isDevelopment() {
        return true;
      }
      /**
       * ÌòÑÏû¨ Î°úÍ∑∏ Î†àÎ≤®Ïù¥ Ï∂úÎ†• Í∞ÄÎä•ÌïúÏßÄ ÌôïÏù∏Ìï©ÎãàÎã§
       */
      static shouldLog(level) {
        return this.logLevelPriority[level] >= this.logLevelPriority[this.currentLogLevel];
      }
      /**
       * ÏùºÎ∞ò Ï†ïÎ≥¥ Î°úÍ∑∏
       */
      static log(message, ...args) {
        if (!this.shouldLog("INFO"))
          return;
        this.writeLog("INFO", message, args.length > 0 ? args : void 0);
        if (this.isDevelopment()) {
          console.log(`[Korean Grammar Assistant] ${message}`, ...args);
        }
      }
      /**
       * ÎîîÎ≤ÑÍ∑∏ Î°úÍ∑∏ (Í∞úÎ∞ú Î™®ÎìúÏóêÏÑúÎßå)
       */
      static debug(message, ...args) {
        if (!this.shouldLog("DEBUG"))
          return;
        this.writeLog("DEBUG", message, args.length > 0 ? args : void 0);
        if (this.isDevelopment()) {
          console.debug(`[Korean Grammar Assistant DEBUG] ${message}`, ...args);
        }
      }
      /**
       * Í≤ΩÍ≥† Î°úÍ∑∏
       */
      static warn(message, ...args) {
        if (!this.shouldLog("WARN"))
          return;
        this.writeLog("WARN", message, args.length > 0 ? args : void 0);
        if (this.isDevelopment()) {
          console.warn(`[Korean Grammar Assistant WARN] ${message}`, ...args);
        }
      }
      /**
       * ÏóêÎü¨ Î°úÍ∑∏ (ÌîÑÎ°úÎçïÏÖòÏóêÏÑúÎèÑ ÌëúÏãú)
       */
      static error(message, ...args) {
        if (!this.shouldLog("ERROR"))
          return;
        this.writeLog("ERROR", message, args.length > 0 ? args : void 0);
        if (this.isDevelopment()) {
          console.error(`[Korean Grammar Assistant ERROR] ${message}`, ...args);
        } else {
          console.error(`[Korean Grammar Assistant] Error: ${message}`);
        }
      }
      /**
       * ÏÑ±Îä• Ï∏°Ï†ï ÏãúÏûë
       */
      static startTimer(label) {
        const startTime = performance.now();
        return () => {
          const endTime = performance.now();
          const duration = Math.round(endTime - startTime);
          this.debug(`\u23F1\uFE0F ${label}: ${duration}ms`);
          return duration;
        };
      }
      /**
       * ÎπÑÎèôÍ∏∞ Ìï®ÏàòÏùò ÏÑ±Îä•ÏùÑ Ï∏°Ï†ïÌï©ÎãàÎã§
       */
      static async measureAsync(label, fn) {
        const endTimer = this.startTimer(label);
        try {
          const result = await fn();
          endTimer();
          return result;
        } catch (error) {
          endTimer();
          this.error(`${label} \uC2E4\uD589 \uC911 \uC624\uB958:`, error);
          throw error;
        }
      }
      /**
       * Í∑∏Î£π Î°úÍπÖ ÏãúÏûë (Í∞úÎ∞ú Î™®ÎìúÏóêÏÑúÎßå)
       */
      static group(label) {
        if (this.isDevelopment()) {
          console.group(`\u{1F538} ${label}`);
        }
      }
      /**
       * Í∑∏Î£π Î°úÍπÖ Ï¢ÖÎ£å (Í∞úÎ∞ú Î™®ÎìúÏóêÏÑúÎßå)
       */
      static groupEnd() {
        if (this.isDevelopment()) {
          console.groupEnd();
        }
      }
      /**
       * Î°úÍ∑∏ ÌûàÏä§ÌÜ†Î¶¨Î•º Î∞òÌôòÌï©ÎãàÎã§
       */
      static getHistory(level) {
        if (level) {
          return this.logHistory.filter((entry) => entry.level === level);
        }
        return [...this.logHistory];
      }
      /**
       * Î°úÍ∑∏ ÌûàÏä§ÌÜ†Î¶¨Î•º ÌÅ¥Î¶¨Ïñ¥Ìï©ÎãàÎã§
       */
      static clearHistory() {
        this.logHistory = [];
      }
      /**
       * Î°úÍ∑∏ ÌÜµÍ≥ÑÎ•º Î∞òÌôòÌï©ÎãàÎã§
       */
      static getStats() {
        const stats = { DEBUG: 0, INFO: 0, WARN: 0, ERROR: 0, total: 0 };
        for (const entry of this.logHistory) {
          stats[entry.level]++;
          stats.total++;
        }
        return stats;
      }
      /**
       * Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ Î™®ÎãàÌÑ∞ÎßÅ (Í∑ºÏÇ¨Ïπò)
       */
      static getMemoryUsage() {
        const historySize = this.logHistory.length;
        const estimatedBytes = this.logHistory.reduce((total, entry) => {
          return total + entry.message.length * 2 + // UTF-16 Í∞ÄÏ†ï
          (entry.data ? JSON.stringify(entry.data).length * 2 : 0) + 32;
        }, 0);
        return { historySize, estimatedBytes };
      }
      /**
       * ÌûàÏä§ÌÜ†Î¶¨ Ï†ÄÏû• ÌôúÏÑ±Ìôî/ÎπÑÌôúÏÑ±Ìôî
       */
      static setHistoryEnabled(enabled) {
        this.enableHistory = enabled;
        if (!enabled) {
          this.clearHistory();
        }
      }
      /**
       * Î°úÍ∑∏ Î†àÎ≤®ÏùÑ ÏÑ§Ï†ïÌï©ÎãàÎã§ (ÏÑ±Îä• ÏµúÏ†ÅÌôî)
       * @param level - ÏµúÏÜå Ï∂úÎ†• Î°úÍ∑∏ Î†àÎ≤®
       */
      static setLogLevel(level) {
        this.currentLogLevel = level;
        this.debug(`\uB85C\uADF8 \uB808\uBCA8\uC774 ${level}\uB85C \uC124\uC815\uB428`);
      }
      /**
       * ÌòÑÏû¨ Î°úÍ∑∏ Î†àÎ≤®ÏùÑ Î∞òÌôòÌï©ÎãàÎã§
       */
      static getLogLevel() {
        return this.currentLogLevel;
      }
      /**
       * ÌîÑÎ°úÎçïÏÖò ÌôòÍ≤ΩÏóê ÏµúÏ†ÅÌôîÎêú ÏÑ§Ï†ïÏùÑ Ï†ÅÏö©Ìï©ÎãàÎã§
       */
      static configureForProduction() {
        this.setLogLevel("WARN");
        this.setHistoryEnabled(false);
        this.debug("\uD504\uB85C\uB355\uC158 \uBAA8\uB4DC \uB85C\uAE45 \uC124\uC815 \uC801\uC6A9\uB428");
      }
      /**
       * Í∞úÎ∞ú ÌôòÍ≤ΩÏóê ÏµúÏ†ÅÌôîÎêú ÏÑ§Ï†ïÏùÑ Ï†ÅÏö©Ìï©ÎãàÎã§
       */
      static configureForDevelopment() {
        this.setLogLevel("DEBUG");
        this.setHistoryEnabled(true);
        this.debug("\uAC1C\uBC1C \uBAA8\uB4DC \uB85C\uAE45 \uC124\uC815 \uC801\uC6A9\uB428");
      }
      /**
       * Ïã§Ï†ú Î°úÍ∑∏ ÏûëÏÑ± (ÌûàÏä§ÌÜ†Î¶¨ Í¥ÄÎ¶¨)
       */
      static writeLog(level, message, data) {
        if (!this.enableHistory || !this.shouldLog(level))
          return;
        const logEntry = {
          timestamp: new Date(),
          level,
          message,
          data
        };
        this.logHistory.push(logEntry);
        if (this.logHistory.length > this.maxLogHistory) {
          this.logHistory = this.logHistory.slice(-this.maxLogHistory);
        }
      }
    };
    Logger.logHistory = [];
    Logger.maxLogHistory = 1e3;
    Logger.enableHistory = true;
    Logger.currentLogLevel = "INFO";
    // Í∏∞Î≥∏ Î°úÍ∑∏ Î†àÎ≤®
    // Î°úÍ∑∏ Î†àÎ≤® Ïö∞ÏÑ†ÏàúÏúÑ (ÎÇÆÏùÑÏàòÎ°ù Ï§ëÏöî)
    Logger.logLevelPriority = {
      "DEBUG": 0,
      "INFO": 1,
      "WARN": 2,
      "ERROR": 3
    };
  }
});

// src/services/settings.ts
function loadApiConfig() {
  try {
    if (typeof require !== "undefined") {
      const fs = require("fs");
      const path = require("path");
      const configPath = path.join(__dirname, "../../api-config.json");
      if (fs.existsSync(configPath)) {
        const config = JSON.parse(fs.readFileSync(configPath, "utf8"));
        Logger.debug("\uB85C\uCEEC API \uC124\uC815 \uD30C\uC77C\uC744 \uB85C\uB4DC\uD588\uC2B5\uB2C8\uB2E4.");
        return config;
      }
    }
  } catch (error) {
    Logger.debug("\uB85C\uCEEC API \uC124\uC815 \uD30C\uC77C\uC744 \uB85C\uB4DC\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4. \uAE30\uBCF8\uAC12\uC744 \uC0AC\uC6A9\uD569\uB2C8\uB2E4.");
  }
  return {
    apiKey: "",
    // ÏÇ¨Ïö©ÏûêÍ∞Ä ÏßÅÏ†ë ÏûÖÎ†•Ìï¥Ïïº Ìï®
    apiHost: "bareun-api.junlim.org",
    apiPort: 443,
    ignoredWords: [],
    ai: DEFAULT_AI_SETTINGS,
    filterSingleCharErrors: true,
    // Í∏∞Î≥∏Ï†ÅÏúºÎ°ú Ìïú Í∏ÄÏûê Ïò§Î•ò ÌïÑÌÑ∞ÎßÅ ÌôúÏÑ±Ìôî
    inlineMode: DEFAULT_INLINE_MODE_SETTINGS
  };
}
var DEFAULT_INLINE_MODE_SETTINGS, DEFAULT_SETTINGS, SettingsService;
var init_settings = __esm({
  "src/services/settings.ts"() {
    init_aiModels();
    init_logger();
    DEFAULT_INLINE_MODE_SETTINGS = {
      enabled: false,
      underlineStyle: "wavy",
      underlineColor: "#ff0000",
      // üéØ ÏÉàÎ°úÏö¥ ÌÜµÌï© Ìà¥ÌåÅ ÏÑ§Ï†ï (ÌîåÎû´ÌèºÎ≥Ñ ÏûêÎèô ÏµúÏ†ÅÌôî)
      tooltipTrigger: "auto",
      // Í∏∞Î≥∏Í∞í: ÌîåÎû´ÌèºÏóê Îî∞Îùº ÏûêÎèô ÏÑ†ÌÉù
      // üîß Î†àÍ±∞Ïãú ÏÑ§Ï†ï (ÌïòÏúÑ Ìò∏ÌôòÏÑ±, Ï∂îÌõÑ Ï†úÍ±∞ ÏòàÏ†ï)
      showTooltipOnHover: true,
      showTooltipOnClick: true
    };
    DEFAULT_SETTINGS = loadApiConfig();
    SettingsService = class {
      /**
       * ÏÑ§Ï†ï Ïú†Ìö®ÏÑ±ÏùÑ Í≤ÄÏÇ¨Ìï©ÎãàÎã§.
       * @param settings Í≤ÄÏÇ¨Ìï† ÏÑ§Ï†ï
       * @returns Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨ Í≤∞Í≥º
       */
      static validateSettings(settings) {
        const errors = [];
        if (!settings.apiKey || settings.apiKey.trim() === "") {
          errors.push("API \uD0A4\uAC00 \uC124\uC815\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4.");
        }
        if (!settings.apiHost || settings.apiHost.trim() === "") {
          errors.push("API \uD638\uC2A4\uD2B8\uAC00 \uC124\uC815\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4.");
        }
        if (!settings.apiPort || settings.apiPort <= 0 || settings.apiPort > 65535) {
          errors.push("\uC720\uD6A8\uD558\uC9C0 \uC54A\uC740 \uD3EC\uD2B8 \uBC88\uD638\uC785\uB2C8\uB2E4.");
        }
        return {
          isValid: errors.length === 0,
          errors
        };
      }
      /**
       * ÏÑ§Ï†ïÏùÑ Í∏∞Î≥∏Í∞íÍ≥º Î≥ëÌï©Ìï©ÎãàÎã§.
       * @param userSettings ÏÇ¨Ïö©Ïûê ÏÑ§Ï†ï
       * @returns Î≥ëÌï©Îêú ÏÑ§Ï†ï
       */
      static mergeWithDefaults(userSettings) {
        const mergedSettings = Object.assign({}, DEFAULT_SETTINGS, userSettings);
        if (userSettings.ai) {
          mergedSettings.ai = Object.assign({}, DEFAULT_AI_SETTINGS, userSettings.ai);
        } else {
          mergedSettings.ai = Object.assign({}, DEFAULT_AI_SETTINGS);
        }
        if (userSettings.inlineMode) {
          mergedSettings.inlineMode = Object.assign({}, DEFAULT_INLINE_MODE_SETTINGS, userSettings.inlineMode);
        } else {
          mergedSettings.inlineMode = Object.assign({}, DEFAULT_INLINE_MODE_SETTINGS);
        }
        if (userSettings.filterSingleCharErrors === void 0) {
          mergedSettings.filterSingleCharErrors = DEFAULT_SETTINGS.filterSingleCharErrors;
        }
        return mergedSettings;
      }
      /**
       * API ÏóîÎìúÌè¨Ïù∏Ìä∏ URLÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§.
       * @param settings ÌîåÎü¨Í∑∏Ïù∏ ÏÑ§Ï†ï
       * @returns API URL
       */
      static buildApiUrl(settings) {
        const protocol = settings.apiPort === 443 ? "https" : "http";
        const port = settings.apiPort === 443 || settings.apiPort === 80 ? "" : `:${settings.apiPort}`;
        return `${protocol}://${settings.apiHost}${port}/bareun/api/v1/correct-error`;
      }
    };
  }
});

// src/services/errorHandler.ts
var errorHandler_exports = {};
__export(errorHandler_exports, {
  ErrorHandlerService: () => ErrorHandlerService
});
var import_obsidian, ErrorHandlerService;
var init_errorHandler = __esm({
  "src/services/errorHandler.ts"() {
    import_obsidian = require("obsidian");
    init_logger();
    ErrorHandlerService = class {
      /**
       * ÏóêÎü¨Î•º Î∂ÑÏÑùÌïòÍ≥† Ï†ÅÏ†àÌïú ÎåÄÏùë Î∞©ÏïàÏùÑ Ï†úÍ≥µÌï©ÎãàÎã§
       */
      static analyzeError(error, context) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        Logger.error("\uC5D0\uB7EC \uBD84\uC11D \uC2DC\uC791:", { error, context });
        if (error.name === "TypeError" && error.message.includes("fetch")) {
          return {
            type: "NETWORK_ERROR",
            message: "Network request failed",
            userMessage: "\uC778\uD130\uB137 \uC5F0\uACB0\uC744 \uD655\uC778\uD574\uC8FC\uC138\uC694",
            suggestion: "\uB124\uD2B8\uC6CC\uD06C \uC0C1\uD0DC\uB97C \uD655\uC778\uD558\uACE0 \uB2E4\uC2DC \uC2DC\uB3C4\uD574\uC8FC\uC138\uC694.",
            retryable: true,
            details: error
          };
        }
        if (((_a = error.message) == null ? void 0 : _a.includes("API \uD0A4")) || ((_b = error.message) == null ? void 0 : _b.includes("api-key"))) {
          return {
            type: "API_KEY_ERROR",
            message: "Invalid API key",
            userMessage: "API \uD0A4\uAC00 \uC62C\uBC14\uB974\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4",
            suggestion: "\uD50C\uB7EC\uADF8\uC778 \uC124\uC815\uC5D0\uC11C \uC62C\uBC14\uB978 Bareun.ai API \uD0A4\uB97C \uC785\uB825\uD574\uC8FC\uC138\uC694.",
            retryable: false,
            details: error
          };
        }
        if ((_c = error.message) == null ? void 0 : _c.includes("API \uC694\uCCAD \uC2E4\uD328")) {
          const statusMatch = error.message.match(/(\d{3})/);
          const status = statusMatch ? parseInt(statusMatch[1]) : 0;
          switch (Math.floor(status / 100)) {
            case 4:
              if (status === 401 || status === 403) {
                return {
                  type: "API_KEY_ERROR",
                  message: `Authentication failed: ${status}`,
                  userMessage: "API \uD0A4 \uC778\uC99D\uC5D0 \uC2E4\uD328\uD588\uC2B5\uB2C8\uB2E4",
                  suggestion: "API \uD0A4\uAC00 \uC62C\uBC14\uB978\uC9C0 \uD655\uC778\uD558\uACE0, \uB9CC\uB8CC\uB418\uC9C0 \uC54A\uC558\uB294\uC9C0 \uD655\uC778\uD574\uC8FC\uC138\uC694.",
                  retryable: false,
                  details: { status, error }
                };
              } else if (status === 429) {
                return {
                  type: "API_RATE_LIMIT",
                  message: "Rate limit exceeded",
                  userMessage: "API \uC0AC\uC6A9\uB7C9 \uD55C\uB3C4\uB97C \uCD08\uACFC\uD588\uC2B5\uB2C8\uB2E4",
                  suggestion: "\uC7A0\uC2DC \uD6C4 \uB2E4\uC2DC \uC2DC\uB3C4\uD574\uC8FC\uC138\uC694. \uB108\uBB34 \uB9CE\uC740 \uC694\uCCAD\uC744 \uBCF4\uB0B4\uACE0 \uC788\uC2B5\uB2C8\uB2E4.",
                  retryable: true,
                  details: { status, error }
                };
              } else {
                return {
                  type: "API_SERVER_ERROR",
                  message: `Client error: ${status}`,
                  userMessage: "\uC694\uCCAD\uC774 \uC62C\uBC14\uB974\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4",
                  suggestion: "\uD14D\uC2A4\uD2B8 \uB0B4\uC6A9\uC744 \uD655\uC778\uD558\uACE0 \uB2E4\uC2DC \uC2DC\uB3C4\uD574\uC8FC\uC138\uC694.",
                  retryable: false,
                  details: { status, error }
                };
              }
            case 5:
              return {
                type: "API_SERVER_ERROR",
                message: `Server error: ${status}`,
                userMessage: "\uC11C\uBC84\uC5D0 \uC77C\uC2DC\uC801\uC778 \uBB38\uC81C\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4",
                suggestion: "\uC7A0\uC2DC \uD6C4 \uB2E4\uC2DC \uC2DC\uB3C4\uD574\uC8FC\uC138\uC694. \uBB38\uC81C\uAC00 \uACC4\uC18D\uB418\uBA74 Bareun.ai \uC11C\uBE44\uC2A4 \uC0C1\uD0DC\uB97C \uD655\uC778\uD574\uC8FC\uC138\uC694.",
                retryable: true,
                details: { status, error }
              };
            default:
              return {
                type: "API_SERVER_ERROR",
                message: `HTTP error: ${status}`,
                userMessage: "API \uC694\uCCAD\uC5D0 \uC2E4\uD328\uD588\uC2B5\uB2C8\uB2E4",
                suggestion: "\uB124\uD2B8\uC6CC\uD06C \uC0C1\uD0DC\uB97C \uD655\uC778\uD558\uACE0 \uB2E4\uC2DC \uC2DC\uB3C4\uD574\uC8FC\uC138\uC694.",
                retryable: true,
                details: { status, error }
              };
          }
        }
        if (((_d = error.message) == null ? void 0 : _d.includes("\uD0C0\uC784\uC544\uC6C3")) || ((_e = error.message) == null ? void 0 : _e.includes("timeout"))) {
          return {
            type: "TIMEOUT_ERROR",
            message: "Request timeout",
            userMessage: "\uC694\uCCAD \uC2DC\uAC04\uC774 \uCD08\uACFC\uB418\uC5C8\uC2B5\uB2C8\uB2E4",
            suggestion: "\uB124\uD2B8\uC6CC\uD06C\uAC00 \uB290\uB9AC\uAC70\uB098 \uD14D\uC2A4\uD2B8\uAC00 \uB108\uBB34 \uAE41\uB2C8\uB2E4. \uD14D\uC2A4\uD2B8\uB97C \uB098\uB204\uC5B4 \uB2E4\uC2DC \uC2DC\uB3C4\uD574\uC8FC\uC138\uC694.",
            retryable: true,
            details: error
          };
        }
        if (error.name === "SyntaxError" || ((_f = error.message) == null ? void 0 : _f.includes("JSON"))) {
          return {
            type: "PARSE_ERROR",
            message: "Failed to parse response",
            userMessage: "\uC11C\uBC84 \uC751\uB2F5\uC744 \uCC98\uB9AC\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4",
            suggestion: "\uC11C\uBC84\uC5D0 \uC77C\uC2DC\uC801\uC778 \uBB38\uC81C\uAC00 \uC788\uC744 \uC218 \uC788\uC2B5\uB2C8\uB2E4. \uC7A0\uC2DC \uD6C4 \uB2E4\uC2DC \uC2DC\uB3C4\uD574\uC8FC\uC138\uC694.",
            retryable: true,
            details: error
          };
        }
        if (((_g = error.message) == null ? void 0 : _g.includes("\uC720\uD6A8")) || ((_h = error.message) == null ? void 0 : _h.includes("validation"))) {
          return {
            type: "VALIDATION_ERROR",
            message: "Validation failed",
            userMessage: "\uC785\uB825 \uB370\uC774\uD130\uAC00 \uC62C\uBC14\uB974\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4",
            suggestion: "\uD14D\uC2A4\uD2B8 \uB0B4\uC6A9\uC744 \uD655\uC778\uD558\uACE0 \uB2E4\uC2DC \uC2DC\uB3C4\uD574\uC8FC\uC138\uC694.",
            retryable: false,
            details: error
          };
        }
        return {
          type: "UNKNOWN_ERROR",
          message: error.message || "Unknown error occurred",
          userMessage: "\uC608\uC0C1\uCE58 \uBABB\uD55C \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4",
          suggestion: "\uBB38\uC81C\uAC00 \uACC4\uC18D\uB418\uBA74 \uD50C\uB7EC\uADF8\uC778\uC744 \uB2E4\uC2DC \uB85C\uB4DC\uD558\uAC70\uB098 Obsidian\uC744 \uC7AC\uC2DC\uC791\uD574\uC8FC\uC138\uC694.",
          retryable: true,
          details: error
        };
      }
      /**
       * ÏóêÎü¨Î•º Ï≤òÎ¶¨ÌïòÍ≥† ÏÇ¨Ïö©ÏûêÏóêÍ≤å Ï†ÅÏ†àÌïú ÌîºÎìúÎ∞±ÏùÑ Ï†úÍ≥µÌï©ÎãàÎã§
       */
      static handleError(error, context) {
        const errorInfo = this.analyzeError(error, context);
        Logger.error("\uC5D0\uB7EC \uCC98\uB9AC:", {
          type: errorInfo.type,
          context,
          retryable: errorInfo.retryable
        });
        this.showUserNotification(errorInfo);
        return errorInfo;
      }
      /**
       * ÏûêÎèô Ïû¨ÏãúÎèÑÍ∞Ä Í∞ÄÎä•Ìïú Ìï®ÏàòÎ•º Ïã§ÌñâÌï©ÎãàÎã§
       */
      static async withRetry(fn, context, config = {}) {
        const retryConfig = { ...this.DEFAULT_RETRY_CONFIG, ...config };
        const retryKey = `${context}_${Date.now()}`;
        let lastError;
        let attempt = 0;
        while (attempt <= retryConfig.maxRetries) {
          try {
            if (attempt > 0) {
              Logger.debug(`\uC7AC\uC2DC\uB3C4 ${attempt}/${retryConfig.maxRetries}:`, { context });
            }
            const result = await fn();
            if (attempt > 0) {
              Logger.debug("\uC7AC\uC2DC\uB3C4 \uC131\uACF5:", { context, attempt });
            }
            this.retryCount.delete(retryKey);
            return result;
          } catch (error) {
            lastError = error;
            attempt++;
            const errorInfo = this.analyzeError(error, context);
            if (!errorInfo.retryable) {
              Logger.error("\uC7AC\uC2DC\uB3C4 \uBD88\uAC00\uB2A5\uD55C \uC5D0\uB7EC:", { type: errorInfo.type, context });
              throw error;
            }
            if (attempt > retryConfig.maxRetries) {
              Logger.error("\uCD5C\uB300 \uC7AC\uC2DC\uB3C4 \uD69F\uC218 \uB3C4\uB2EC:", { context, attempt });
              break;
            }
            const delay = Math.min(
              retryConfig.baseDelay * Math.pow(retryConfig.backoffFactor, attempt - 1),
              retryConfig.maxDelay
            );
            Logger.warn(`\uC7AC\uC2DC\uB3C4 \uB300\uAE30 \uC911:`, { context, attempt, delay: `${delay}ms` });
            if (attempt === 1) {
              new import_obsidian.Notice(`\uC5F0\uACB0 \uBB38\uC81C\uB85C \uC7AC\uC2DC\uB3C4 \uC911... (${attempt}/${retryConfig.maxRetries})`, 2e3);
            }
            await this.sleep(delay);
          }
        }
        const finalErrorInfo = this.handleError(lastError, `${context} (\uC7AC\uC2DC\uB3C4 ${retryConfig.maxRetries}\uD68C \uC2E4\uD328)`);
        throw lastError;
      }
      /**
       * ÏÇ¨Ïö©ÏûêÏóêÍ≤å ÏπúÌôîÏ†ÅÏù∏ ÏïåÎ¶ºÏùÑ ÌëúÏãúÌï©ÎãàÎã§
       */
      static showUserNotification(errorInfo) {
        const { type, userMessage, suggestion, retryable } = errorInfo;
        const icons = {
          NETWORK_ERROR: "\u{1F310}",
          API_KEY_ERROR: "\u{1F511}",
          API_RATE_LIMIT: "\u23F1\uFE0F",
          API_SERVER_ERROR: "\u{1F527}",
          TIMEOUT_ERROR: "\u23F0",
          PARSE_ERROR: "\u{1F4C4}",
          VALIDATION_ERROR: "\u26A0\uFE0F",
          UNKNOWN_ERROR: "\u2753"
        };
        const icon = icons[type] || "\u274C";
        const retryText = retryable ? " (\uC790\uB3D9 \uC7AC\uC2DC\uB3C4 \uC911)" : "";
        new import_obsidian.Notice(`${icon} ${userMessage}${retryText}`, 4e3);
        if (suggestion) {
          setTimeout(() => {
            new import_obsidian.Notice(`\u{1F4A1} ${suggestion}`, 6e3);
          }, 500);
        }
      }
      /**
       * ÏóêÎü¨ ÌÜµÍ≥ÑÎ•º Î∞òÌôòÌï©ÎãàÎã§
       */
      static getErrorStats() {
        const stats = Logger.getHistory("ERROR");
        const errorStats = {
          NETWORK_ERROR: 0,
          API_KEY_ERROR: 0,
          API_RATE_LIMIT: 0,
          API_SERVER_ERROR: 0,
          TIMEOUT_ERROR: 0,
          PARSE_ERROR: 0,
          VALIDATION_ERROR: 0,
          UNKNOWN_ERROR: 0
        };
        for (const log of stats) {
          if (log.message.includes("\uB124\uD2B8\uC6CC\uD06C") || log.message.includes("fetch")) {
            errorStats.NETWORK_ERROR++;
          } else if (log.message.includes("API \uD0A4") || log.message.includes("\uD0A4")) {
            errorStats.API_KEY_ERROR++;
          } else if (log.message.includes("rate limit") || log.message.includes("429")) {
            errorStats.API_RATE_LIMIT++;
          } else if (log.message.includes("\uD0C0\uC784\uC544\uC6C3") || log.message.includes("timeout")) {
            errorStats.TIMEOUT_ERROR++;
          } else if (log.message.includes("JSON") || log.message.includes("parse")) {
            errorStats.PARSE_ERROR++;
          } else if (log.message.includes("API") || log.message.includes("\uC11C\uBC84")) {
            errorStats.API_SERVER_ERROR++;
          } else {
            errorStats.UNKNOWN_ERROR++;
          }
        }
        return errorStats;
      }
      /**
       * ÎπÑÎèôÍ∏∞ ÎåÄÍ∏∞ Ìó¨Ìçº
       */
      static sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }
      /**
       * Ïû¨ÏãúÎèÑ ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
       */
      static clearRetryState() {
        this.retryCount.clear();
        Logger.debug("\uC7AC\uC2DC\uB3C4 \uC0C1\uD0DC \uCD08\uAE30\uD654\uB428");
      }
    };
    ErrorHandlerService.DEFAULT_RETRY_CONFIG = {
      maxRetries: 3,
      baseDelay: 1e3,
      maxDelay: 1e4,
      backoffFactor: 2
    };
    ErrorHandlerService.retryCount = /* @__PURE__ */ new Map();
  }
});

// src/api/openai-client.ts
var import_obsidian3, OpenAIClient;
var init_openai_client = __esm({
  "src/api/openai-client.ts"() {
    import_obsidian3 = require("obsidian");
    init_aiModels();
    init_logger();
    OpenAIClient = class {
      constructor(apiKey) {
        this.apiKey = apiKey;
      }
      async fetchModels() {
        if (!this.apiKey) {
          return [];
        }
        try {
          const response = await (0, import_obsidian3.requestUrl)({
            url: API_ENDPOINTS.openai.models,
            method: "GET",
            headers: {
              "Authorization": `Bearer ${this.apiKey}`,
              "Content-Type": "application/json"
            }
          });
          if (response.status === 200) {
            const models = response.json.data.map((model) => model.id).filter(
              (id) => MODEL_PREFIXES.openai.some((prefix) => id.startsWith(prefix))
            ).sort();
            Logger.debug(`${models.length}\uAC1C \uBAA8\uB378\uC744 \uAC00\uC838\uC654\uC2B5\uB2C8\uB2E4.`);
            return models;
          }
        } catch (error) {
          Logger.error("\uBAA8\uB378 \uBAA9\uB85D \uAC00\uC838\uC624\uAE30 \uC2E4\uD328:", error);
        }
        return [];
      }
      async chat(messages, maxTokens, model) {
        if (!this.apiKey) {
          throw new Error("OpenAI API \uD0A4\uAC00 \uC124\uC815\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4.");
        }
        if (!this.apiKey.startsWith("sk-")) {
          throw new Error('OpenAI API \uD0A4 \uD615\uC2DD\uC774 \uC62C\uBC14\uB974\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4. "sk-"\uB85C \uC2DC\uC791\uD574\uC57C \uD569\uB2C8\uB2E4.');
        }
        Logger.debug("chat \uC694\uCCAD \uC2DC\uC791:", {
          model,
          maxTokens,
          messagesCount: messages.length,
          apiKeyPrefix: this.apiKey.substring(0, 7) + "..."
        });
        const requestBody = {
          model,
          messages,
          max_tokens: maxTokens,
          temperature: 0.1
        };
        Logger.debug("\uC694\uCCAD \uB370\uC774\uD130:", {
          url: API_ENDPOINTS.openai.chat,
          model,
          messagesCount: messages.length,
          maxTokens,
          bodySize: JSON.stringify(requestBody).length
        });
        let response;
        try {
          response = await (0, import_obsidian3.requestUrl)({
            url: API_ENDPOINTS.openai.chat,
            method: "POST",
            headers: {
              "Authorization": `Bearer ${this.apiKey}`,
              "Content-Type": "application/json"
            },
            body: JSON.stringify(requestBody)
          });
        } catch (error) {
          Logger.error("requestUrl \uC624\uB958:", error);
          Logger.error("\uC694\uCCAD \uC815\uBCF4:", {
            url: API_ENDPOINTS.openai.chat,
            model,
            hasApiKey: !!this.apiKey,
            bodySize: JSON.stringify(requestBody).length
          });
          throw error;
        }
        if (response.status === 200) {
          return response.json.choices[0].message.content.trim();
        } else {
          Logger.error("API \uC751\uB2F5 \uC624\uB958:", {
            status: response.status,
            text: response.text,
            json: response.json
          });
          throw new Error(`OpenAI API \uC624\uB958: ${response.status} - ${response.text || JSON.stringify(response.json)}`);
        }
      }
    };
  }
});

// src/api/anthropic-client.ts
var import_obsidian4, AnthropicClient;
var init_anthropic_client = __esm({
  "src/api/anthropic-client.ts"() {
    import_obsidian4 = require("obsidian");
    init_aiModels();
    init_logger();
    AnthropicClient = class {
      constructor(apiKey) {
        this.apiKey = apiKey;
      }
      async chat(messages, maxTokens, model) {
        if (!this.apiKey) {
          throw new Error("Anthropic API \uD0A4\uAC00 \uC124\uC815\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4.");
        }
        const systemMessage = messages.find((m) => m.role === "system");
        const userMessages = messages.filter((m) => m.role !== "system");
        const response = await (0, import_obsidian4.requestUrl)({
          url: API_ENDPOINTS.anthropic.messages,
          method: "POST",
          headers: {
            "x-api-key": this.apiKey,
            "Content-Type": "application/json",
            "anthropic-version": "2023-06-01"
          },
          body: JSON.stringify({
            model,
            max_tokens: maxTokens,
            temperature: 0.1,
            system: (systemMessage == null ? void 0 : systemMessage.content) || "",
            messages: userMessages
          })
        });
        if (response.status === 200) {
          return response.json.content[0].text.trim();
        } else {
          Logger.error("[Anthropic] API \uC751\uB2F5 \uC624\uB958:", {
            status: response.status,
            text: response.text,
            json: response.json
          });
          throw new Error(`Anthropic API \uC624\uB958: ${response.status} - ${response.text || JSON.stringify(response.json)}`);
        }
      }
    };
  }
});

// src/api/google-client.ts
var import_obsidian5, GoogleClient;
var init_google_client = __esm({
  "src/api/google-client.ts"() {
    import_obsidian5 = require("obsidian");
    init_aiModels();
    init_logger();
    GoogleClient = class {
      constructor(apiKey) {
        this.apiKey = apiKey;
      }
      async chat(messages, maxTokens, model) {
        var _a, _b, _c, _d;
        if (!this.apiKey) {
          throw new Error("Google API \uD0A4\uAC00 \uC124\uC815\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4.");
        }
        const systemMessage = messages.find((m) => m.role === "system");
        const userMessages = messages.filter((m) => m.role !== "system");
        if (systemMessage && userMessages.length > 0) {
          userMessages[0].content = `${systemMessage.content}

${userMessages[0].content}`;
        }
        const contents = userMessages.map((message) => ({
          role: message.role === "assistant" ? "model" : "user",
          parts: [{ text: message.content }]
        }));
        const response = await (0, import_obsidian5.requestUrl)({
          url: `${API_ENDPOINTS.google.generateContent(model)}?key=${this.apiKey}`,
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            contents,
            generationConfig: {
              maxOutputTokens: maxTokens,
              temperature: 0.1
            }
          })
        });
        if (response.status === 200) {
          const candidate = (_a = response.json.candidates) == null ? void 0 : _a[0];
          if ((_d = (_c = (_b = candidate == null ? void 0 : candidate.content) == null ? void 0 : _b.parts) == null ? void 0 : _c[0]) == null ? void 0 : _d.text) {
            return candidate.content.parts[0].text.trim();
          }
          Logger.error("[Google] API \uC751\uB2F5 \uD615\uC2DD \uC624\uB958:", response.json);
          throw new Error("Google API \uC751\uB2F5 \uD615\uC2DD\uC774 \uC62C\uBC14\uB974\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4.");
        } else {
          Logger.error("[Google] API \uC751\uB2F5 \uC624\uB958:", {
            status: response.status,
            text: response.text,
            json: response.json
          });
          throw new Error(`Google API \uC624\uB958: ${response.status} - ${response.text || JSON.stringify(response.json)}`);
        }
      }
    };
  }
});

// src/api/ollama-client.ts
var import_obsidian6, OllamaClient;
var init_ollama_client = __esm({
  "src/api/ollama-client.ts"() {
    import_obsidian6 = require("obsidian");
    OllamaClient = class {
      constructor(endpoint) {
        this.endpoint = endpoint;
      }
      async chat(messages, maxTokens, model) {
        if (!this.endpoint) {
          throw new Error("Ollama \uC5D4\uB4DC\uD3EC\uC778\uD2B8\uAC00 \uC124\uC815\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4.");
        }
        let prompt = "";
        messages.forEach((message) => {
          if (message.role === "system") {
            prompt += `System: ${message.content}

`;
          } else if (message.role === "user") {
            prompt += `Human: ${message.content}

`;
          } else if (message.role === "assistant") {
            prompt += `Assistant: ${message.content}

`;
          }
        });
        prompt += "Assistant: ";
        const response = await (0, import_obsidian6.requestUrl)({
          url: `${this.endpoint}/api/generate`,
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            model,
            prompt,
            options: {
              num_predict: maxTokens,
              temperature: 0.1
            },
            stream: false
          })
        });
        if (response.status === 200) {
          return response.json.response.trim();
        } else {
          throw new Error(`Ollama API \uC624\uB958: ${response.status} - ${response.text}`);
        }
      }
    };
  }
});

// src/api/clientFactory.ts
var clientFactory_exports = {};
__export(clientFactory_exports, {
  AIClientFactory: () => AIClientFactory
});
var AIClientFactory;
var init_clientFactory = __esm({
  "src/api/clientFactory.ts"() {
    init_openai_client();
    init_anthropic_client();
    init_google_client();
    init_ollama_client();
    init_logger();
    AIClientFactory = class {
      static createClient(settings) {
        const provider = settings.provider;
        const apiKey = this.getApiKey(settings);
        Logger.debug("\uD074\uB77C\uC774\uC5B8\uD2B8 \uC0DD\uC131:", {
          provider,
          hasApiKey: !!apiKey,
          apiKeyLength: apiKey ? apiKey.length : 0,
          model: settings.model
        });
        switch (provider) {
          case "openai":
            return new OpenAIClient(settings.openaiApiKey);
          case "anthropic":
            return new AnthropicClient(settings.anthropicApiKey);
          case "google":
            return new GoogleClient(settings.googleApiKey);
          case "ollama":
            return new OllamaClient(settings.ollamaEndpoint);
          default:
            throw new Error(`\uC9C0\uC6D0\uD558\uC9C0 \uC54A\uB294 AI \uC81C\uACF5\uC790\uC785\uB2C8\uB2E4: ${provider}`);
        }
      }
      static async fetchModels(settings) {
        const client = this.createClient(settings);
        if (settings.provider === "ollama" || settings.provider === "anthropic") {
          return [];
        }
        if (!client.fetchModels) {
          return [];
        }
        try {
          return await client.fetchModels();
        } catch (error) {
          Logger.error(`${settings.provider} \uBAA8\uB378 \uBAA9\uB85D \uAC00\uC838\uC624\uAE30 \uC2E4\uD328:`, error);
          return [];
        }
      }
      static getApiKey(settings) {
        switch (settings.provider) {
          case "openai":
            return settings.openaiApiKey;
          case "anthropic":
            return settings.anthropicApiKey;
          case "google":
            return settings.googleApiKey;
          case "ollama":
            return "";
          default:
            return "";
        }
      }
      static hasValidApiKey(settings) {
        if (settings.provider === "ollama") {
          return !!settings.ollamaEndpoint;
        }
        return !!this.getApiKey(settings);
      }
    };
  }
});

// src/services/advancedSettingsService.ts
var advancedSettingsService_exports = {};
__export(advancedSettingsService_exports, {
  AdvancedSettingsService: () => AdvancedSettingsService
});
var AdvancedSettingsService;
var init_advancedSettingsService = __esm({
  "src/services/advancedSettingsService.ts"() {
    init_settings();
    init_logger();
    AdvancedSettingsService = class {
      /**
       * ÏÑ§Ï†ïÏùÑ Ìè¨Í¥ÑÏ†ÅÏúºÎ°ú Í≤ÄÏ¶ùÌï©ÎãàÎã§
       */
      static validateSettings(settings) {
        const result = {
          isValid: true,
          errors: [],
          warnings: [],
          suggestions: []
        };
        if (!settings.apiKey || settings.apiKey.trim() === "") {
          result.errors.push("API \uD0A4\uAC00 \uC124\uC815\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4");
          result.isValid = false;
        } else if (settings.apiKey.length < 10) {
          result.warnings.push("API \uD0A4\uAC00 \uB108\uBB34 \uC9E7\uC2B5\uB2C8\uB2E4. \uC62C\uBC14\uB978 \uD0A4\uC778\uC9C0 \uD655\uC778\uD574\uC8FC\uC138\uC694");
        }
        if (!settings.apiHost || settings.apiHost.trim() === "") {
          result.errors.push("API \uD638\uC2A4\uD2B8\uAC00 \uC124\uC815\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4");
          result.isValid = false;
        } else {
          try {
            new URL(`https://${settings.apiHost}`);
          } catch (e) {
            result.errors.push("API \uD638\uC2A4\uD2B8 \uD615\uC2DD\uC774 \uC62C\uBC14\uB974\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4");
            result.isValid = false;
          }
        }
        if (settings.apiPort < 1 || settings.apiPort > 65535) {
          result.errors.push("API \uD3EC\uD2B8\uB294 1-65535 \uBC94\uC704\uC5EC\uC57C \uD569\uB2C8\uB2E4");
          result.isValid = false;
        }
        if (settings.ai) {
          if (settings.ai.enabled) {
            const hasApiKey = settings.ai.openaiApiKey || settings.ai.anthropicApiKey || settings.ai.googleApiKey || settings.ai.ollamaEndpoint;
            if (!hasApiKey) {
              result.errors.push("AI \uAE30\uB2A5\uC774 \uD65C\uC131\uD654\uB418\uC5C8\uC9C0\uB9CC \uC0AC\uC6A9 \uAC00\uB2A5\uD55C API \uD0A4\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4");
              result.isValid = false;
            }
            if (settings.ai.maxTokens < 100) {
              result.warnings.push("\uCD5C\uB300 \uD1A0\uD070 \uC218\uAC00 \uB108\uBB34 \uC801\uC2B5\uB2C8\uB2E4. \uBCF5\uC7A1\uD55C \uBD84\uC11D\uC5D0 \uC81C\uD55C\uC774 \uC788\uC744 \uC218 \uC788\uC2B5\uB2C8\uB2E4");
            } else if (settings.ai.maxTokens > 8e3) {
              result.warnings.push("\uCD5C\uB300 \uD1A0\uD070 \uC218\uAC00 \uB9E4\uC6B0 \uD07D\uB2C8\uB2E4. \uBE44\uC6A9\uC774 \uB9CE\uC774 \uBC1C\uC0DD\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4");
            }
            if (settings.ai.provider === "ollama" && !settings.ai.ollamaEndpoint) {
              result.errors.push("Ollama \uD504\uB85C\uBC14\uC774\uB354 \uC120\uD0DD \uC2DC \uC5D4\uB4DC\uD3EC\uC778\uD2B8\uAC00 \uD544\uC694\uD569\uB2C8\uB2E4");
              result.isValid = false;
            }
          }
        }
        if (settings.ignoredWords && settings.ignoredWords.length > 1e3) {
          result.warnings.push(`\uC608\uC678 \uB2E8\uC5B4\uAC00 ${settings.ignoredWords.length}\uAC1C\uB85C \uB9E4\uC6B0 \uB9CE\uC2B5\uB2C8\uB2E4. \uC131\uB2A5\uC5D0 \uC601\uD5A5\uC744 \uC904 \uC218 \uC788\uC2B5\uB2C8\uB2E4`);
        }
        if (settings.ignoredWords && settings.ignoredWords.length > 100) {
          result.suggestions.push("\uC608\uC678 \uB2E8\uC5B4\uAC00 \uB9CE\uC2B5\uB2C8\uB2E4. \uC815\uAE30\uC801\uC73C\uB85C \uBD88\uD544\uC694\uD55C \uB2E8\uC5B4\uB97C \uC815\uB9AC\uD558\uB294 \uAC83\uC744 \uAD8C\uC7A5\uD569\uB2C8\uB2E4");
        }
        if (settings.ai && settings.ai.enabled && settings.ai.maxTokens > 4e3) {
          result.suggestions.push("AI \uD1A0\uD070 \uC218\uB97C \uC904\uC774\uBA74 \uC751\uB2F5 \uC18D\uB3C4\uAC00 \uD5A5\uC0C1\uB429\uB2C8\uB2E4");
        }
        Logger.debug("\uC124\uC815 \uAC80\uC99D \uC644\uB8CC:", {
          isValid: result.isValid,
          errorsCount: result.errors.length,
          warningsCount: result.warnings.length
        });
        return result;
      }
      /**
       * ÏÑ§Ï†ïÏùÑ Î∞±ÏóÖÌï©ÎãàÎã§
       */
      static backupSettings(settings, reason = "\uC218\uB3D9 \uBC31\uC5C5") {
        const backup = {
          timestamp: Date.now(),
          version: "0.2.0",
          // ÌòÑÏû¨ ÌîåÎü¨Í∑∏Ïù∏ Î≤ÑÏ†Ñ
          settings: JSON.parse(JSON.stringify(settings)),
          // ÍπäÏùÄ Î≥µÏÇ¨
          reason
        };
        this.backups.unshift(backup);
        if (this.backups.length > this.MAX_BACKUPS) {
          this.backups = this.backups.slice(0, this.MAX_BACKUPS);
        }
        Logger.debug("\uC124\uC815 \uBC31\uC5C5 \uC0DD\uC131:", { reason, backupCount: this.backups.length });
      }
      /**
       * Î∞±ÏóÖÏóêÏÑú ÏÑ§Ï†ïÏùÑ Î≥µÏõêÌï©ÎãàÎã§
       */
      static restoreSettings(backupIndex) {
        if (backupIndex < 0 || backupIndex >= this.backups.length) {
          Logger.error("\uC798\uBABB\uB41C \uBC31\uC5C5 \uC778\uB371\uC2A4:", { backupIndex, availableBackups: this.backups.length });
          return null;
        }
        const backup = this.backups[backupIndex];
        const restoredSettings = JSON.parse(JSON.stringify(backup.settings));
        Logger.debug("\uC124\uC815 \uBCF5\uC6D0:", {
          backupTimestamp: new Date(backup.timestamp).toISOString(),
          reason: backup.reason
        });
        return restoredSettings;
      }
      /**
       * Î∞±ÏóÖ Î™©Î°ùÏùÑ Î∞òÌôòÌï©ÎãàÎã§
       */
      static getBackups() {
        return this.backups.map((backup, index) => ({
          index,
          timestamp: new Date(backup.timestamp).toLocaleString(),
          reason: backup.reason,
          version: backup.version,
          age: this.formatAge(Date.now() - backup.timestamp)
        }));
      }
      /**
       * ÏÑ§Ï†ï ÌîÑÎ°úÌååÏùºÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§
       */
      static createProfile(name, description, settings) {
        const profile = {
          id: this.generateId(),
          name: name.trim(),
          description: description.trim(),
          settings: JSON.parse(JSON.stringify(settings)),
          isDefault: false,
          createdAt: Date.now(),
          lastUsed: Date.now()
        };
        this.profiles.push(profile);
        Logger.debug("\uC124\uC815 \uD504\uB85C\uD30C\uC77C \uC0DD\uC131:", { name, id: profile.id });
        return profile.id;
      }
      /**
       * ÏÑ§Ï†ï ÌîÑÎ°úÌååÏùºÏùÑ Ï†ÅÏö©Ìï©ÎãàÎã§
       */
      static applyProfile(profileId, currentSettings) {
        const profile = this.profiles.find((p) => p.id === profileId);
        if (!profile) {
          Logger.error("\uD504\uB85C\uD30C\uC77C\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC74C:", { profileId });
          return currentSettings;
        }
        const mergedSettings = this.mergeSettings(currentSettings, profile.settings);
        profile.lastUsed = Date.now();
        Logger.debug("\uC124\uC815 \uD504\uB85C\uD30C\uC77C \uC801\uC6A9:", { name: profile.name, id: profileId });
        return mergedSettings;
      }
      /**
       * ÌîÑÎ°úÌååÏùº Î™©Î°ùÏùÑ Î∞òÌôòÌï©ÎãàÎã§
       */
      static getProfiles() {
        return this.profiles.map((profile) => ({
          id: profile.id,
          name: profile.name,
          description: profile.description,
          isDefault: profile.isDefault,
          createdAt: new Date(profile.createdAt).toLocaleString(),
          lastUsed: new Date(profile.lastUsed).toLocaleString()
        }));
      }
      /**
       * ÌîÑÎ°úÌååÏùºÏùÑ ÏÇ≠Ï†úÌï©ÎãàÎã§
       */
      static deleteProfile(profileId) {
        const index = this.profiles.findIndex((p) => p.id === profileId);
        if (index === -1) {
          return false;
        }
        const profile = this.profiles[index];
        if (profile.isDefault) {
          Logger.debug("\uAE30\uBCF8 \uD504\uB85C\uD30C\uC77C\uC740 \uC0AD\uC81C\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4:", { profileId });
          return false;
        }
        this.profiles.splice(index, 1);
        Logger.debug("\uC124\uC815 \uD504\uB85C\uD30C\uC77C \uC0AD\uC81C:", { name: profile.name, id: profileId });
        return true;
      }
      /**
       * ÏÑ§Ï†ï Î≥ÄÍ≤ΩÏùÑ Ï∂îÏ†ÅÌï©ÎãàÎã§
       */
      static trackChange(field, oldValue, newValue, reason) {
        const change = {
          timestamp: Date.now(),
          field,
          oldValue: JSON.parse(JSON.stringify(oldValue)),
          newValue: JSON.parse(JSON.stringify(newValue)),
          reason
        };
        this.changeHistory.unshift(change);
        if (this.changeHistory.length > this.MAX_HISTORY) {
          this.changeHistory = this.changeHistory.slice(0, this.MAX_HISTORY);
        }
        Logger.debug("\uC124\uC815 \uBCC0\uACBD \uCD94\uC801:", { field, reason });
      }
      /**
       * Î≥ÄÍ≤Ω ÌûàÏä§ÌÜ†Î¶¨Î•º Î∞òÌôòÌï©ÎãàÎã§
       */
      static getChangeHistory(limit = 20) {
        return this.changeHistory.slice(0, limit).map((change) => ({
          timestamp: new Date(change.timestamp).toLocaleString(),
          field: change.field,
          oldValue: this.stringifyValue(change.oldValue),
          newValue: this.stringifyValue(change.newValue),
          reason: change.reason,
          age: this.formatAge(Date.now() - change.timestamp)
        }));
      }
      /**
       * ÏÑ§Ï†ïÏùÑ Í∏∞Î≥∏Í∞íÏúºÎ°ú Ïû¨ÏÑ§Ï†ïÌï©ÎãàÎã§
       */
      static resetToDefaults(currentSettings) {
        this.backupSettings(currentSettings, "\uAE30\uBCF8\uAC12 \uC7AC\uC124\uC815 \uC804 \uBC31\uC5C5");
        const defaultSettings = {
          apiKey: "",
          apiHost: "bareun-api.junlim.org",
          apiPort: 443,
          ignoredWords: [],
          ai: {
            enabled: false,
            provider: "openai",
            openaiApiKey: "",
            anthropicApiKey: "",
            googleApiKey: "",
            ollamaEndpoint: "http://localhost:11434",
            model: "gpt-4o-mini",
            maxTokens: 2e3,
            temperature: 0.3,
            showTokenWarning: true,
            tokenWarningThreshold: 1500
          },
          filterSingleCharErrors: true,
          inlineMode: DEFAULT_INLINE_MODE_SETTINGS
        };
        Logger.debug("\uC124\uC815\uC744 \uAE30\uBCF8\uAC12\uC73C\uB85C \uC7AC\uC124\uC815");
        return defaultSettings;
      }
      /**
       * ÏÑ§Ï†ïÏùÑ ÎÇ¥Î≥¥ÎÉÖÎãàÎã§ (JSON ÌòïÌÉú)
       */
      static exportSettings(settings) {
        const exportData = {
          version: "0.2.0",
          timestamp: Date.now(),
          settings,
          metadata: {
            exportedBy: "Korean Grammar Assistant",
            platform: navigator.platform,
            userAgent: navigator.userAgent.substring(0, 100)
          }
        };
        return JSON.stringify(exportData, null, 2);
      }
      /**
       * ÏÑ§Ï†ïÏùÑ Í∞ÄÏ†∏ÏòµÎãàÎã§ (JSONÏóêÏÑú)
       */
      static importSettings(jsonData) {
        try {
          const importData = JSON.parse(jsonData);
          if (!importData.settings) {
            return { success: false, error: "\uC720\uD6A8\uD558\uC9C0 \uC54A\uC740 \uC124\uC815 \uD30C\uC77C\uC785\uB2C8\uB2E4" };
          }
          const settings = importData.settings;
          const validation = this.validateSettings(settings);
          if (!validation.isValid) {
            return {
              success: false,
              error: `\uC124\uC815 \uC720\uD6A8\uC131 \uAC80\uC0AC \uC2E4\uD328: ${validation.errors.join(", ")}`
            };
          }
          Logger.debug("\uC124\uC815 \uAC00\uC838\uC624\uAE30 \uC131\uACF5:", { version: importData.version });
          return { success: true, settings };
        } catch (error) {
          Logger.error("\uC124\uC815 \uAC00\uC838\uC624\uAE30 \uC2E4\uD328:", error);
          return { success: false, error: "\uC124\uC815 \uD30C\uC77C\uC744 \uD30C\uC2F1\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4" };
        }
      }
      /**
       * ÏÑ±Îä• ÏµúÏ†ÅÌôî Ï†úÏïàÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§
       */
      static getOptimizationSuggestions(settings) {
        var _a;
        const suggestions = [];
        if ((_a = settings.ai) == null ? void 0 : _a.enabled) {
          if (settings.ai.maxTokens > 4e3) {
            suggestions.push({
              type: "cost",
              title: "AI \uD1A0\uD070 \uC218 \uCD5C\uC801\uD654",
              description: "\uB192\uC740 \uD1A0\uD070 \uC218\uB294 \uBE44\uC6A9 \uC99D\uAC00\uC640 \uC751\uB2F5 \uC9C0\uC5F0\uC744 \uC77C\uC73C\uD0AC \uC218 \uC788\uC2B5\uB2C8\uB2E4",
              impact: "medium",
              action: "\uD1A0\uD070 \uC218\uB97C 2000-3000\uC73C\uB85C \uC870\uC815\uD558\uB294 \uAC83\uC744 \uAD8C\uC7A5\uD569\uB2C8\uB2E4"
            });
          }
          if (!settings.ai.openaiApiKey && !settings.ai.anthropicApiKey && !settings.ai.googleApiKey && !settings.ai.ollamaEndpoint) {
            suggestions.push({
              type: "usability",
              title: "AI API \uD0A4 \uC124\uC815",
              description: "AI \uAE30\uB2A5\uC774 \uD65C\uC131\uD654\uB418\uC5C8\uC9C0\uB9CC \uC0AC\uC6A9 \uAC00\uB2A5\uD55C API \uD0A4\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4",
              impact: "high",
              action: "\uCD5C\uC18C \uD558\uB098\uC758 AI \uC11C\uBE44\uC2A4 API \uD0A4\uB97C \uC124\uC815\uD574\uC8FC\uC138\uC694"
            });
          }
        }
        if (settings.ignoredWords.length > 500) {
          suggestions.push({
            type: "performance",
            title: "\uC608\uC678 \uB2E8\uC5B4 \uC815\uB9AC",
            description: "\uB108\uBB34 \uB9CE\uC740 \uC608\uC678 \uB2E8\uC5B4\uB294 \uAC80\uC0AC \uC131\uB2A5\uC744 \uC800\uD558\uC2DC\uD0AC \uC218 \uC788\uC2B5\uB2C8\uB2E4",
            impact: "medium",
            action: "\uBD88\uD544\uC694\uD55C \uC608\uC678 \uB2E8\uC5B4\uB97C \uC815\uB9AC\uD558\uB294 \uAC83\uC744 \uAD8C\uC7A5\uD569\uB2C8\uB2E4"
          });
        }
        return suggestions;
      }
      /**
       * ÏÑ§Ï†ïÏùÑ Î≥ëÌï©Ìï©ÎãàÎã§
       */
      static mergeSettings(base, override) {
        const merged = JSON.parse(JSON.stringify(base));
        Object.keys(override).forEach((key) => {
          const value = override[key];
          if (value !== void 0) {
            if (typeof value === "object" && value !== null && !Array.isArray(value)) {
              merged[key] = { ...merged[key], ...value };
            } else {
              merged[key] = value;
            }
          }
        });
        return merged;
      }
      /**
       * Í≥†Ïú† IDÎ•º ÏÉùÏÑ±Ìï©ÎãàÎã§
       */
      static generateId() {
        return Date.now().toString(36) + Math.random().toString(36).substr(2);
      }
      /**
       * Í∞íÏùÑ Î¨∏ÏûêÏó¥Î°ú Î≥ÄÌôòÌï©ÎãàÎã§
       */
      static stringifyValue(value) {
        if (typeof value === "string") {
          return value.length > 50 ? value.substring(0, 50) + "..." : value;
        }
        if (Array.isArray(value)) {
          return `\uBC30\uC5F4 (${value.length}\uAC1C \uD56D\uBAA9)`;
        }
        if (typeof value === "object" && value !== null) {
          return `\uAC1D\uCCB4 (${Object.keys(value).length}\uAC1C \uC18D\uC131)`;
        }
        return String(value);
      }
      /**
       * ÏãúÍ∞Ñ Ï∞®Ïù¥Î•º Ìè¨Îß∑Ìï©ÎãàÎã§
       */
      static formatAge(ms) {
        const seconds = Math.floor(ms / 1e3);
        const minutes = Math.floor(seconds / 60);
        const hours = Math.floor(minutes / 60);
        const days = Math.floor(hours / 24);
        if (days > 0)
          return `${days}\uC77C \uC804`;
        if (hours > 0)
          return `${hours}\uC2DC\uAC04 \uC804`;
        if (minutes > 0)
          return `${minutes}\uBD84 \uC804`;
        return `${seconds}\uCD08 \uC804`;
      }
    };
    AdvancedSettingsService.MAX_BACKUPS = 10;
    AdvancedSettingsService.MAX_HISTORY = 100;
    AdvancedSettingsService.backups = [];
    AdvancedSettingsService.profiles = [];
    AdvancedSettingsService.changeHistory = [];
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => KoreanGrammarPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian15 = require("obsidian");
init_settings();

// src/orchestrator.ts
var import_obsidian8 = require("obsidian");

// src/services/api.ts
init_logger();
init_errorHandler();
var SpellCheckApiService = class {
  constructor() {
    this.morphemeCache = /* @__PURE__ */ new Map();
    this.maxCacheSize = 100;
  }
  // ÏµúÎåÄ 100Í∞ú Ï∫êÏãú Ïú†ÏßÄ
  /**
   * ÌÖçÏä§Ìä∏Ïùò ÌòïÌÉúÏÜåÎ•º Î∂ÑÏÑùÌï©ÎãàÎã§ (Ï∫êÏã± Î∞è ÏµúÏ†ÅÌôî Ï†ÅÏö©).
   * @param text Î∂ÑÏÑùÌï† ÌÖçÏä§Ìä∏
   * @param settings ÌîåÎü¨Í∑∏Ïù∏ ÏÑ§Ï†ï
   * @returns ÌòïÌÉúÏÜå Î∂ÑÏÑù Í≤∞Í≥º
   */
  async analyzeMorphemes(text, settings) {
    const cacheKey = `morpheme_${this.hashText(text)}`;
    const cachedResult = this.morphemeCache.get(cacheKey);
    if (cachedResult) {
      Logger.debug("\uD615\uD0DC\uC18C \uBD84\uC11D \uCE90\uC2DC\uC5D0\uC11C \uACB0\uACFC \uBC18\uD658:", { textLength: text.length });
      return cachedResult;
    }
    try {
      const result = await this.executeMorphemeRequest(text, settings);
      this.morphemeCache.set(cacheKey, result);
      this.manageCacheSize();
      return result;
    } catch (error) {
      Logger.error("\uD615\uD0DC\uC18C \uBD84\uC11D \uC2E4\uD328:", error);
      throw error;
    }
  }
  /**
   * Ïã§Ï†ú ÌòïÌÉúÏÜå Î∂ÑÏÑù API ÏöîÏ≤≠ÏùÑ ÏàòÌñâÌï©ÎãàÎã§.
   */
  async executeMorphemeRequest(text, settings) {
    const protocol = settings.apiPort === 443 ? "https" : "http";
    const port = settings.apiPort === 443 || settings.apiPort === 80 ? "" : `:${settings.apiPort}`;
    const apiUrl = `${protocol}://${settings.apiHost}${port}/bareun/api/v1/analyze`;
    const requestBody = {
      document: {
        content: text,
        language: "ko-KR"
      },
      encoding_type: "UTF8"
    };
    Logger.debug("\uD615\uD0DC\uC18C \uBD84\uC11D API \uC694\uCCAD:", {
      url: apiUrl,
      textLength: text.length,
      cached: false
    });
    return await ErrorHandlerService.withRetry(
      async () => {
        var _a, _b;
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 1e4);
        try {
          const response = await fetch(apiUrl, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "api-key": settings.apiKey
            },
            body: JSON.stringify(requestBody),
            signal: controller.signal
          });
          clearTimeout(timeoutId);
          if (!response.ok) {
            const errorText = await response.text();
            Logger.error("\uD615\uD0DC\uC18C \uBD84\uC11D API \uC624\uB958:", {
              status: response.status,
              statusText: response.statusText,
              errorBody: errorText
            });
            throw new Error(`\uD615\uD0DC\uC18C \uBD84\uC11D API \uC694\uCCAD \uC2E4\uD328: ${response.status} ${response.statusText}`);
          }
          const data = await response.json();
          Logger.debug("\uD615\uD0DC\uC18C \uBD84\uC11D API \uC751\uB2F5 \uC131\uACF5:", {
            textLength: text.length,
            tokensCount: ((_a = data.sentences) == null ? void 0 : _a.reduce((count, sentence) => count + sentence.tokens.length, 0)) || 0,
            sentencesCount: ((_b = data.sentences) == null ? void 0 : _b.length) || 0
          });
          return data;
        } catch (error) {
          clearTimeout(timeoutId);
          if (error.name === "AbortError") {
            throw new Error("\uD615\uD0DC\uC18C \uBD84\uC11D \uC694\uCCAD \uD0C0\uC784\uC544\uC6C3 (10\uCD08)");
          }
          throw error;
        }
      },
      `morpheme-analysis-${text.substring(0, 50)}`,
      {
        maxRetries: 2,
        baseDelay: 1e3,
        maxDelay: 3e3,
        backoffFactor: 1.5
      }
    );
  }
  /**
   * ÌÖçÏä§Ìä∏Î•º Ìï¥ÏãúÌï©ÎãàÎã§ (Ï∫êÏãú ÌÇ§ ÏÉùÏÑ±Ïö©).
   */
  hashText(text) {
    let hash = 0;
    for (let i = 0; i < text.length; i++) {
      const char = text.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return hash.toString(36);
  }
  /**
   * Ï∫êÏãú ÌÅ¨Í∏∞Î•º Í¥ÄÎ¶¨Ìï©ÎãàÎã§ (LRU Î∞©Ïãù).
   */
  manageCacheSize() {
    if (this.morphemeCache.size > this.maxCacheSize) {
      const firstKey = this.morphemeCache.keys().next().value;
      this.morphemeCache.delete(firstKey);
      Logger.debug("\uD615\uD0DC\uC18C \uCE90\uC2DC \uD06C\uAE30 \uAD00\uB9AC: \uC624\uB798\uB41C \uD56D\uBAA9 \uC0AD\uC81C");
    }
  }
  /**
   * Ï∫êÏãúÎ•º ÏàòÎèôÏúºÎ°ú Ï†ïÎ¶¨Ìï©ÎãàÎã§.
   */
  clearMorphemeCache() {
    this.morphemeCache.clear();
    Logger.debug("\uD615\uD0DC\uC18C \uCE90\uC2DC \uC815\uB9AC \uC644\uB8CC");
  }
  /**
   * Ï∫êÏãú ÌÜµÍ≥ÑÎ•º Î∞òÌôòÌï©ÎãàÎã§.
   */
  getMorphemeCacheStats() {
    return {
      size: this.morphemeCache.size,
      maxSize: this.maxCacheSize
    };
  }
  /**
   * ÌÖçÏä§Ìä∏Ïùò ÎßûÏ∂§Î≤ïÏùÑ Í≤ÄÏÇ¨Ìï©ÎãàÎã§.
   * @param text Í≤ÄÏÇ¨Ìï† ÌÖçÏä§Ìä∏
   * @param settings ÌîåÎü¨Í∑∏Ïù∏ ÏÑ§Ï†ï
   * @returns Í≤ÄÏÇ¨ Í≤∞Í≥º
   */
  async checkSpelling(text, settings) {
    if (!settings.apiKey || settings.apiKey.trim() === "") {
      throw new Error("API \uD0A4\uAC00 \uC124\uC815\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4. \uD50C\uB7EC\uADF8\uC778 \uC124\uC815\uC5D0\uC11C Bareun.ai API \uD0A4\uB97C \uC785\uB825\uD574\uC8FC\uC138\uC694.");
    }
    const protocol = settings.apiPort === 443 ? "https" : "http";
    const port = settings.apiPort === 443 || settings.apiPort === 80 ? "" : `:${settings.apiPort}`;
    const apiUrl = `${protocol}://${settings.apiHost}${port}/bareun/api/v1/correct-error`;
    const requestBody = {
      document: {
        content: text,
        type: "PLAIN_TEXT"
      },
      encoding_type: "UTF8",
      auto_split: false
      // üîß ÏûêÎèô Î∂ÑÌï† ÎπÑÌôúÏÑ±ÌôîÌïòÏó¨ Î∂àÌïÑÏöîÌïú ÍµêÏ†ï Î∞©ÏßÄ
    };
    const response = await fetch(apiUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "api-key": settings.apiKey
      },
      body: JSON.stringify(requestBody)
    });
    if (!response.ok) {
      throw new Error(`API \uC694\uCCAD \uC2E4\uD328: ${response.status} ${response.statusText}`);
    }
    const data = await response.json();
    return this.parseBareunResults(data, text, settings);
  }
  /**
   * Bareun.ai API ÏùëÎãµÏùÑ ÌååÏã±ÌïòÏó¨ ÍµêÏ†ï Ï†ïÎ≥¥Î•º Ï∂îÏ∂úÌï©ÎãàÎã§.
   * @param data API ÏùëÎãµ Îç∞Ïù¥ÌÑ∞
   * @param originalText ÏõêÎ≥∏ ÌÖçÏä§Ìä∏
   * @param settings ÌîåÎü¨Í∑∏Ïù∏ ÏÑ§Ï†ï
   * @returns ÌååÏã±Îêú Í≤∞Í≥º
   */
  parseBareunResults(data, originalText, settings) {
    var _a;
    const corrections = [];
    let resultOutput = data.revised || originalText;
    const correctionMap = /* @__PURE__ */ new Map();
    Logger.debug("=== Bareun API \uC751\uB2F5 \uBD84\uC11D ===");
    Logger.debug("\uC6D0\uBCF8 \uD14D\uC2A4\uD2B8:", originalText);
    Logger.debug("\uAD50\uC815\uB41C \uD14D\uC2A4\uD2B8:", data.revised);
    Logger.debug("revisedSentences \uC218:", ((_a = data.revisedSentences) == null ? void 0 : _a.length) || 0);
    const cleanOriginal = originalText.trim().replace(/\s+/g, " ");
    const cleanRevised = (data.revised || "").trim().replace(/\s+/g, " ");
    Logger.log("\u{1F50D} \uC804\uCCB4 \uD14D\uC2A4\uD2B8 \uBE44\uAD50:");
    Logger.log("  \uC815\uB9AC\uB41C \uC6D0\uBCF8:", `"${cleanOriginal}"`);
    Logger.log("  \uC815\uB9AC\uB41C \uAD50\uC815:", `"${cleanRevised}"`);
    Logger.log("  \uD14D\uC2A4\uD2B8 \uB3D9\uC77C \uC5EC\uBD80:", cleanOriginal === cleanRevised);
    if (cleanOriginal === cleanRevised) {
      Logger.log("\u2705 \uC804\uCCB4 \uD14D\uC2A4\uD2B8 \uAC80\uC99D: \uC6D0\uBCF8\uACFC \uAD50\uC815\uBCF8\uC774 \uB3D9\uC77C\uD558\uC5EC \uC624\uB958 \uC5C6\uC74C\uC73C\uB85C \uCC98\uB9AC");
      return {
        resultOutput: originalText,
        corrections: []
      };
    }
    if (data.revisedSentences && Array.isArray(data.revisedSentences)) {
      data.revisedSentences.forEach((sentence, sentenceIndex) => {
        var _a2;
        Logger.debug(`
--- \uBB38\uC7A5 ${sentenceIndex + 1} ---`);
        Logger.debug("\uC6D0\uBCF8 \uBB38\uC7A5:", sentence.origin);
        Logger.debug("\uAD50\uC815\uB41C \uBB38\uC7A5:", sentence.revised);
        Logger.debug("revisedBlocks \uC218:", ((_a2 = sentence.revisedBlocks) == null ? void 0 : _a2.length) || 0);
        if (sentence.revisedBlocks && Array.isArray(sentence.revisedBlocks)) {
          sentence.revisedBlocks.forEach((block, blockIndex) => {
            var _a3, _b, _c, _d, _e, _f;
            Logger.log(`
  \uBE14\uB85D ${blockIndex + 1}:`);
            Logger.debug(`  \uC804\uCCB4 \uBE14\uB85D \uC815\uBCF4:`, JSON.stringify(block, null, 2));
            Logger.debug("  \uC6D0\uBCF8 \uB0B4\uC6A9:", (_a3 = block.origin) == null ? void 0 : _a3.content);
            Logger.debug("  \uC6D0\uBCF8 \uC704\uCE58:", `${(_b = block.origin) == null ? void 0 : _b.beginOffset}-${((_c = block.origin) == null ? void 0 : _c.beginOffset) + ((_d = block.origin) == null ? void 0 : _d.length)}`);
            Logger.debug("  \uAD50\uC815:", block.revised);
            Logger.debug("  \uC81C\uC548 \uC218:", ((_e = block.revisions) == null ? void 0 : _e.length) || 0);
            if (block.origin && block.revised && block.revisions) {
              const blockOriginalText = block.origin.content;
              Logger.log(`\u{1F4DD} \uBE14\uB85D \uC0C1\uC138 \uBD84\uC11D:`);
              Logger.log(`  \uC6D0\uBCF8: "${blockOriginalText}"`);
              Logger.log(`  \uAD50\uC815: "${block.revised}"`);
              Logger.log(`  \uC6D0\uBCF8 = \uAD50\uC815: ${blockOriginalText === block.revised}`);
              if (blockOriginalText === block.revised) {
                Logger.debug("  -> \uC6D0\uBCF8\uACFC \uAD50\uC815\uBCF8\uC774 \uB3D9\uC77C\uD558\uC5EC \uAC74\uB108\uB700");
                return;
              }
              if (!blockOriginalText || blockOriginalText.trim().length === 0) {
                Logger.debug("  -> \uBE48 \uD14D\uC2A4\uD2B8\uB85C \uAC74\uB108\uB700");
                return;
              }
              if (originalText.indexOf(blockOriginalText) === -1) {
                Logger.debug("  -> \uC6D0\uBCF8 \uD14D\uC2A4\uD2B8\uC5D0\uC11C \uCC3E\uC744 \uC218 \uC5C6\uC5B4 \uAC74\uB108\uB700");
                return;
              }
              const suggestions = block.revisions.map((rev) => rev.revised);
              Logger.debug(`  \u{1F50D} API\uC5D0\uC11C \uBC1B\uC740 \uC81C\uC548 \uC218: ${suggestions.length}\uAC1C`);
              Logger.debug("  \uC81C\uC548\uB4E4:", suggestions);
              const uniqueSuggestions = [...new Set(suggestions)].filter((s) => {
                const isValid = s !== blockOriginalText && s.trim() !== blockOriginalText.trim() && s.length > 0 && !s.includes("\uFFFD");
                Logger.debug(`    "${s}" \u2192 "${blockOriginalText}" \uC720\uD6A8\uC131: ${isValid}`);
                return isValid;
              });
              Logger.debug(`  \u2705 \uC911\uBCF5\uC81C\uAC70 \uD6C4 \uC720\uD6A8\uD55C \uC81C\uC548 \uC218: ${uniqueSuggestions.length}\uAC1C`);
              Logger.debug("  \uC720\uD6A8\uD55C \uC81C\uC548\uB4E4:", uniqueSuggestions);
              const filteredSuggestions = this.applySingleCharFilter(
                blockOriginalText,
                uniqueSuggestions,
                settings.filterSingleCharErrors
              );
              Logger.debug(`  \u{1F680} \uCD5C\uC885 \uD544\uD130\uB9C1\uB41C \uC81C\uC548 \uC218: ${filteredSuggestions.length}\uAC1C`);
              Logger.debug("  \uD544\uD130\uB9C1\uB41C \uC81C\uC548\uB4E4:", filteredSuggestions);
              if (filteredSuggestions.length > 0) {
                if (correctionMap.has(blockOriginalText)) {
                  Logger.debug("  -> \uAE30\uC874 \uAD50\uC815\uC5D0 \uC81C\uC548 \uCD94\uAC00");
                  const existing = correctionMap.get(blockOriginalText);
                  const combinedSuggestions = [.../* @__PURE__ */ new Set([...existing.corrected, ...filteredSuggestions])];
                  correctionMap.set(blockOriginalText, {
                    ...existing,
                    corrected: combinedSuggestions
                  });
                  Logger.debug("  -> \uD1B5\uD569\uB41C \uC81C\uC548\uB4E4:", combinedSuggestions);
                } else {
                  Logger.debug("  -> \uC0C8 \uAD50\uC815 \uC0DD\uC131");
                  correctionMap.set(blockOriginalText, {
                    original: blockOriginalText,
                    corrected: filteredSuggestions,
                    help: ((_f = block.revisions[0]) == null ? void 0 : _f.comment) || "\uB9DE\uCDA4\uBC95 \uAD50\uC815"
                  });
                  Logger.debug("  -> \uC0C8 \uAD50\uC815 \uC81C\uC548\uB4E4:", filteredSuggestions);
                }
              } else {
                Logger.debug("  -> \uC720\uD6A8\uD55C \uC81C\uC548\uC774 \uC5C6\uC5B4 \uAC74\uB108\uB700");
              }
            }
          });
        }
      });
    }
    corrections.push(...Array.from(correctionMap.values()));
    Logger.debug("\n=== \uCD5C\uC885 \uAD50\uC815 \uACB0\uACFC ===");
    Logger.debug("\uAD50\uC815 \uB9F5 \uD06C\uAE30:", correctionMap.size);
    Logger.log("\uCD5C\uC885 \uAD50\uC815 \uBC30\uC5F4:", corrections);
    Logger.log("\u{1F4CA} \uCD5C\uC885 \uAD50\uC815 \uC0C1\uC138:");
    Logger.log(`  \uCD1D \uAD50\uC815 \uC218: ${corrections.length}\uAC1C`);
    corrections.forEach((correction, index) => {
      Logger.log(`  ${index + 1}. "${correction.original}" \u2192 [${correction.corrected.join(", ")}]`);
      Logger.log(`     \uC124\uBA85: ${correction.help}`);
    });
    const normalizedSource = originalText.replace(/\s+/g, " ").trim();
    const normalizedResult = resultOutput.replace(/\s+/g, " ").trim();
    const hasSignificantChange = normalizedResult !== normalizedSource;
    const lengthDiff = Math.abs(normalizedSource.length - normalizedResult.length);
    const isMinorChange = lengthDiff <= 2;
    if (corrections.length === 0 && hasSignificantChange && !isMinorChange) {
      Logger.log("\u{1F50D} diff \uB85C\uC9C1 \uC2E4\uD589 \uC870\uAC74:");
      Logger.log(`  \uD14D\uC2A4\uD2B8 \uBCC0\uACBD: ${hasSignificantChange}`);
      Logger.log(`  \uAE38\uC774 \uCC28\uC774: ${lengthDiff}\uC790`);
      Logger.log(`  \uC0AC\uC18C\uD55C \uBCC0\uACBD: ${isMinorChange}`);
      Logger.log("\u2192 \uC138\uBD80 \uC815\uBCF4\uAC00 \uC5C6\uC5B4 diff \uB85C\uC9C1 \uC0AC\uC6A9");
      Logger.debug("\uC6D0\uBCF8 (\uC815\uADDC\uD654):", normalizedSource);
      Logger.debug("\uACB0\uACFC (\uC815\uADDC\uD654):", normalizedResult);
      const words = originalText.split(/(\s+)/);
      const revisedWords = resultOutput.split(/(\s+)/);
      for (let i = 0; i < Math.min(words.length, revisedWords.length); i++) {
        if (words[i] !== revisedWords[i] && words[i].trim() && revisedWords[i].trim()) {
          const wordLengthDiff = Math.abs(words[i].length - revisedWords[i].length);
          if (wordLengthDiff > 0 || words[i].toLowerCase() !== revisedWords[i].toLowerCase()) {
            corrections.push({
              original: words[i],
              corrected: [revisedWords[i]],
              help: "\uC790\uB3D9 \uAD50\uC815\uB428"
            });
          }
        }
      }
    } else if (corrections.length === 0) {
      Logger.log("\u2705 \uB9DE\uCDA4\uBC95 \uC624\uB958 \uC5C6\uC74C - diff \uB85C\uC9C1 \uC2E4\uD589 \uC548\uD568");
    } else if (hasSignificantChange && isMinorChange) {
      Logger.log("\u26A0\uFE0F \uC0AC\uC18C\uD55C \uBCC0\uACBD\uC774\uBBC0\uB85C diff \uB85C\uC9C1 \uAC74\uB108\uB700");
    }
    return { resultOutput, corrections };
  }
  /**
   * ÌòïÌÉúÏÜå Î∂ÑÏÑùÏùÑ ÌôúÏö©ÌïòÏó¨ Í≤πÏπòÎäî Ïò§Î•òÎ•º Ìï¥Í≤∞Ìï©ÎãàÎã§.
   * @param text ÏõêÎ≥∏ ÌÖçÏä§Ìä∏
   * @param corrections ÍµêÏ†ï Î∞∞Ïó¥
   * @param settings ÌîåÎü¨Í∑∏Ïù∏ ÏÑ§Ï†ï
   * @returns Í∞úÏÑ†Îêú ÍµêÏ†ï Î∞∞Ïó¥
   */
  async improveCorrectionsWithMorphemes(text, corrections, settings) {
    try {
      Logger.log("\n=== \uD615\uD0DC\uC18C \uBD84\uC11D \uAE30\uBC18 \uAD50\uC815 \uAC1C\uC120 ===");
      const morphemeData = await this.analyzeMorphemes(text, settings);
      Logger.debug("\uD615\uD0DC\uC18C \uBD84\uC11D \uC644\uB8CC:", morphemeData);
      const improvedCorrections = this.groupCorrectionsByMorphemes(corrections, morphemeData, text);
      Logger.debug(`\uAD50\uC815 \uAC1C\uC120 \uACB0\uACFC: ${corrections.length}\uAC1C \u2192 ${improvedCorrections.length}\uAC1C`);
      return improvedCorrections;
    } catch (error) {
      Logger.debug("\uD615\uD0DC\uC18C \uBD84\uC11D \uC2E4\uD328, \uC6D0\uBCF8 \uAD50\uC815 \uC0AC\uC6A9:", error);
      return corrections;
    }
  }
  /**
   * Ïù¥ÎØ∏ Î∂ÑÏÑùÎêú ÌòïÌÉúÏÜå Îç∞Ïù¥ÌÑ∞Î•º ÏÇ¨Ïö©ÌïòÏó¨ ÍµêÏ†ïÏùÑ Í∞úÏÑ†Ìï©ÎãàÎã§ (Ï§ëÎ≥µ API Ìò∏Ï∂ú Î∞©ÏßÄ).
   * @param text ÏõêÎ≥∏ ÌÖçÏä§Ìä∏
   * @param corrections ÍµêÏ†ï Î∞∞Ïó¥
   * @param settings ÌîåÎü¨Í∑∏Ïù∏ ÏÑ§Ï†ï
   * @param morphemeData Ïù¥ÎØ∏ Î∂ÑÏÑùÎêú ÌòïÌÉúÏÜå Îç∞Ïù¥ÌÑ∞
   * @returns Í∞úÏÑ†Îêú ÍµêÏ†ï Î∞∞Ïó¥
   */
  async improveCorrectionsWithMorphemeData(text, corrections, settings, morphemeData) {
    try {
      Logger.debug("=== \uD615\uD0DC\uC18C \uB370\uC774\uD130 \uAE30\uBC18 \uAD50\uC815 \uAC1C\uC120 (\uC7AC\uC0AC\uC6A9) ===");
      Logger.debug("\uAE30\uC874 \uD615\uD0DC\uC18C \uB370\uC774\uD130 \uC7AC\uC0AC\uC6A9:", morphemeData);
      const improvedCorrections = this.groupCorrectionsByMorphemes(corrections, morphemeData, text);
      Logger.debug(`\uAD50\uC815 \uAC1C\uC120 \uACB0\uACFC (\uC7AC\uC0AC\uC6A9): ${corrections.length}\uAC1C \u2192 ${improvedCorrections.length}\uAC1C`);
      return improvedCorrections;
    } catch (error) {
      Logger.debug("\uD615\uD0DC\uC18C \uB370\uC774\uD130 \uAE30\uBC18 \uAD50\uC815 \uAC1C\uC120 \uC2E4\uD328, \uC6D0\uBCF8 \uAD50\uC815 \uC0AC\uC6A9:", error);
      return corrections;
    }
  }
  /**
   * ÌòïÌÉúÏÜå Ï†ïÎ≥¥Î•º Í∏∞Î∞òÏúºÎ°ú ÍµêÏ†ïÏùÑ Í∑∏Î£πÌôîÌï©ÎãàÎã§.
   * @param corrections ÏõêÎ≥∏ ÍµêÏ†ï Î∞∞Ïó¥
   * @param morphemeData ÌòïÌÉúÏÜå Î∂ÑÏÑù Í≤∞Í≥º
   * @param originalText ÏõêÎ≥∏ ÌÖçÏä§Ìä∏
   * @returns Í∑∏Î£πÌôîÎêú ÍµêÏ†ï Î∞∞Ïó¥
   */
  groupCorrectionsByMorphemes(corrections, morphemeData, originalText) {
    const tokenMap = /* @__PURE__ */ new Map();
    morphemeData.sentences.forEach((sentence) => {
      sentence.tokens.forEach((token) => {
        tokenMap.set(token.text.content, token);
      });
    });
    Logger.debug("\uD1A0\uD070 \uB9F5:", Array.from(tokenMap.keys()));
    const groupedCorrections = [];
    const processedRanges = /* @__PURE__ */ new Set();
    corrections.forEach((correction) => {
      const correctionPositions = this.findAllPositions(originalText, correction.original);
      correctionPositions.forEach((position) => {
        const rangeKey = `${position}_${position + correction.original.length}`;
        if (!processedRanges.has(rangeKey)) {
          const overlappingCorrections = this.findOverlappingCorrections(
            corrections,
            originalText,
            position,
            correction.original.length
          );
          if (overlappingCorrections.length > 1) {
            Logger.debug(`\uC704\uCE58 ${position}\uC5D0\uC11C \uACB9\uCE58\uB294 \uAD50\uC815\uB4E4:`, overlappingCorrections.map((c) => c.original));
            const bestCorrection = this.selectBestCorrectionWithTokens(
              overlappingCorrections,
              tokenMap,
              originalText,
              position
            );
            if (bestCorrection) {
              groupedCorrections.push(bestCorrection);
              Logger.debug(`\uC120\uD0DD\uB41C \uAD50\uC815: "${bestCorrection.original}"`);
              overlappingCorrections.forEach((corr) => {
                const corrPositions = this.findAllPositions(originalText, corr.original);
                corrPositions.forEach((pos) => {
                  const key = `${pos}_${pos + corr.original.length}`;
                  processedRanges.add(key);
                });
              });
            }
          } else {
            groupedCorrections.push(correction);
            processedRanges.add(rangeKey);
          }
        }
      });
    });
    return groupedCorrections;
  }
  /**
   * ÌäπÏ†ï ÏúÑÏπòÏóêÏÑú Í≤πÏπòÎäî ÍµêÏ†ïÎì§ÏùÑ Ï∞æÏäµÎãàÎã§.
   */
  findOverlappingCorrections(corrections, text, position, length) {
    const overlapping = [];
    const endPosition = position + length;
    corrections.forEach((correction) => {
      const positions = this.findAllPositions(text, correction.original);
      positions.forEach((pos) => {
        const corrEnd = pos + correction.original.length;
        if (!(corrEnd <= position || endPosition <= pos)) {
          if (!overlapping.some((existing) => existing.original === correction.original)) {
            overlapping.push(correction);
          }
        }
      });
    });
    return overlapping;
  }
  /**
   * ÌÜ†ÌÅ∞ Ï†ïÎ≥¥Î•º Í∏∞Î∞òÏúºÎ°ú ÏµúÏ†ÅÏùò ÍµêÏ†ïÏùÑ ÏÑ†ÌÉùÌï©ÎãàÎã§.
   */
  selectBestCorrectionWithTokens(corrections, tokenMap, text, position) {
    for (const correction of corrections) {
      const token = tokenMap.get(correction.original);
      if (token) {
        Logger.debug(`\uD1A0\uD070 \uACBD\uACC4 \uC77C\uCE58 \uAD50\uC815 \uC120\uD0DD: "${correction.original}" (\uD1A0\uD070 \uB2E8\uC704)`);
        return correction;
      }
    }
    const longestCorrections = corrections.filter(
      (c) => c.original.length === Math.max(...corrections.map((corr) => corr.original.length))
    );
    if (longestCorrections.length === 1) {
      Logger.debug(`\uAC00\uC7A5 \uAE34 \uAD50\uC815 \uC120\uD0DD: "${longestCorrections[0].original}"`);
      return longestCorrections[0];
    }
    Logger.debug(`\uAE30\uBCF8 \uC120\uD0DD: "${longestCorrections[0].original}"`);
    return longestCorrections[0];
  }
  /**
   * ÌÖçÏä§Ìä∏ÏóêÏÑú ÌäπÏ†ï Ìå®ÌÑ¥Ïùò Î™®Îì† ÏúÑÏπòÎ•º Ï∞æÏäµÎãàÎã§.
   */
  findAllPositions(text, pattern) {
    const positions = [];
    let index = text.indexOf(pattern);
    while (index !== -1) {
      positions.push(index);
      index = text.indexOf(pattern, index + 1);
    }
    return positions;
  }
  /**
   * Ìïú Í∏ÄÏûê Ïò§Î•ò ÌïÑÌÑ∞ÎßÅÏùÑ Ï†ÅÏö©Ìï©ÎãàÎã§.
   * @param original ÏõêÎ≥∏ ÌÖçÏä§Ìä∏
   * @param suggestions ÏàòÏ†ï Ï†úÏïàÎì§
   * @param filterEnabled ÌïÑÌÑ∞ÎßÅ ÌôúÏÑ±Ìôî Ïó¨Î∂Ä
   * @returns ÌïÑÌÑ∞ÎßÅÎêú Ï†úÏïàÎì§
   */
  applySingleCharFilter(original, suggestions, filterEnabled) {
    if (!filterEnabled) {
      Logger.debug("    \uD55C \uAE00\uC790 \uD544\uD130\uB9C1 \uBE44\uD65C\uC131\uD654\uB428");
      return suggestions;
    }
    if (original.length !== 1) {
      Logger.debug(`    \uC6D0\uBCF8\uC774 \uD55C \uAE00\uC790\uAC00 \uC544\uB2D8 (${original.length}\uAE00\uC790): "${original}"`);
      return suggestions;
    }
    Logger.debug(`    \uD55C \uAE00\uC790 \uC6D0\uBCF8 \uAC10\uC9C0: "${original}"`);
    const meaningfulSuggestions = suggestions.filter((suggestion) => {
      const exceptions = this.checkSingleCharExceptions(original, suggestion);
      if (exceptions.isException) {
        Logger.debug(`      "${suggestion}": \uC608\uC678 \uCC98\uB9AC\uB428 (${exceptions.reason})`);
        return true;
      }
      Logger.debug(`      "${suggestion}": \uD55C \uAE00\uC790 \uAD50\uC815\uC73C\uB85C \uD544\uD130\uB9C1\uB428`);
      return false;
    });
    Logger.debug(`    \uD544\uD130\uB9C1 \uACB0\uACFC: ${suggestions.length} \u2192 ${meaningfulSuggestions.length}`);
    return meaningfulSuggestions;
  }
  /**
   * Ìïú Í∏ÄÏûê ÍµêÏ†ïÏùò ÏòàÏô∏ ÏºÄÏù¥Ïä§Î•º ÌôïÏù∏Ìï©ÎãàÎã§.
   * @param original ÏõêÎ≥∏ Í∏ÄÏûê
   * @param suggestion Ï†úÏïà Í∏ÄÏûê
   * @returns ÏòàÏô∏ Ï≤òÎ¶¨ Í≤∞Í≥º
   */
  checkSingleCharExceptions(original, suggestion) {
    var _a;
    if (/[0-9a-zA-Z]/.test(original) && /[Í∞Ä-Ìû£]/.test(suggestion)) {
      return { isException: true, reason: "\uC22B\uC790/\uC601\uBB38 \u2192 \uD55C\uAE00 \uBCC0\uD658" };
    }
    if (/[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?~`]/.test(original) && /[Í∞Ä-Ìû£]/.test(suggestion)) {
      return { isException: true, reason: "\uD2B9\uC218\uBB38\uC790 \u2192 \uD55C\uAE00 \uBCC0\uD658" };
    }
    const commonSingleCharCorrections = {
      "\uB418": ["\uB41C", "\uB428", "\uB3FC"],
      // Îêò/Îèº ÌòºÏö©
      "\uB3FC": ["\uB41C", "\uB418"],
      "\uC548": ["\uC54A"],
      // Ïïà/Ïïä ÌòºÏö©  
      "\uC54A": ["\uC548"],
      "\uC758": ["\uC5D0", "\uC744", "\uB97C"],
      // Ï°∞ÏÇ¨ ÌòºÏö©
      "\uC5D0": ["\uC758", "\uC744"],
      "\uC744": ["\uB97C", "\uC758"],
      "\uB97C": ["\uC744", "\uC758"],
      "\uC774": ["\uAC00", "\uD788"],
      // Ïù¥/Í∞Ä, Ïù¥/Ìûà ÌòºÏö©
      "\uAC00": ["\uC774", "\uAC00"],
      "\uD788": ["\uC774", "\uAC8C"],
      "\uAC8C": ["\uD788", "\uC5D0"]
    };
    if ((_a = commonSingleCharCorrections[original]) == null ? void 0 : _a.includes(suggestion)) {
      return { isException: true, reason: "\uC790\uC8FC \uD2C0\uB9AC\uB294 \uD55C \uAE00\uC790 \uAD50\uC815" };
    }
    if (suggestion.length > 1) {
      return { isException: true, reason: "\uD55C \uAE00\uC790 \u2192 \uC5EC\uB7EC \uAE00\uC790 \uD655\uC7A5" };
    }
    return { isException: false, reason: "\uC77C\uBC18\uC801\uC778 \uD55C \uAE00\uC790 \uAD50\uC815" };
  }
};

// src/services/cacheService.ts
init_logger();
var SpellCheckCacheService = class {
  constructor(maxSize = 1e3, ttlMinutes = 30, cleanupIntervalMinutes = 5) {
    this.cache = /* @__PURE__ */ new Map();
    // ÌÜµÍ≥Ñ Ï†ïÎ≥¥
    this.stats = {
      totalRequests: 0,
      cacheHits: 0,
      cacheMisses: 0
    };
    this.maxSize = maxSize;
    this.ttl = ttlMinutes * 60 * 1e3;
    this.cleanupInterval = cleanupIntervalMinutes * 60 * 1e3;
    Logger.debug("SpellCheckCacheService \uCD08\uAE30\uD654:", {
      maxSize,
      ttlMinutes,
      cleanupIntervalMinutes
    });
    this.startCleanupTimer();
  }
  /**
   * Ï∫êÏãúÏóêÏÑú Í≤∞Í≥ºÎ•º Í∞ÄÏ†∏ÏòµÎãàÎã§
   * @param text Í≤ÄÏÇ¨Ìï† ÌÖçÏä§Ìä∏ (ÌÇ§Î°ú ÏÇ¨Ïö©)
   * @returns Ï∫êÏãúÎêú Í≤∞Í≥º ÎòêÎäî null
   */
  get(text) {
    this.stats.totalRequests++;
    const key = this.generateKey(text);
    const item = this.cache.get(key);
    if (!item) {
      this.stats.cacheMisses++;
      Logger.debug("\uCE90\uC2DC \uBBF8\uC2A4:", { key: key.substring(0, 50) + "..." });
      return null;
    }
    const now = Date.now();
    if (now - item.timestamp > this.ttl) {
      this.cache.delete(key);
      this.stats.cacheMisses++;
      Logger.debug("\uCE90\uC2DC \uB9CC\uB8CC:", { key: key.substring(0, 50) + "..." });
      return null;
    }
    item.accessCount++;
    item.lastAccessed = now;
    this.cache.delete(key);
    this.cache.set(key, item);
    this.stats.cacheHits++;
    Logger.debug("\uCE90\uC2DC \uD788\uD2B8:", {
      key: key.substring(0, 50) + "...",
      accessCount: item.accessCount
    });
    return item.result;
  }
  /**
   * Í≤∞Í≥ºÎ•º Ï∫êÏãúÏóê Ï†ÄÏû•Ìï©ÎãàÎã§
   * @param text Í≤ÄÏÇ¨Ìïú ÌÖçÏä§Ìä∏
   * @param result Í≤ÄÏÇ¨ Í≤∞Í≥º
   */
  set(text, result) {
    const key = this.generateKey(text);
    const now = Date.now();
    if (this.cache.size >= this.maxSize && !this.cache.has(key)) {
      this.evictLeastRecentlyUsed();
    }
    const item = {
      result,
      timestamp: now,
      accessCount: 1,
      lastAccessed: now
    };
    this.cache.set(key, item);
    Logger.debug("\uCE90\uC2DC \uC800\uC7A5:", {
      key: key.substring(0, 50) + "...",
      cacheSize: this.cache.size,
      corrections: result.corrections.length
    });
  }
  /**
   * Ï∫êÏãú ÌÜµÍ≥ÑÎ•º Î∞òÌôòÌï©ÎãàÎã§
   */
  getStats() {
    const hitRatio = this.stats.totalRequests > 0 ? this.stats.cacheHits / this.stats.totalRequests * 100 : 0;
    return {
      totalRequests: this.stats.totalRequests,
      cacheHits: this.stats.cacheHits,
      cacheMisses: this.stats.cacheMisses,
      hitRatio: Math.round(hitRatio * 100) / 100,
      cacheSize: this.cache.size,
      memoryUsage: this.estimateMemoryUsage()
    };
  }
  /**
   * Ï∫êÏãúÎ•º ÏôÑÏ†ÑÌûà ÎπÑÏõÅÎãàÎã§
   */
  clear() {
    this.cache.clear();
    this.stats = {
      totalRequests: 0,
      cacheHits: 0,
      cacheMisses: 0
    };
    Logger.debug("\uCE90\uC2DC \uC804\uCCB4 \uC0AD\uC81C \uC644\uB8CC");
  }
  /**
   * ÎßåÎ£åÎêú Ìï≠Î™©Îì§ÏùÑ Ï†ïÎ¶¨Ìï©ÎãàÎã§
   */
  cleanup() {
    const now = Date.now();
    let removedCount = 0;
    for (const [key, item] of this.cache.entries()) {
      if (now - item.timestamp > this.ttl) {
        this.cache.delete(key);
        removedCount++;
      }
    }
    if (removedCount > 0) {
      Logger.debug("\uCE90\uC2DC \uC815\uB9AC \uC644\uB8CC:", {
        removedCount,
        remainingSize: this.cache.size
      });
    }
  }
  /**
   * Ï∫êÏãú ÏÑúÎπÑÏä§Î•º Ï¢ÖÎ£åÌïòÍ≥† Ï†ïÎ¶¨Ìï©ÎãàÎã§
   */
  destroy() {
    if (this.cleanupTimer) {
      clearInterval(this.cleanupTimer);
      this.cleanupTimer = void 0;
    }
    this.clear();
    Logger.debug("SpellCheckCacheService \uC885\uB8CC");
  }
  /**
   * ÌÖçÏä§Ìä∏ÏóêÏÑú Ï∫êÏãú ÌÇ§Î•º ÏÉùÏÑ±Ìï©ÎãàÎã§
   * @param text ÏõêÎ≥∏ ÌÖçÏä§Ìä∏
   * @returns Ìï¥ÏãúÎêú ÌÇ§
   */
  generateKey(text) {
    const normalized = text.trim().replace(/\s+/g, " ");
    let hash = 0;
    for (let i = 0; i < normalized.length; i++) {
      const char = normalized.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return `spell_${Math.abs(hash)}_${normalized.length}`;
  }
  /**
   * LRU Ï†ïÏ±ÖÏóê Îî∞Îùº Í∞ÄÏû• Ïò§ÎûòÎêú Ìï≠Î™©ÏùÑ Ï†úÍ±∞Ìï©ÎãàÎã§
   */
  evictLeastRecentlyUsed() {
    let oldestKey = null;
    let oldestTime = Date.now();
    for (const [key, item] of this.cache.entries()) {
      if (item.lastAccessed < oldestTime) {
        oldestTime = item.lastAccessed;
        oldestKey = key;
      }
    }
    if (oldestKey) {
      this.cache.delete(oldestKey);
      Logger.debug("LRU \uC81C\uAC70:", {
        key: oldestKey.substring(0, 50) + "...",
        age: Date.now() - oldestTime
      });
    }
  }
  /**
   * ÎåÄÎûµÏ†ÅÏù∏ Î©îÎ™®Î¶¨ ÏÇ¨Ïö©ÎüâÏùÑ Ï∂îÏ†ïÌï©ÎãàÎã§ (Î∞îÏù¥Ìä∏ Îã®ÏúÑ)
   */
  estimateMemoryUsage() {
    let totalSize = 0;
    for (const [key, item] of this.cache.entries()) {
      totalSize += key.length * 2;
      totalSize += JSON.stringify(item.result).length * 2;
      totalSize += 32;
    }
    return totalSize;
  }
  /**
   * Ï†ïÎ¶¨ ÌÉÄÏù¥Î®∏Î•º ÏãúÏûëÌï©ÎãàÎã§
   */
  startCleanupTimer() {
    this.cleanupTimer = setInterval(() => {
      this.cleanup();
    }, this.cleanupInterval);
  }
};

// src/services/optimizedApiService.ts
init_errorHandler();
init_logger();
var OptimizedSpellCheckService = class {
  constructor(maxBatchSize = 5, batchTimeoutMs = 2e3, requestTimeoutMs = 15e3, maxConcurrentBatches = 3, cacheOptions) {
    this.requestQueue = [];
    this.processing = false;
    this.activeBatches = 0;
    // ÏÑ±Îä• Î©îÌä∏Î¶≠
    this.metrics = {
      totalRequests: 0,
      successfulRequests: 0,
      failedRequests: 0,
      responseTimes: []
    };
    this.apiService = new SpellCheckApiService();
    this.cacheService = new SpellCheckCacheService(
      cacheOptions == null ? void 0 : cacheOptions.maxSize,
      cacheOptions == null ? void 0 : cacheOptions.ttlMinutes,
      cacheOptions == null ? void 0 : cacheOptions.cleanupIntervalMinutes
    );
    this.maxBatchSize = maxBatchSize;
    this.batchTimeout = batchTimeoutMs;
    this.requestTimeout = requestTimeoutMs;
    this.maxConcurrentBatches = maxConcurrentBatches;
    Logger.debug("OptimizedSpellCheckService \uCD08\uAE30\uD654:", {
      maxBatchSize,
      batchTimeoutMs,
      requestTimeoutMs,
      maxConcurrentBatches
    });
  }
  /**
   * ÎßûÏ∂§Î≤ï Í≤ÄÏÇ¨Î•º ÏàòÌñâÌï©ÎãàÎã§ (ÏµúÏ†ÅÌôîÎêú Î≤ÑÏ†Ñ)
   * @param text Í≤ÄÏÇ¨Ìï† ÌÖçÏä§Ìä∏
   * @param settings ÌîåÎü¨Í∑∏Ïù∏ ÏÑ§Ï†ï
   * @param priority ÏöîÏ≤≠ Ïö∞ÏÑ†ÏàúÏúÑ
   * @returns Í≤ÄÏÇ¨ Í≤∞Í≥º Promise
   */
  async checkSpelling(text, settings, priority = "medium") {
    this.metrics.totalRequests++;
    const cachedResult = this.cacheService.get(text);
    if (cachedResult) {
      Logger.debug("\uCE90\uC2DC\uC5D0\uC11C \uACB0\uACFC \uBC18\uD658:", { textLength: text.length });
      return cachedResult;
    }
    if (text.length < 50 || priority === "high") {
      Logger.debug("\uC989\uC2DC \uCC98\uB9AC:", { textLength: text.length, priority });
      return this.processSingleRequest(text, settings);
    }
    return new Promise((resolve, reject) => {
      const item = {
        text,
        resolve,
        reject,
        timestamp: Date.now(),
        priority
      };
      this.insertByPriority(item);
      Logger.debug("\uBC30\uCE58 \uD050\uC5D0 \uCD94\uAC00:", {
        queueLength: this.requestQueue.length,
        priority,
        textLength: text.length
      });
      this.scheduleBatchProcessing(settings);
    });
  }
  /**
   * ÏÑúÎπÑÏä§ ÏÑ±Îä• Î©îÌä∏Î¶≠ÏùÑ Î∞òÌôòÌï©ÎãàÎã§
   */
  getMetrics() {
    const avgResponseTime = this.metrics.responseTimes.length > 0 ? this.metrics.responseTimes.reduce((a, b) => a + b, 0) / this.metrics.responseTimes.length : 0;
    return {
      totalRequests: this.metrics.totalRequests,
      successfulRequests: this.metrics.successfulRequests,
      failedRequests: this.metrics.failedRequests,
      averageResponseTime: Math.round(avgResponseTime),
      queueLength: this.requestQueue.length,
      activeBatches: this.activeBatches,
      cache: this.cacheService.getStats(),
      morphemeCache: this.apiService.getMorphemeCacheStats()
      // ‚≠ê NEW: ÌòïÌÉúÏÜå Ï∫êÏãú ÌÜµÍ≥Ñ
    };
  }
  /**
   * Ï∫êÏãúÎ•º ÏàòÎèôÏúºÎ°ú Ï†ïÎ¶¨Ìï©ÎãàÎã§
   */
  clearCache() {
    this.cacheService.clear();
    this.apiService.clearMorphemeCache();
  }
  /**
   * ÎåÄÍ∏∞ Ï§ëÏù∏ Î™®Îì† ÏöîÏ≤≠ÏùÑ Ï∑®ÏÜåÌï©ÎãàÎã§
   */
  cancelPendingRequests() {
    const error = new Error("\uC694\uCCAD\uC774 \uCDE8\uC18C\uB418\uC5C8\uC2B5\uB2C8\uB2E4");
    this.requestQueue.forEach((item) => {
      item.reject(error);
    });
    this.requestQueue = [];
    if (this.batchTimer) {
      clearTimeout(this.batchTimer);
      this.batchTimer = void 0;
    }
    Logger.debug("\uB300\uAE30 \uC911\uC778 \uBAA8\uB4E0 \uC694\uCCAD \uCDE8\uC18C\uB428");
  }
  /**
   * ÏÑúÎπÑÏä§Î•º Ï¢ÖÎ£åÌïòÍ≥† Î¶¨ÏÜåÏä§Î•º Ï†ïÎ¶¨Ìï©ÎãàÎã§
   */
  destroy() {
    this.cancelPendingRequests();
    this.cacheService.destroy();
    Logger.debug("OptimizedSpellCheckService \uC885\uB8CC");
  }
  /**
   * Îã®Ïùº ÏöîÏ≤≠ÏùÑ Ï¶âÏãú Ï≤òÎ¶¨Ìï©ÎãàÎã§ (ÏóêÎü¨ Ìï∏Îì§ÎßÅ Î∞è Ïû¨ÏãúÎèÑ Ìè¨Ìï®)
   */
  async processSingleRequest(text, settings) {
    const startTime = Date.now();
    try {
      const result = await ErrorHandlerService.withRetry(
        async () => {
          return await this.executeWithTimeout(
            () => this.apiService.checkSpelling(text, settings),
            this.requestTimeout
          );
        },
        `spell-check-${text.substring(0, 50)}`,
        {
          maxRetries: 2,
          baseDelay: 1e3,
          maxDelay: 5e3,
          backoffFactor: 2
        }
      );
      this.cacheService.set(text, result);
      const responseTime = Date.now() - startTime;
      this.updateMetrics(true, responseTime);
      return result;
    } catch (error) {
      this.updateMetrics(false, Date.now() - startTime);
      const errorInfo = ErrorHandlerService.handleError(error, "spell-check-api");
      throw error;
    }
  }
  /**
   * Î∞∞Ïπò Ï≤òÎ¶¨Î•º Ïä§ÏºÄÏ§ÑÎßÅÌï©ÎãàÎã§
   */
  scheduleBatchProcessing(settings) {
    if (this.processing || this.requestQueue.length === 0) {
      return;
    }
    if (this.activeBatches >= this.maxConcurrentBatches) {
      Logger.debug("\uCD5C\uB300 \uB3D9\uC2DC \uBC30\uCE58 \uC218 \uB3C4\uB2EC, \uB300\uAE30 \uC911");
      return;
    }
    if (this.requestQueue.length >= this.maxBatchSize) {
      this.processBatch(settings);
    } else if (!this.batchTimer) {
      this.batchTimer = setTimeout(() => {
        this.processBatch(settings);
      }, this.batchTimeout);
    }
  }
  /**
   * Î∞∞ÏπòÎ•º Ï≤òÎ¶¨Ìï©ÎãàÎã§
   */
  async processBatch(settings) {
    if (this.processing || this.requestQueue.length === 0) {
      return;
    }
    this.processing = true;
    this.activeBatches++;
    if (this.batchTimer) {
      clearTimeout(this.batchTimer);
      this.batchTimer = void 0;
    }
    const batch = this.requestQueue.splice(0, this.maxBatchSize);
    Logger.debug("\uBC30\uCE58 \uCC98\uB9AC \uC2DC\uC791:", {
      batchSize: batch.length,
      remainingQueue: this.requestQueue.length,
      activeBatches: this.activeBatches
    });
    try {
      const promises = batch.map(async (item) => {
        try {
          const result = await this.processSingleRequest(item.text, settings);
          item.resolve(result);
        } catch (error) {
          item.reject(error instanceof Error ? error : new Error(String(error)));
        }
      });
      await Promise.allSettled(promises);
    } catch (error) {
      Logger.error("\uBC30\uCE58 \uCC98\uB9AC \uC911 \uC624\uB958:", error);
      batch.forEach((item) => {
        item.reject(error instanceof Error ? error : new Error(String(error)));
      });
    } finally {
      this.processing = false;
      this.activeBatches--;
      Logger.debug("\uBC30\uCE58 \uCC98\uB9AC \uC644\uB8CC:", {
        remainingQueue: this.requestQueue.length,
        activeBatches: this.activeBatches
      });
      if (this.requestQueue.length > 0) {
        setTimeout(() => this.scheduleBatchProcessing(settings), 100);
      }
    }
  }
  /**
   * Ïö∞ÏÑ†ÏàúÏúÑÏóê Îî∞Îùº ÌÅêÏóê ÏïÑÏù¥ÌÖúÏùÑ ÏÇΩÏûÖÌï©ÎãàÎã§
   */
  insertByPriority(item) {
    const priorityOrder = { high: 0, medium: 1, low: 2 };
    const itemPriority = priorityOrder[item.priority];
    let insertIndex = this.requestQueue.length;
    for (let i = 0; i < this.requestQueue.length; i++) {
      const existingPriority = priorityOrder[this.requestQueue[i].priority];
      if (itemPriority < existingPriority) {
        insertIndex = i;
        break;
      }
    }
    this.requestQueue.splice(insertIndex, 0, item);
  }
  /**
   * ÌÉÄÏûÑÏïÑÏõÉÏùÑ Ï†ÅÏö©Ìïú Ìï®Ïàò Ïã§Ìñâ
   */
  async executeWithTimeout(fn, timeoutMs) {
    return new Promise((resolve, reject) => {
      const timer = setTimeout(() => {
        reject(new Error(`\uC694\uCCAD \uD0C0\uC784\uC544\uC6C3 (${timeoutMs}ms)`));
      }, timeoutMs);
      fn().then((result) => {
        clearTimeout(timer);
        resolve(result);
      }).catch((error) => {
        clearTimeout(timer);
        reject(error);
      });
    });
  }
  /**
   * ÏÑ±Îä• Î©îÌä∏Î¶≠ÏùÑ ÏóÖÎç∞Ïù¥Ìä∏Ìï©ÎãàÎã§
   */
  updateMetrics(success, responseTime) {
    if (success) {
      this.metrics.successfulRequests++;
    } else {
      this.metrics.failedRequests++;
    }
    this.metrics.responseTimes.push(responseTime);
    if (this.metrics.responseTimes.length > 100) {
      this.metrics.responseTimes = this.metrics.responseTimes.slice(-100);
    }
  }
  /**
   * ÌòïÌÉúÏÜå Î∂ÑÏÑùÏùÑ ÌôúÏö©ÌïòÏó¨ Í≤πÏπòÎäî Ïò§Î•òÎ•º Ìï¥Í≤∞Ìï©ÎãàÎã§.
   * @param text ÏõêÎ≥∏ ÌÖçÏä§Ìä∏
   * @param corrections ÍµêÏ†ï Î∞∞Ïó¥
   * @param settings ÌîåÎü¨Í∑∏Ïù∏ ÏÑ§Ï†ï
   * @returns Í∞úÏÑ†Îêú ÍµêÏ†ï Î∞∞Ïó¥
   */
  async improveCorrectionsWithMorphemes(text, corrections, settings) {
    return await this.apiService.improveCorrectionsWithMorphemes(text, corrections, settings);
  }
  /**
   * Ïù¥ÎØ∏ Î∂ÑÏÑùÎêú ÌòïÌÉúÏÜå Îç∞Ïù¥ÌÑ∞Î•º ÏÇ¨Ïö©ÌïòÏó¨ ÍµêÏ†ïÏùÑ Í∞úÏÑ†Ìï©ÎãàÎã§ (Ï§ëÎ≥µ API Ìò∏Ï∂ú Î∞©ÏßÄ).
   * @param text ÏõêÎ≥∏ ÌÖçÏä§Ìä∏
   * @param corrections ÍµêÏ†ï Î∞∞Ïó¥
   * @param settings ÌîåÎü¨Í∑∏Ïù∏ ÏÑ§Ï†ï
   * @param morphemeData Ïù¥ÎØ∏ Î∂ÑÏÑùÎêú ÌòïÌÉúÏÜå Îç∞Ïù¥ÌÑ∞
   * @returns Í∞úÏÑ†Îêú ÍµêÏ†ï Î∞∞Ïó¥
   */
  async improveCorrectionsWithMorphemeData(text, corrections, settings, morphemeData) {
    return await this.apiService.improveCorrectionsWithMorphemeData(text, corrections, settings, morphemeData);
  }
  /**
   * ÌòïÌÉúÏÜå Î∂ÑÏÑùÏùÑ ÏàòÌñâÌï©ÎãàÎã§.
   */
  async analyzeMorphemes(text, settings) {
    return await this.apiService.analyzeMorphemes(text, settings);
  }
};

// src/orchestrator.ts
init_settings();

// src/services/ignoredWords.ts
var IgnoredWordsService = class {
  /**
   * Îã®Ïñ¥Í∞Ä ÏòàÏô∏ Ï≤òÎ¶¨ÎêòÏóàÎäîÏßÄ ÌôïÏù∏Ìï©ÎãàÎã§.
   * @param word ÌôïÏù∏Ìï† Îã®Ïñ¥
   * @param settings ÌîåÎü¨Í∑∏Ïù∏ ÏÑ§Ï†ï
   * @returns ÏòàÏô∏ Ï≤òÎ¶¨ Ïó¨Î∂Ä
   */
  static isWordIgnored(word, settings) {
    return settings.ignoredWords.includes(word.trim());
  }
  /**
   * Îã®Ïñ¥Î•º ÏòàÏô∏ Ï≤òÎ¶¨ Î™©Î°ùÏóê Ï∂îÍ∞ÄÌï©ÎãàÎã§.
   * @param word Ï∂îÍ∞ÄÌï† Îã®Ïñ¥
   * @param settings ÌîåÎü¨Í∑∏Ïù∏ ÏÑ§Ï†ï
   * @returns ÏóÖÎç∞Ïù¥Ìä∏Îêú ÏÑ§Ï†ï
   */
  static addIgnoredWord(word, settings) {
    const trimmedWord = word.trim();
    if (!trimmedWord || this.isWordIgnored(trimmedWord, settings)) {
      return settings;
    }
    return {
      ...settings,
      ignoredWords: [...settings.ignoredWords, trimmedWord].sort()
    };
  }
  /**
   * Îã®Ïñ¥Î•º ÏòàÏô∏ Ï≤òÎ¶¨ Î™©Î°ùÏóêÏÑú Ï†úÍ±∞Ìï©ÎãàÎã§.
   * @param word Ï†úÍ±∞Ìï† Îã®Ïñ¥
   * @param settings ÌîåÎü¨Í∑∏Ïù∏ ÏÑ§Ï†ï
   * @returns ÏóÖÎç∞Ïù¥Ìä∏Îêú ÏÑ§Ï†ï
   */
  static removeIgnoredWord(word, settings) {
    const trimmedWord = word.trim();
    return {
      ...settings,
      ignoredWords: settings.ignoredWords.filter((w) => w !== trimmedWord)
    };
  }
  /**
   * ÏòàÏô∏ Ï≤òÎ¶¨Îêú Îã®Ïñ¥ Î™©Î°ùÏùÑ Í∞ÄÏ†∏ÏòµÎãàÎã§.
   * @param settings ÌîåÎü¨Í∑∏Ïù∏ ÏÑ§Ï†ï
   * @returns ÏòàÏô∏ Ï≤òÎ¶¨Îêú Îã®Ïñ¥ Î∞∞Ïó¥
   */
  static getIgnoredWords(settings) {
    return [...settings.ignoredWords].sort();
  }
  /**
   * ÏòàÏô∏ Ï≤òÎ¶¨Îêú Îã®Ïñ¥ ÏàòÎ•º Í∞ÄÏ†∏ÏòµÎãàÎã§.
   * @param settings ÌîåÎü¨Í∑∏Ïù∏ ÏÑ§Ï†ï
   * @returns ÏòàÏô∏ Ï≤òÎ¶¨Îêú Îã®Ïñ¥ Ïàò
   */
  static getIgnoredWordsCount(settings) {
    return settings.ignoredWords.length;
  }
  /**
   * Î™®Îì† ÏòàÏô∏ Ï≤òÎ¶¨Îêú Îã®Ïñ¥Î•º Ï†úÍ±∞Ìï©ÎãàÎã§.
   * @param settings ÌîåÎü¨Í∑∏Ïù∏ ÏÑ§Ï†ï
   * @returns ÏóÖÎç∞Ïù¥Ìä∏Îêú ÏÑ§Ï†ï
   */
  static clearAllIgnoredWords(settings) {
    return {
      ...settings,
      ignoredWords: []
    };
  }
  /**
   * Îã®Ïñ¥ Î™©Î°ùÏùÑ ÏùºÍ¥Ñ Ï∂îÍ∞ÄÌï©ÎãàÎã§.
   * @param words Ï∂îÍ∞ÄÌï† Îã®Ïñ¥ Î∞∞Ïó¥
   * @param settings ÌîåÎü¨Í∑∏Ïù∏ ÏÑ§Ï†ï
   * @returns ÏóÖÎç∞Ïù¥Ìä∏Îêú ÏÑ§Ï†ï
   */
  static addMultipleIgnoredWords(words, settings) {
    const newWords = words.map((word) => word.trim()).filter((word) => word && !this.isWordIgnored(word, settings));
    if (newWords.length === 0) {
      return settings;
    }
    return {
      ...settings,
      ignoredWords: [...settings.ignoredWords, ...newWords].sort()
    };
  }
  /**
   * ÏòàÏô∏ Ï≤òÎ¶¨Îêú Îã®Ïñ¥Î•º Í≤ÄÏÉâÌï©ÎãàÎã§.
   * @param query Í≤ÄÏÉâÏñ¥
   * @param settings ÌîåÎü¨Í∑∏Ïù∏ ÏÑ§Ï†ï
   * @returns Í≤ÄÏÉâ Í≤∞Í≥º
   */
  static searchIgnoredWords(query, settings) {
    const trimmedQuery = query.trim().toLowerCase();
    if (!trimmedQuery) {
      return this.getIgnoredWords(settings);
    }
    return settings.ignoredWords.filter((word) => word.toLowerCase().includes(trimmedQuery)).sort();
  }
  /**
   * ÏòàÏô∏ Ï≤òÎ¶¨Îêú Îã®Ïñ¥Î•º Î¨∏ÏûêÏó¥Î°ú ÎÇ¥Î≥¥ÎÉÖÎãàÎã§.
   * @param settings ÌîåÎü¨Í∑∏Ïù∏ ÏÑ§Ï†ï
   * @param separator Íµ¨Î∂ÑÏûê (Í∏∞Î≥∏Í∞í: ', ')
   * @returns ÏòàÏô∏ Ï≤òÎ¶¨Îêú Îã®Ïñ¥Îì§ÏùÑ Íµ¨Î∂ÑÏûêÎ°ú Ïó∞Í≤∞Ìïú Î¨∏ÏûêÏó¥
   */
  static exportIgnoredWords(settings, separator = ", ") {
    return this.getIgnoredWords(settings).join(separator);
  }
  /**
   * Î¨∏ÏûêÏó¥ÏóêÏÑú ÏòàÏô∏ Ï≤òÎ¶¨Îêú Îã®Ïñ¥Î•º Í∞ÄÏ†∏ÏôÄ ÏùºÍ¥Ñ Ï∂îÍ∞ÄÌï©ÎãàÎã§.
   * @param wordsString Îã®Ïñ¥Îì§Ïù¥ Ìè¨Ìï®Îêú Î¨∏ÏûêÏó¥
   * @param separator Íµ¨Î∂ÑÏûê (Í∏∞Î≥∏Í∞í: ',')
   * @param settings ÌîåÎü¨Í∑∏Ïù∏ ÏÑ§Ï†ï
   * @returns ÏóÖÎç∞Ïù¥Ìä∏Îêú ÏÑ§Ï†ï
   */
  static importIgnoredWords(wordsString, separator = ",", settings) {
    const words = wordsString.split(separator).map((word) => word.trim()).filter((word) => word);
    return this.addMultipleIgnoredWords(words, settings);
  }
};

// src/ui/correctionPopup.ts
var import_obsidian2 = require("obsidian");

// src/utils/htmlUtils.ts
function escapeHtml(text) {
  const div = document.createElement("div");
  div.textContent = text;
  return div.innerHTML;
}
function safeRemoveElement(element) {
  if (element && element.parentNode) {
    element.parentNode.removeChild(element);
  }
}
function addEventListenerWithCleanup(element, event, handler) {
  element.addEventListener(event, handler);
  return () => element.removeEventListener(event, handler);
}

// src/utils/domUtils.ts
function parseHTMLSafely(htmlString) {
  const template = document.createElement("template");
  template.innerHTML = htmlString;
  return template.content;
}
function clearElement(element) {
  try {
    while (element.firstChild) {
      const child = element.firstChild;
      if (child.parentNode === element) {
        element.removeChild(child);
      } else {
        break;
      }
    }
  } catch (error) {
    element.textContent = "";
  }
}
function createMetricsDisplay(parent, metrics) {
  clearElement(parent);
  const apiSection = parent.createEl("div");
  apiSection.createEl("strong", { text: "API \uC131\uB2A5 \uD1B5\uACC4:" });
  apiSection.createEl("br");
  const apiMetrics = [
    `\uCD1D \uC694\uCCAD: ${metrics.totalRequests}`,
    `\uC131\uACF5 \uC694\uCCAD: ${metrics.successfulRequests}`,
    `\uC2E4\uD328 \uC694\uCCAD: ${metrics.failedRequests}`,
    `\uD3C9\uADE0 \uC751\uB2F5\uC2DC\uAC04: ${metrics.averageResponseTime}ms`,
    `\uB300\uAE30\uC5F4 \uAE38\uC774: ${metrics.queueLength}`,
    `\uD65C\uC131 \uBC30\uCE58: ${metrics.activeBatches}`
  ];
  apiMetrics.forEach((metric) => {
    apiSection.createEl("div", { text: `\u2022 ${metric}` });
  });
  parent.createEl("br");
  if (metrics.cache) {
    const cacheSection = parent.createEl("div");
    cacheSection.createEl("strong", { text: "\uCE90\uC2DC \uD1B5\uACC4:" });
    cacheSection.createEl("br");
    const cacheMetrics = [
      `\uCD1D \uC694\uCCAD: ${metrics.cache.totalRequests}`,
      `\uCE90\uC2DC \uD788\uD2B8: ${metrics.cache.cacheHits}`,
      `\uCE90\uC2DC \uBBF8\uC2A4: ${metrics.cache.cacheMisses}`,
      `\uD788\uD2B8\uC728: ${metrics.cache.hitRatio}%`,
      `\uCE90\uC2DC \uD06C\uAE30: ${metrics.cache.cacheSize}\uAC1C`,
      `\uBA54\uBAA8\uB9AC \uC0AC\uC6A9\uB7C9: ${Math.round(metrics.cache.memoryUsage / 1024)}KB`
    ];
    cacheMetrics.forEach((metric) => {
      cacheSection.createEl("div", { text: `\u2022 ${metric}` });
    });
  }
}

// src/ui/baseComponent.ts
var BaseComponent = class {
  constructor(tagName = "div", className) {
    this.cleanupFunctions = [];
    this.isDestroyed = false;
    this.element = document.createElement(tagName);
    if (className) {
      this.element.className = className;
    }
  }
  /**
   * Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑàÎ•º Ï∂îÍ∞ÄÌïòÍ≥† Ï†ïÎ¶¨ Ìï®ÏàòÎ•º Îì±Î°ùÌï©ÎãàÎã§.
   * @param element ÎåÄÏÉÅ ÏöîÏÜå
   * @param event Ïù¥Î≤§Ìä∏ ÌÉÄÏûÖ
   * @param handler Ïù¥Î≤§Ìä∏ Ìï∏Îì§Îü¨
   */
  addEventListener(element, event, handler) {
    const cleanup = addEventListenerWithCleanup(element, event, handler);
    this.cleanupFunctions.push(cleanup);
  }
  /**
   * Ïª¥Ìè¨ÎÑåÌä∏Ïùò Î£®Ìä∏ ÏöîÏÜåÎ•º Î∞òÌôòÌï©ÎãàÎã§.
   */
  getElement() {
    return this.element;
  }
  /**
   * Ïª¥Ìè¨ÎÑåÌä∏Î•º DOMÏóê Ï∂îÍ∞ÄÌï©ÎãàÎã§.
   * @param parent Î∂ÄÎ™® ÏöîÏÜå
   */
  appendTo(parent) {
    if (!this.isDestroyed) {
      parent.appendChild(this.element);
    }
  }
  /**
   * Ïª¥Ìè¨ÎÑåÌä∏Î•º DOMÏóêÏÑú Ï†úÍ±∞Ìï©ÎãàÎã§.
   */
  remove() {
    safeRemoveElement(this.element);
  }
  /**
   * Ïª¥Ìè¨ÎÑåÌä∏Î•º ÏôÑÏ†ÑÌûà ÌååÍ¥¥ÌïòÍ≥† Î¶¨ÏÜåÏä§Î•º Ï†ïÎ¶¨Ìï©ÎãàÎã§.
   */
  destroy() {
    if (this.isDestroyed)
      return;
    this.cleanupFunctions.forEach((cleanup) => cleanup());
    this.cleanupFunctions = [];
    this.remove();
    this.isDestroyed = true;
  }
  /**
   * Ïª¥Ìè¨ÎÑåÌä∏Í∞Ä ÌååÍ¥¥ÎêòÏóàÎäîÏßÄ ÌôïÏù∏Ìï©ÎãàÎã§.
   */
  isComponentDestroyed() {
    return this.isDestroyed;
  }
  /**
   * CSS ÌÅ¥ÎûòÏä§Î•º Ï∂îÍ∞ÄÌï©ÎãàÎã§.
   * @param className ÌÅ¥ÎûòÏä§Î™Ö
   */
  addClass(className) {
    this.element.classList.add(className);
  }
  /**
   * CSS ÌÅ¥ÎûòÏä§Î•º Ï†úÍ±∞Ìï©ÎãàÎã§.
   * @param className ÌÅ¥ÎûòÏä§Î™Ö
   */
  removeClass(className) {
    this.element.classList.remove(className);
  }
  /**
   * CSS ÌÅ¥ÎûòÏä§Î•º ÌÜ†Í∏ÄÌï©ÎãàÎã§.
   * @param className ÌÅ¥ÎûòÏä§Î™Ö
   * @param force Í∞ïÏ†ú ÏÑ§Ï†ïÍ∞í
   */
  toggleClass(className, force) {
    this.element.classList.toggle(className, force);
  }
  /**
   * ÏöîÏÜåÏùò ÎÇ¥Ïö©ÏùÑ ÏÑ§Ï†ïÌï©ÎãàÎã§.
   * @param content HTML ÎòêÎäî ÌÖçÏä§Ìä∏ ÎÇ¥Ïö©
   * @param isHTML HTML Ïó¨Î∂Ä (Í∏∞Î≥∏Í∞í: false)
   */
  setContent(content, isHTML = false) {
    if (isHTML) {
      clearElement(this.element);
      const fragment = parseHTMLSafely(content);
      this.element.appendChild(fragment);
    } else {
      this.element.textContent = content;
    }
  }
  /**
   * ÏöîÏÜåÏóê ÏÜçÏÑ±ÏùÑ ÏÑ§Ï†ïÌï©ÎãàÎã§.
   * @param name ÏÜçÏÑ±Î™Ö
   * @param value ÏÜçÏÑ±Í∞í
   */
  setAttribute(name, value) {
    this.element.setAttribute(name, value);
  }
  /**
   * ÏöîÏÜåÏùò Ïä§ÌÉÄÏùºÏùÑ ÏÑ§Ï†ïÌï©ÎãàÎã§.
   * @param property CSS ÏÜçÏÑ±
   * @param value CSS Í∞í
   */
  setStyle(property, value) {
    this.element.style[property] = value;
  }
};

// src/state/correctionState.ts
init_logger();
var CorrectionStateManager = class {
  constructor(corrections, ignoredWords = []) {
    this.states = /* @__PURE__ */ new Map();
    this.corrections = [];
    this.ignoredWords = [];
    this.userEditedValues = /* @__PURE__ */ new Map();
    this.corrections = corrections;
    this.ignoredWords = ignoredWords;
    this.initializeStates(ignoredWords);
  }
  /**
   * ÏÉÅÌÉúÎ•º Ï¥àÍ∏∞ÌôîÌï©ÎãàÎã§.
   */
  initializeStates(ignoredWords) {
    this.states.clear();
    this.corrections.forEach((correction, index) => {
      const isOriginalKept = ignoredWords.includes(correction.original);
      this.setState(index, correction.original, false, isOriginalKept);
      Logger.debug(`Initializing: ${correction.original} at index ${index} as ${isOriginalKept ? "ORIGINAL_KEPT" : "ERROR"}.`);
    });
  }
  /**
   * ÌäπÏ†ï ÍµêÏ†ïÏùò ÏÉÅÌÉúÎ•º ÏÑ§Ï†ïÌï©ÎãàÎã§.
   * @param correctionIndex ÍµêÏ†ï Ïù∏Îç±Ïä§
   * @param value ÏÑ§Ï†ïÌï† Í∞í
   * @param isExceptionState ÏòàÏô∏ Ï≤òÎ¶¨ ÏÉÅÌÉú Ïó¨Î∂Ä
   * @param isOriginalKept ÏõêÎ≥∏Ïú†ÏßÄ ÏÉÅÌÉú Ïó¨Î∂Ä
   * @param isUserEdited ÏÇ¨Ïö©Ïûê Ìé∏Ïßë ÏÉÅÌÉú Ïó¨Î∂Ä
   */
  setState(correctionIndex, value, isExceptionState = false, isOriginalKept = false, isUserEdited = false) {
    var _a;
    const stack = new Error().stack;
    const caller = ((_a = stack == null ? void 0 : stack.split("\n")[2]) == null ? void 0 : _a.trim()) || "unknown";
    Logger.debug(`\u{1F527} setState \uD638\uCD9C\uB428: index=${correctionIndex}, value="${value}", isUserEdited=${isUserEdited}, caller=${caller}`);
    this.states.set(correctionIndex, value);
    const exceptionKey = `${correctionIndex}_exception`;
    const originalKeptKey = `${correctionIndex}_originalKept`;
    const userEditedKey = `${correctionIndex}_userEdited`;
    if (isExceptionState) {
      this.states.set(exceptionKey, true);
    } else {
      this.states.delete(exceptionKey);
    }
    if (isOriginalKept) {
      this.states.set(originalKeptKey, true);
    } else {
      this.states.delete(originalKeptKey);
    }
    if (isUserEdited) {
      this.states.set(userEditedKey, true);
      this.userEditedValues.set(correctionIndex, value);
      Logger.debug(`\u{1F527} setState: \uC0AC\uC6A9\uC790 \uD3B8\uC9D1 \uC0C1\uD0DC \uC124\uC815 - userEditedKey="${userEditedKey}", value="${value}"`);
    } else {
      const wasUserEdited = this.states.has(userEditedKey);
      const existingUserValue = this.userEditedValues.get(correctionIndex);
      this.states.delete(userEditedKey);
      if (wasUserEdited) {
        Logger.debug(`\u{1F527} setState: \uC0AC\uC6A9\uC790 \uD3B8\uC9D1 \uC0C1\uD0DC \uD574\uC81C (\uD3B8\uC9D1\uAC12 \uBCF4\uC874) - userEditedKey="${userEditedKey}", \uBCF4\uC874\uAC12="${existingUserValue}", caller=${caller}`);
      }
    }
  }
  /**
   * ÌäπÏ†ï ÍµêÏ†ïÏùò ÌòÑÏû¨ Í∞íÏùÑ Í∞ÄÏ†∏ÏòµÎãàÎã§.
   * @param correctionIndex ÍµêÏ†ï Ïù∏Îç±Ïä§
   * @returns ÌòÑÏû¨ Í∞í
   */
  getValue(correctionIndex) {
    const isUserEdited = this.isUserEditedState(correctionIndex);
    const userEditedValue = this.userEditedValues.get(correctionIndex);
    const statesValue = this.states.get(correctionIndex) || "";
    const finalValue = isUserEdited && userEditedValue !== void 0 ? userEditedValue : statesValue;
    if (isUserEdited && !userEditedValue) {
      Logger.warn(`\u26A0\uFE0F \uC0AC\uC6A9\uC790 \uD3B8\uC9D1 \uC0C1\uD0DC\uC778\uB370 \uD3B8\uC9D1\uAC12\uC774 \uC5C6\uC74C: index=${correctionIndex}`);
    }
    Logger.debug(`getValue(${correctionIndex}): states="${statesValue}", userEdited=${isUserEdited}, userEditedValue="${userEditedValue}", finalValue="${finalValue}"`);
    return finalValue;
  }
  /**
   * ÌäπÏ†ï ÍµêÏ†ïÏù¥ ÏòàÏô∏ Ï≤òÎ¶¨ ÏÉÅÌÉúÏù∏ÏßÄ ÌôïÏù∏Ìï©ÎãàÎã§.
   * @param correctionIndex ÍµêÏ†ï Ïù∏Îç±Ïä§
   * @returns ÏòàÏô∏ Ï≤òÎ¶¨ ÏÉÅÌÉú Ïó¨Î∂Ä
   */
  isExceptionState(correctionIndex) {
    const exceptionKey = `${correctionIndex}_exception`;
    return !!this.states.get(exceptionKey);
  }
  /**
   * ÌäπÏ†ï ÍµêÏ†ïÏù¥ ÏõêÎ≥∏Ïú†ÏßÄ ÏÉÅÌÉúÏù∏ÏßÄ ÌôïÏù∏Ìï©ÎãàÎã§.
   * @param correctionIndex ÍµêÏ†ï Ïù∏Îç±Ïä§
   * @returns ÏõêÎ≥∏Ïú†ÏßÄ ÏÉÅÌÉú Ïó¨Î∂Ä
   */
  isOriginalKeptState(correctionIndex) {
    const originalKeptKey = `${correctionIndex}_originalKept`;
    return !!this.states.get(originalKeptKey);
  }
  /**
   * ÌäπÏ†ï ÍµêÏ†ïÏù¥ ÏÇ¨Ïö©Ïûê Ìé∏Ïßë ÏÉÅÌÉúÏù∏ÏßÄ ÌôïÏù∏Ìï©ÎãàÎã§.
   * @param correctionIndex ÍµêÏ†ï Ïù∏Îç±Ïä§
   * @returns ÏÇ¨Ïö©Ïûê Ìé∏Ïßë ÏÉÅÌÉú Ïó¨Î∂Ä
   */
  isUserEditedState(correctionIndex) {
    const userEditedKey = `${correctionIndex}_userEdited`;
    return !!this.states.get(userEditedKey);
  }
  /**
   * ÏÇ¨Ïö©Ïûê Ìé∏ÏßëÎêú Í∞íÏùÑ ÏÑ§Ï†ïÌï©ÎãàÎã§.
   * @param correctionIndex ÍµêÏ†ï Ïù∏Îç±Ïä§
   * @param userValue ÏÇ¨Ïö©ÏûêÍ∞Ä ÏûÖÎ†•Ìïú Í∞í
   */
  setUserEdited(correctionIndex, userValue) {
    Logger.debug(`\u{1F527} setUserEdited \uD638\uCD9C: index=${correctionIndex}, value="${userValue}"`);
    const beforeStates = this.states.get(correctionIndex);
    const beforeUserEdited = this.isUserEditedState(correctionIndex);
    const beforeUserValue = this.userEditedValues.get(correctionIndex);
    Logger.debug(`\u{1F527} Before setState: states="${beforeStates}", userEdited=${beforeUserEdited}, userValue="${beforeUserValue}"`);
    this.setState(correctionIndex, userValue, false, false, true);
    Logger.debug(`\u{1F527} \uC0AC\uC6A9\uC790 \uD3B8\uC9D1\uC740 \uB3D9\uAE30\uD654\uD558\uC9C0 \uC54A\uC74C - \uAC1C\uBCC4 \uD56D\uBAA9\uB9CC \uC801\uC6A9`);
    const afterStates = this.states.get(correctionIndex);
    const afterUserEdited = this.isUserEditedState(correctionIndex);
    const afterUserValue = this.userEditedValues.get(correctionIndex);
    Logger.debug(`\u{1F527} After setState: states="${afterStates}", userEdited=${afterUserEdited}, userValue="${afterUserValue}"`);
  }
  /**
   * ÌäπÏ†ï Îã®Ïñ¥Í∞Ä Ï¥àÍ∏∞Ïóê Î¨¥ÏãúÎêú Îã®Ïñ¥Ïù∏ÏßÄ ÌôïÏù∏Ìï©ÎãàÎã§.
   * @param word ÌôïÏù∏Ìï† Îã®Ïñ¥
   * @returns Ï¥àÍ∏∞Ïóê Î¨¥ÏãúÎêú Îã®Ïñ¥ Ïó¨Î∂Ä
   */
  isInitiallyIgnoredWord(word) {
    return this.ignoredWords.includes(word);
  }
  /**
   * 5Îã®Í≥Ñ ÌÜ†Í∏ÄÏùÑ ÏàòÌñâÌï©ÎãàÎã§.
   * - Ïò§Î•ò(Îπ®Í∞ÑÏÉâ) ‚Üí ÏàòÏ†ï1, ÏàòÏ†ï2...(Ï¥àÎ°ùÏÉâ) ‚Üí ÏòàÏô∏Ï≤òÎ¶¨(ÌååÎûÄÏÉâ) ‚Üí ÏõêÎ≥∏Ïú†ÏßÄ(Ï£ºÌô©ÏÉâ) ‚Üí ÏÇ¨Ïö©ÏûêÌé∏Ïßë(Î≥¥ÎùºÏÉâ) ‚Üí Ïò§Î•ò(Îπ®Í∞ÑÏÉâ)
   * @param correctionIndex ÍµêÏ†ï Ïù∏Îç±Ïä§
   * @returns ÏÉàÎ°úÏö¥ ÏÉÅÌÉú Ï†ïÎ≥¥
   */
  toggleState(correctionIndex) {
    Logger.debug(`\u{1F504} toggleState \uD638\uCD9C\uB428! correctionIndex: ${correctionIndex}`);
    if (correctionIndex < 0 || correctionIndex >= this.corrections.length) {
      throw new Error(`Invalid correction index: ${correctionIndex}`);
    }
    const correction = this.corrections[correctionIndex];
    const suggestions = [correction.original, ...correction.corrected];
    const currentValue = this.getValue(correctionIndex);
    const isCurrentlyException = this.isExceptionState(correctionIndex);
    const isCurrentlyOriginalKept = this.isOriginalKeptState(correctionIndex);
    const isCurrentlyUserEdited = this.isUserEditedState(correctionIndex);
    Logger.debug("toggleState Initial state:", {
      correctionIndex,
      currentValue,
      isCurrentlyException,
      isCurrentlyOriginalKept,
      isCurrentlyUserEdited,
      originalText: correction.original,
      suggestions
    });
    let newValue;
    let newIsException;
    let newIsOriginalKept;
    let newIsUserEdited;
    Logger.debug(`\u{1F50D} toggleState \uBD84\uAE30 \uC9C4\uB2E8: isCurrentlyUserEdited=${isCurrentlyUserEdited}, isCurrentlyOriginalKept=${isCurrentlyOriginalKept}, isCurrentlyException=${isCurrentlyException}`);
    if (isCurrentlyUserEdited) {
      Logger.debug("\u{1F504} toggleState \uBD84\uAE30 1 \uC9C4\uC785: UserEdited -> Error");
      newValue = correction.original;
      newIsException = false;
      newIsOriginalKept = false;
      newIsUserEdited = false;
      Logger.debug("toggleState UserEdited -> Error");
    } else if (isCurrentlyOriginalKept) {
      Logger.debug("\u{1F504} toggleState \uBD84\uAE30 2 \uC9C4\uC785: OriginalKept -> ?");
      const userEditedValue = this.userEditedValues.get(correctionIndex);
      if (userEditedValue) {
        newValue = userEditedValue;
        newIsException = false;
        newIsOriginalKept = false;
        newIsUserEdited = true;
        Logger.debug(`toggleState OriginalKept -> UserEdited: userEditedValue="${userEditedValue}"`);
      } else {
        newValue = correction.original;
        newIsException = false;
        newIsOriginalKept = false;
        newIsUserEdited = false;
        Logger.debug("toggleState OriginalKept -> Error (\uD3B8\uC9D1\uAC12 \uC5C6\uC74C, \uC0AC\uC6A9\uC790\uD3B8\uC9D1 \uAC74\uB108\uB700)");
      }
    } else if (isCurrentlyException) {
      Logger.debug("\u{1F504} toggleState \uBD84\uAE30 3 \uC9C4\uC785: Exception -> OriginalKept");
      newValue = correction.original;
      newIsException = false;
      newIsOriginalKept = true;
      newIsUserEdited = false;
      Logger.debug("toggleState Exception -> OriginalKept");
    } else {
      Logger.debug("\u{1F504} toggleState \uBD84\uAE30 4 \uC9C4\uC785: \uC81C\uC548 \uC21C\uD658 \uB85C\uC9C1");
      let nextIndex = suggestions.indexOf(currentValue) + 1;
      if (nextIndex >= suggestions.length) {
        newValue = correction.original;
        newIsException = true;
        newIsOriginalKept = false;
        newIsUserEdited = false;
        Logger.debug("toggleState Last Suggestion -> Exception");
      } else {
        newValue = suggestions[nextIndex];
        newIsException = false;
        newIsOriginalKept = false;
        newIsUserEdited = false;
        Logger.debug("toggleState Next Suggestion:", newValue);
      }
    }
    if (isCurrentlyUserEdited || newIsUserEdited) {
      this.setState(correctionIndex, newValue, newIsException, newIsOriginalKept, newIsUserEdited);
      Logger.debug(`\uC0AC\uC6A9\uC790 \uD3B8\uC9D1 \uAD00\uB828 \uC0C1\uD0DC \uBCC0\uD654\uB294 \uAC1C\uBCC4 \uC801\uC6A9\uB9CC \uC218\uD589: index ${correctionIndex}, from=${isCurrentlyUserEdited} to=${newIsUserEdited}`);
    } else {
      this.syncSameWordStates(correction.original, newValue, newIsException, newIsOriginalKept, newIsUserEdited, correctionIndex);
    }
    return { value: newValue, isExceptionState: newIsException };
  }
  /**
   * 5Îã®Í≥Ñ Ïó≠Î∞©Ìñ• ÌÜ†Í∏ÄÏùÑ ÏàòÌñâÌï©ÎãàÎã§.
   * - Ïò§Î•ò(Îπ®Í∞ÑÏÉâ) ‚Üí ÏÇ¨Ïö©ÏûêÌé∏Ïßë(Î≥¥ÎùºÏÉâ) ‚Üí ÏõêÎ≥∏Ïú†ÏßÄ(Ï£ºÌô©ÏÉâ) ‚Üí ÏòàÏô∏Ï≤òÎ¶¨(ÌååÎûÄÏÉâ) ‚Üí ÏàòÏ†ïN, ÏàòÏ†ï1(Ï¥àÎ°ùÏÉâ) ‚Üí Ïò§Î•ò(Îπ®Í∞ÑÏÉâ)
   * @param correctionIndex ÍµêÏ†ï Ïù∏Îç±Ïä§
   * @returns ÏÉàÎ°úÏö¥ ÏÉÅÌÉú Ï†ïÎ≥¥
   */
  toggleStatePrev(correctionIndex) {
    Logger.debug(`\u{1F504} toggleStatePrev \uD638\uCD9C\uB428! correctionIndex: ${correctionIndex}`);
    if (correctionIndex < 0 || correctionIndex >= this.corrections.length) {
      throw new Error(`Invalid correction index: ${correctionIndex}`);
    }
    const correction = this.corrections[correctionIndex];
    const suggestions = [correction.original, ...correction.corrected];
    const currentValue = this.getValue(correctionIndex);
    const isCurrentlyException = this.isExceptionState(correctionIndex);
    const isCurrentlyOriginalKept = this.isOriginalKeptState(correctionIndex);
    const isCurrentlyUserEdited = this.isUserEditedState(correctionIndex);
    Logger.debug("toggleStatePrev Initial state:", {
      correctionIndex,
      currentValue,
      isCurrentlyException,
      isCurrentlyOriginalKept,
      isCurrentlyUserEdited,
      originalText: correction.original,
      suggestions
    });
    let newValue;
    let newIsException;
    let newIsOriginalKept;
    let newIsUserEdited;
    if (currentValue === correction.original && !isCurrentlyException && !isCurrentlyOriginalKept && !isCurrentlyUserEdited) {
      const userEditedValue = this.userEditedValues.get(correctionIndex);
      if (userEditedValue) {
        newValue = userEditedValue;
        newIsException = false;
        newIsOriginalKept = false;
        newIsUserEdited = true;
        Logger.debug(`toggleStatePrev Error -> UserEdited: userEditedValue="${userEditedValue}"`);
      } else {
        newValue = correction.original;
        newIsException = false;
        newIsOriginalKept = true;
        newIsUserEdited = false;
        Logger.debug("toggleStatePrev Error -> OriginalKept (\uD3B8\uC9D1\uAC12 \uC5C6\uC74C, \uC0AC\uC6A9\uC790\uD3B8\uC9D1 \uAC74\uB108\uB700)");
      }
    } else if (isCurrentlyUserEdited) {
      newValue = correction.original;
      newIsException = false;
      newIsOriginalKept = true;
      newIsUserEdited = false;
      Logger.debug("toggleStatePrev UserEdited -> OriginalKept");
    } else if (isCurrentlyOriginalKept) {
      newValue = correction.original;
      newIsException = true;
      newIsOriginalKept = false;
      newIsUserEdited = false;
      Logger.debug("toggleStatePrev OriginalKept -> Exception");
    } else if (isCurrentlyException) {
      if (correction.corrected.length > 0) {
        newValue = correction.corrected[correction.corrected.length - 1];
        newIsException = false;
        newIsOriginalKept = false;
        newIsUserEdited = false;
        Logger.debug("toggleStatePrev Exception -> Last Suggestion");
      } else {
        const userEditedValue = this.userEditedValues.get(correctionIndex);
        if (userEditedValue) {
          newValue = userEditedValue;
          newIsException = false;
          newIsOriginalKept = false;
          newIsUserEdited = true;
          Logger.debug(`toggleStatePrev Exception -> UserEdited (no suggestions): userEditedValue="${userEditedValue}"`);
        } else {
          newValue = correction.original;
          newIsException = false;
          newIsOriginalKept = true;
          newIsUserEdited = false;
          Logger.debug("toggleStatePrev Exception -> OriginalKept (no suggestions, \uD3B8\uC9D1\uAC12 \uC5C6\uC74C)");
        }
      }
    } else {
      let currentIndex = suggestions.indexOf(currentValue);
      let prevIndex = currentIndex - 1;
      if (prevIndex < 0) {
        newValue = correction.original;
        newIsException = false;
        newIsOriginalKept = false;
        newIsUserEdited = false;
        Logger.debug("toggleStatePrev First Suggestion -> Error");
      } else {
        newValue = suggestions[prevIndex];
        newIsException = false;
        newIsOriginalKept = false;
        newIsUserEdited = false;
        Logger.debug("toggleStatePrev Previous Suggestion:", newValue);
      }
    }
    if (isCurrentlyUserEdited || newIsUserEdited) {
      this.setState(correctionIndex, newValue, newIsException, newIsOriginalKept, newIsUserEdited);
      Logger.debug(`\uC0AC\uC6A9\uC790 \uD3B8\uC9D1 \uAD00\uB828 \uC0C1\uD0DC \uBCC0\uD654\uB294 \uAC1C\uBCC4 \uC801\uC6A9\uB9CC \uC218\uD589: index ${correctionIndex}, from=${isCurrentlyUserEdited} to=${newIsUserEdited}`);
    } else {
      this.syncSameWordStates(correction.original, newValue, newIsException, newIsOriginalKept, newIsUserEdited, correctionIndex);
    }
    return { value: newValue, isExceptionState: newIsException };
  }
  /**
   * Í∞ôÏùÄ ÏõêÎ≥∏ ÌÖçÏä§Ìä∏Î•º Í∞ÄÏßÑ Î™®Îì† ÍµêÏ†ï Ìï≠Î™©Ïùò ÏÉÅÌÉúÎ•º ÎèôÍ∏∞ÌôîÌï©ÎãàÎã§.
   * @param originalText ÏõêÎ≥∏ ÌÖçÏä§Ìä∏
   * @param newValue ÏÉàÎ°úÏö¥ Í∞í
   * @param isException ÏòàÏô∏ Ï≤òÎ¶¨ ÏÉÅÌÉú
   * @param isOriginalKept ÏõêÎ≥∏ Ïú†ÏßÄ ÏÉÅÌÉú
   * @param isUserEdited ÏÇ¨Ïö©Ïûê Ìé∏Ïßë ÏÉÅÌÉú
   */
  syncSameWordStates(originalText, newValue, isException, isOriginalKept, isUserEdited = false, currentCorrectionIndex) {
    let syncedCount = 0;
    const coreWord = this.extractCoreWord(originalText);
    Logger.debug(`=== \uB3D9\uAE30\uD654 \uC2DC\uC791 ===`);
    Logger.debug(`\uC6D0\uBCF8: "${originalText}", \uD575\uC2EC: "${coreWord}"`);
    Logger.debug(`\uC804\uCCB4 \uAD50\uC815 \uAC1C\uC218: ${this.corrections.length}`);
    for (let i = 0; i < this.corrections.length; i++) {
      const targetOriginal = this.corrections[i].original;
      const targetCoreWord = this.extractCoreWord(targetOriginal);
      Logger.debug(`\uAD50\uC815 ${i}: "${targetOriginal}" \u2192 \uD575\uC2EC: "${targetCoreWord}"`);
      if (targetCoreWord === coreWord) {
        const existingUserEdited = this.isUserEditedState(i);
        if (existingUserEdited && i !== currentCorrectionIndex) {
          Logger.debug(`  \u2192 \uB9E4\uCE58\uD558\uC9C0\uB9CC \uAE30\uC874 \uC0AC\uC6A9\uC790 \uD3B8\uC9D1 \uC0C1\uD0DC \uC720\uC9C0 (index ${i})`);
        } else if (isUserEdited && i !== currentCorrectionIndex) {
          Logger.debug(`  \u2192 \uB9E4\uCE58\uD558\uC9C0\uB9CC \uC0AC\uC6A9\uC790 \uD3B8\uC9D1\uC740 \uAC1C\uBCC4 \uD56D\uBAA9\uB9CC \uC801\uC6A9 (index ${i})`);
        } else {
          const shouldPreserveUserEdited = existingUserEdited && !isUserEdited;
          const finalIsUserEdited = shouldPreserveUserEdited ? true : isUserEdited;
          const finalValue = shouldPreserveUserEdited ? this.userEditedValues.get(i) || newValue : newValue;
          Logger.debug(`  \u2192 \uB9E4\uCE58! \uB3D9\uAE30\uD654 \uC2E4\uD589 (index ${i}), preserveUserEdited=${shouldPreserveUserEdited}, finalIsUserEdited=${finalIsUserEdited}, finalValue="${finalValue}"`);
          this.setState(i, finalValue, isException, isOriginalKept, finalIsUserEdited);
          syncedCount++;
        }
      } else {
        Logger.debug(`  \u2192 \uB9E4\uCE58 \uC548\uB428 ("${targetCoreWord}" \u2260 "${coreWord}")`);
      }
    }
    Logger.debug(`\uAC19\uC740 \uB2E8\uC5B4 \uC77C\uAD04 \uC2DC\uAC01\uC801 \uC5C5\uB370\uC774\uD2B8: "${originalText}" (\uD575\uC2EC: "${coreWord}") \u2192 "${newValue}" (${syncedCount}\uAC1C \uD56D\uBAA9)`);
  }
  /**
   * ÌÖçÏä§Ìä∏ÏóêÏÑú ÌïµÏã¨ Îã®Ïñ¥Î•º Ï∂îÏ∂úÌï©ÎãàÎã§.
   * @param text ÏõêÎ≥∏ ÌÖçÏä§Ìä∏
   * @returns ÌïµÏã¨ Îã®Ïñ¥
   */
  extractCoreWord(text) {
    let coreWord = text.replace(/\([^)]*\)/g, "");
    const particles = ["\uC740", "\uB294", "\uC774", "\uAC00", "\uC744", "\uB97C", "\uC5D0", "\uC5D0\uC11C", "\uB85C", "\uC73C\uB85C", "\uC640", "\uACFC", "\uB3C4", "\uB9CC", "\uAE4C\uC9C0", "\uBD80\uD130", "\uCC98\uB7FC", "\uAC19\uC774", "\uBCF4\uB2E4", "\uB9C8\uB2E4", "\uC870\uCC28", "\uB9C8\uC800", "\uB77C\uB3C4", "\uB098\uB9C8", "\uC774\uB098", "\uAC70\uB098"];
    for (const particle of particles) {
      if (coreWord.endsWith(particle)) {
        coreWord = coreWord.slice(0, -particle.length);
        break;
      }
    }
    coreWord = coreWord.trim();
    Logger.debug(`\uD575\uC2EC \uB2E8\uC5B4 \uCD94\uCD9C: "${text}" \u2192 "${coreWord}"`);
    return coreWord;
  }
  /**
   * ÌäπÏ†ï ÍµêÏ†ïÏùò ÌëúÏãú ÌÅ¥ÎûòÏä§Î•º Í∞ÄÏ†∏ÏòµÎãàÎã§.
   * @param correctionIndex ÍµêÏ†ï Ïù∏Îç±Ïä§
   * @returns CSS ÌÅ¥ÎûòÏä§Î™Ö
   */
  getDisplayClass(correctionIndex) {
    const correction = this.corrections[correctionIndex];
    if (!correction)
      return "";
    if (this.isUserEditedState(correctionIndex)) {
      Logger.debug(`DisplayClass for ${correction.original} (index ${correctionIndex}): spell-user-edited`);
      return "spell-user-edited";
    }
    if (this.isOriginalKeptState(correctionIndex)) {
      Logger.debug(`DisplayClass for ${correction.original} (index ${correctionIndex}): spell-original-kept`);
      return "spell-original-kept";
    }
    const currentValue = this.getValue(correctionIndex);
    const isException = this.isExceptionState(correctionIndex);
    if (currentValue === correction.original) {
      const className = isException ? "spell-exception-processed" : "spell-error";
      Logger.debug(`DisplayClass for ${correction.original} (index ${correctionIndex}): ${className}`);
      return className;
    } else {
      Logger.debug(`DisplayClass for ${correction.original} (index ${correctionIndex}): spell-corrected`);
      return "spell-corrected";
    }
  }
  /**
   * ÌäπÏ†ï Í∞íÏù¥ ÏÑ†ÌÉùÎêòÏóàÎäîÏßÄ ÌôïÏù∏Ìï©ÎãàÎã§ (Ïò§Î•ò Ïπ¥ÎìúÏö©).
   * @param correctionIndex ÍµêÏ†ï Ïù∏Îç±Ïä§
   * @param value ÌôïÏù∏Ìï† Í∞í
   * @returns ÏÑ†ÌÉù Ïó¨Î∂Ä
   */
  isSelected(correctionIndex, value) {
    const correction = this.corrections[correctionIndex];
    if (!correction)
      return false;
    const currentValue = this.getValue(correctionIndex);
    const isException = this.isExceptionState(correctionIndex);
    if (value === correction.original) {
      return currentValue === correction.original && isException;
    } else {
      return currentValue === value && !isException;
    }
  }
  /**
   * Î™®Îì† ÏÉÅÌÉúÎ•º Í∞ÄÏ†∏ÏòµÎãàÎã§.
   * @returns ÏÉÅÌÉú Îßµ
   */
  getAllStates() {
    const allStates = {};
    for (let i = 0; i < this.corrections.length; i++) {
      const correction = this.corrections[i];
      const value = this.getValue(i);
      let state;
      if (this.isUserEditedState(i)) {
        state = "user-edited";
      } else if (this.isOriginalKeptState(i)) {
        state = "original-kept";
      } else if (this.isExceptionState(i)) {
        state = "exception-processed";
      } else if (value !== correction.original) {
        state = "corrected";
      } else {
        state = "error";
      }
      allStates[i] = { state, value };
    }
    return allStates;
  }
  /**
   * ÏµúÏ¢Ö Ï†ÅÏö©Ìï† ÌÖçÏä§Ìä∏Î•º ÏÉùÏÑ±Ìï©ÎãàÎã§.
   * @param originalText ÏõêÎ≥∏ ÌÖçÏä§Ìä∏
   * @returns ÍµêÏ†ïÏù¥ Ï†ÅÏö©Îêú ÌÖçÏä§Ìä∏ÏôÄ ÏòàÏô∏ Ï≤òÎ¶¨Îêú Îã®Ïñ¥Îì§
   */
  applyCorrections(originalText) {
    let finalText = originalText;
    const exceptionWords = [];
    Logger.log("\u{1F527} applyCorrections \uC2DC\uC791:", {
      originalTextLength: originalText.length,
      correctionsCount: this.corrections.length,
      originalPreview: originalText.substring(0, 100) + (originalText.length > 100 ? "..." : "")
    });
    for (let i = this.corrections.length - 1; i >= 0; i--) {
      const correction = this.corrections[i];
      const selectedValue = this.getValue(i);
      const isException = this.isExceptionState(i);
      const isUserEdited = this.isUserEditedState(i);
      Logger.debug(`\u{1F527} \uAD50\uC815 \uCC98\uB9AC [${i}]: "${correction.original}" \u2192 "${selectedValue}" (userEdited=${isUserEdited}, exception=${isException})`);
      if (isException) {
        if (!exceptionWords.includes(correction.original)) {
          exceptionWords.push(correction.original);
        }
        Logger.debug(`\u{1F527} \uC608\uC678\uCC98\uB9AC\uB85C \uCD94\uAC00: "${correction.original}"`);
      } else if (selectedValue !== correction.original) {
        Logger.log(`\u{1F527} \uD14D\uC2A4\uD2B8 \uAD50\uCCB4 \uC2E4\uD589: "${correction.original}" \u2192 "${selectedValue}" (userEdited=${isUserEdited})`);
        const beforeReplace = finalText;
        finalText = this.replaceAllOccurrences(finalText, correction.original, selectedValue);
        const changed = beforeReplace !== finalText;
        Logger.debug(`\u{1F527} \uAD50\uCCB4 \uACB0\uACFC: \uBCC0\uACBD\uB428=${changed}, \uD14D\uC2A4\uD2B8\uAE38\uC774 ${beforeReplace.length} \u2192 ${finalText.length}`);
      } else {
        Logger.debug(`\u{1F527} \uAD50\uC815 \uAC74\uB108\uB700: \uC6D0\uBCF8\uACFC \uB3D9\uC77C\uD558\uAC70\uB098 \uC608\uC678\uCC98\uB9AC\uB428`);
      }
    }
    Logger.log("\u{1F527} applyCorrections \uC644\uB8CC:", {
      finalTextLength: finalText.length,
      exceptionWordsCount: exceptionWords.length,
      changed: originalText !== finalText,
      finalPreview: finalText.substring(0, 100) + (finalText.length > 100 ? "..." : "")
    });
    return { finalText, exceptionWords };
  }
  /**
   * ÌÖçÏä§Ìä∏ÏóêÏÑú Î™®Îì† Î∞úÏÉù ÏúÑÏπòÎ•º ÏïàÏ†ÑÌïòÍ≤å ÍµêÏ≤¥Ìï©ÎãàÎã§.
   * @param text ÎåÄÏÉÅ ÌÖçÏä§Ìä∏
   * @param original ÏõêÎ≥∏ Î¨∏ÏûêÏó¥
   * @param replacement ÍµêÏ≤¥Ìï† Î¨∏ÏûêÏó¥
   * @returns ÍµêÏ≤¥Îêú ÌÖçÏä§Ìä∏
   */
  replaceAllOccurrences(text, original, replacement) {
    const escapedOriginal = original.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    const regex = new RegExp(escapedOriginal, "g");
    const result = text.replace(regex, replacement);
    const occurrences = (text.match(regex) || []).length;
    if (occurrences > 0) {
      Logger.debug(`\uC77C\uAD04 \uC218\uC815: "${original}" \u2192 "${replacement}" (${occurrences}\uAC1C \uC704\uCE58)`);
    }
    return result;
  }
  /**
   * ÏòàÏô∏ Ï≤òÎ¶¨Îêú Îã®Ïñ¥ Î™©Î°ùÏùÑ Í∞ÄÏ†∏ÏòµÎãàÎã§.
   * @returns ÏòàÏô∏ Ï≤òÎ¶¨Îêú Îã®Ïñ¥ Î∞∞Ïó¥
   */
  getExceptionWords() {
    const exceptionWords = [];
    for (let i = 0; i < this.corrections.length; i++) {
      if (this.isExceptionState(i)) {
        const correction = this.corrections[i];
        if (!exceptionWords.includes(correction.original)) {
          exceptionWords.push(correction.original);
        }
      }
    }
    return exceptionWords;
  }
};

// src/utils/textUtils.ts
init_logger();
function findOptimalBreakPoint(text, targetLength, tolerance = 200) {
  if (text.length <= targetLength)
    return text.length;
  const minLength = Math.max(0, targetLength - tolerance);
  const maxLength = Math.min(text.length, targetLength + tolerance);
  const patterns = [
    { regex: /[.!?]\s+/g, score: 100 },
    // Î¨∏Ïû• ÎÅù + Í≥µÎ∞±
    { regex: /[.!?]$/g, score: 95 },
    // Î¨∏Ïû• ÎÅù (ÌÖçÏä§Ìä∏ ÎßàÏßÄÎßâ)
    { regex: /[.!?]/g, score: 90 },
    // Î¨∏Ïû• ÎÅù
    { regex: /[,;]\s+/g, score: 80 },
    // ÏâºÌëú, ÏÑ∏ÎØ∏ÏΩúÎ°† + Í≥µÎ∞±
    { regex: /\n\s*/g, score: 85 },
    // Ï§ÑÎ∞îÍøà
    { regex: /\s{2,}/g, score: 70 },
    // Ïó¨Îü¨ Í≥µÎ∞±
    { regex: /\s+/g, score: 60 }
    // Îã®Ïùº Í≥µÎ∞±
  ];
  let bestBreakPoint = targetLength;
  let bestScore = -1;
  for (const pattern of patterns) {
    const matches = Array.from(text.matchAll(pattern.regex));
    for (const match of matches) {
      const endIndex = match.index + match[0].length;
      if (endIndex >= minLength && endIndex <= maxLength) {
        const distanceFromTarget = Math.abs(endIndex - targetLength);
        const distanceScore = Math.max(0, 50 - distanceFromTarget);
        const totalScore = pattern.score + distanceScore;
        if (totalScore > bestScore) {
          bestScore = totalScore;
          bestBreakPoint = endIndex;
        }
      }
    }
  }
  return bestBreakPoint;
}
function splitTextIntoPages(text, charsPerPage) {
  if (text.length <= charsPerPage) {
    return [text.length];
  }
  const pageBreaks = [];
  let currentPosition = 0;
  while (currentPosition < text.length) {
    const remainingText = text.slice(currentPosition);
    if (remainingText.length <= charsPerPage) {
      pageBreaks.push(text.length);
      break;
    }
    const breakPoint = findOptimalBreakPoint(remainingText, charsPerPage);
    const absoluteBreakPoint = currentPosition + breakPoint;
    pageBreaks.push(absoluteBreakPoint);
    currentPosition = absoluteBreakPoint;
  }
  return pageBreaks;
}
function calculateDynamicCharsPerPage(previewElement, isErrorExpanded = false) {
  if (!previewElement) {
    Logger.debug("No previewElement, returning default 800.");
    return 800;
  }
  const previewRect = previewElement.getBoundingClientRect();
  const availableHeight = previewRect.height;
  const avgCharsPerLine = 75;
  const lineHeight = 15 * 1.7;
  const linesPerPage = Math.floor(availableHeight / lineHeight);
  let calculatedChars;
  if (isErrorExpanded) {
    calculatedChars = Math.max(500, Math.min(1e3, linesPerPage * avgCharsPerLine));
  } else {
    calculatedChars = Math.max(800, Math.min(1800, linesPerPage * avgCharsPerLine));
  }
  Logger.debug(`Available height: ${availableHeight}, Lines per page: ${linesPerPage}, Calculated chars: ${calculatedChars}, Error expanded: ${isErrorExpanded}`);
  return calculatedChars;
}
function getCurrentParagraph(editor) {
  const cursor = editor.getCursor();
  const currentLine = cursor.line;
  const totalLines = editor.lineCount();
  Logger.debug(`\uBB38\uB2E8 \uAC10\uC9C0 \uC2DC\uC791: \uD604\uC7AC \uB77C\uC778 ${currentLine}, \uCD1D \uB77C\uC778 ${totalLines}`);
  const currentWord = editor.wordAt(cursor);
  if (currentWord) {
    Logger.debug(`\uD604\uC7AC \uB2E8\uC5B4 \uBC94\uC704: ${currentWord.from.line}:${currentWord.from.ch} - ${currentWord.to.line}:${currentWord.to.ch}`);
  }
  let startLine = currentLine;
  let endLine = currentLine;
  while (startLine > 0) {
    const prevLine = editor.getLine(startLine - 1);
    if (prevLine.trim() === "") {
      break;
    }
    if (prevLine.startsWith("#")) {
      break;
    }
    if (prevLine.match(/^[\s]*[-*+]\s/) || prevLine.match(/^[\s]*\d+\.\s/)) {
      break;
    }
    if (prevLine.startsWith("```")) {
      break;
    }
    startLine--;
  }
  while (endLine < totalLines - 1) {
    const nextLine = editor.getLine(endLine + 1);
    if (nextLine.trim() === "") {
      break;
    }
    if (nextLine.startsWith("#")) {
      break;
    }
    if (nextLine.match(/^[\s]*[-*+]\s/) || nextLine.match(/^[\s]*\d+\.\s/)) {
      break;
    }
    if (nextLine.startsWith("```")) {
      break;
    }
    endLine++;
  }
  const from = { line: startLine, ch: 0 };
  const to = { line: endLine, ch: editor.getLine(endLine).length };
  const text = editor.getRange(from, to);
  Logger.debug(`\uBB38\uB2E8 \uAC10\uC9C0 \uC644\uB8CC: ${startLine}\uD589-${endLine}\uD589 (${text.length}\uC790)`);
  Logger.debug(`\uBB38\uB2E8 \uB0B4\uC6A9 \uBBF8\uB9AC\uBCF4\uAE30: "${text.substring(0, 50)}${text.length > 50 ? "..." : ""}"`);
  return { text, from, to };
}
function getCurrentWord(editor) {
  const cursor = editor.getCursor();
  const wordRange = editor.wordAt(cursor);
  if (!wordRange) {
    return null;
  }
  const text = editor.getRange(wordRange.from, wordRange.to);
  Logger.debug(`\uD604\uC7AC \uB2E8\uC5B4 \uAC10\uC9C0: "${text}" (${wordRange.from.line}:${wordRange.from.ch} - ${wordRange.to.line}:${wordRange.to.ch})`);
  return {
    text,
    from: wordRange.from,
    to: wordRange.to
  };
}
function getCurrentSentence(editor) {
  const cursor = editor.getCursor();
  const currentLine = cursor.line;
  const currentChar = cursor.ch;
  const currentLineText = editor.getLine(currentLine);
  Logger.debug(`\uBB38\uC7A5 \uAC10\uC9C0 \uC2DC\uC791: ${currentLine}\uD589 ${currentChar}\uC5F4`);
  const sentenceEndPattern = /[.!?„ÄÇÔºÅÔºü]/;
  const sentenceEndPatternGlobal = /[.!?„ÄÇÔºÅÔºü]/g;
  let sentenceStart = 0;
  let sentenceStartLine = currentLine;
  let sentenceStartChar = 0;
  for (let i = currentChar - 1; i >= 0; i--) {
    if (sentenceEndPattern.test(currentLineText[i])) {
      sentenceStartChar = i + 1;
      break;
    }
  }
  if (sentenceStartChar === 0) {
    let searchLine = currentLine - 1;
    while (searchLine >= 0) {
      const lineText = editor.getLine(searchLine);
      if (lineText.trim() === "") {
        sentenceStartLine = searchLine + 1;
        sentenceStartChar = 0;
        break;
      }
      if (lineText.startsWith("#") || lineText.match(/^[\s]*[-*+]\s/) || lineText.match(/^[\s]*\d+\.\s/)) {
        sentenceStartLine = searchLine + 1;
        sentenceStartChar = 0;
        break;
      }
      const matches = Array.from(lineText.matchAll(sentenceEndPatternGlobal));
      if (matches.length > 0) {
        const lastMatch = matches[matches.length - 1];
        if (lastMatch && typeof lastMatch.index === "number") {
          sentenceStartLine = searchLine;
          sentenceStartChar = lastMatch.index + 1;
          break;
        }
      }
      searchLine--;
    }
  }
  let sentenceEndLine = currentLine;
  let sentenceEndChar = currentLineText.length;
  for (let i = currentChar; i < currentLineText.length; i++) {
    if (sentenceEndPattern.test(currentLineText[i])) {
      sentenceEndChar = i + 1;
      break;
    }
  }
  if (sentenceEndChar === currentLineText.length) {
    const totalLines = editor.lineCount();
    let searchLine = currentLine + 1;
    while (searchLine < totalLines) {
      const lineText = editor.getLine(searchLine);
      if (lineText.trim() === "") {
        sentenceEndLine = searchLine - 1;
        sentenceEndChar = editor.getLine(sentenceEndLine).length;
        break;
      }
      if (lineText.startsWith("#") || lineText.match(/^[\s]*[-*+]\s/) || lineText.match(/^[\s]*\d+\.\s/)) {
        sentenceEndLine = searchLine - 1;
        sentenceEndChar = editor.getLine(sentenceEndLine).length;
        break;
      }
      const match = lineText.match(sentenceEndPattern);
      if (match && match.index !== void 0) {
        sentenceEndLine = searchLine;
        sentenceEndChar = match.index + 1;
        break;
      }
      searchLine++;
    }
  }
  const from = { line: sentenceStartLine, ch: sentenceStartChar };
  const to = { line: sentenceEndLine, ch: sentenceEndChar };
  const text = editor.getRange(from, to).trim();
  Logger.debug(`\uBB38\uC7A5 \uAC10\uC9C0 \uC644\uB8CC: ${sentenceStartLine}:${sentenceStartChar} - ${sentenceEndLine}:${sentenceEndChar}`);
  Logger.debug(`\uBB38\uC7A5 \uB0B4\uC6A9: "${text.substring(0, 50)}${text.length > 50 ? "..." : ""}"`);
  return { text, from, to };
}

// src/ui/correctionPopup.ts
init_logger();
var CorrectionPopup = class extends BaseComponent {
  constructor(app, config, aiService, onSettingsUpdate) {
    super("div", "correction-popup-container");
    // Pagination state
    this.isLongText = false;
    this.currentPreviewPage = 0;
    this.totalPreviewPages = 1;
    this.pageBreaks = [];
    this.charsPerPage = 800;
    // AI Î∂ÑÏÑù Í≤∞Í≥º
    this.aiAnalysisResults = [];
    this.isAiAnalyzing = false;
    this.currentFocusIndex = 0;
    this.currentCorrections = [];
    // Ï†ÑÏ≤¥ Ïò§Î•ò ÏúÑÏπò Ï∫êÏãú
    this.allErrorPositions = [];
    this.app = app;
    this.config = config;
    this.stateManager = new CorrectionStateManager(config.corrections, this.config.ignoredWords);
    this.aiService = aiService;
    this.onSettingsUpdate = onSettingsUpdate;
    this.keyboardScope = new import_obsidian2.Scope();
    this.setupKeyboardNavigation();
    this.initializePagination();
    this.calculateAllErrorPositions();
  }
  /**
   * ÌÇ§Î≥¥Îìú ÎÑ§ÎπÑÍ≤åÏù¥ÏÖòÏùÑ ÏÑ§Ï†ïÌï©ÎãàÎã§.
   */
  setupKeyboardNavigation() {
    this.keyboardScope.register([], "Tab", (evt) => {
      evt.preventDefault();
      this.focusNextError();
      return false;
    });
    this.keyboardScope.register(["Shift"], "Tab", (evt) => {
      evt.preventDefault();
      this.focusPrevError();
      return false;
    });
    this.keyboardScope.register([], "Enter", (evt) => {
      var _a;
      const target = evt.target;
      if (target && (((_a = target.dataset) == null ? void 0 : _a.editMode) === "true" || target.classList.contains("error-original-input"))) {
        Logger.debug("Enter key in edit mode - allowing default behavior");
        return true;
      }
      evt.preventDefault();
      this.applyCurrentSelection();
      return false;
    });
    this.keyboardScope.register([], "Escape", (evt) => {
      var _a;
      const target = evt.target;
      if (target && (((_a = target.dataset) == null ? void 0 : _a.editMode) === "true" || target.classList.contains("error-original-input"))) {
        Logger.debug("Escape key in edit mode - allowing default behavior");
        return true;
      }
      evt.preventDefault();
      this.close();
      return false;
    });
    this.keyboardScope.register([], "ArrowRight", (evt) => {
      if (this.isInEditMode()) {
        Logger.debug("\u{1F6AB} \uD3B8\uC9D1 \uBAA8\uB4DC \uC911 - ArrowRight \uBE44\uD65C\uC131\uD654");
        return;
      }
      evt.preventDefault();
      this.cycleCurrentCorrectionNext();
      return false;
    });
    this.keyboardScope.register([], "ArrowLeft", (evt) => {
      if (this.isInEditMode()) {
        Logger.debug("\u{1F6AB} \uD3B8\uC9D1 \uBAA8\uB4DC \uC911 - ArrowLeft \uBE44\uD65C\uC131\uD654");
        return;
      }
      evt.preventDefault();
      this.cycleCurrentCorrectionPrev();
      return false;
    });
    this.keyboardScope.register(["Shift", "Mod"], "KeyA", (evt) => {
      evt.preventDefault();
      evt.stopPropagation();
      evt.stopImmediatePropagation();
      this.triggerAIAnalysis();
      return false;
    });
    this.keyboardScope.register([], "ArrowUp", (evt) => {
      if (this.isLongText && this.currentPreviewPage > 0) {
        evt.preventDefault();
        this.goToPrevPage();
        return false;
      }
      return true;
    });
    this.keyboardScope.register([], "ArrowDown", (evt) => {
      if (this.isInEditMode()) {
        return;
      }
      if (this.isLongText && this.currentPreviewPage < this.totalPreviewPages - 1) {
        evt.preventDefault();
        this.goToNextPage();
        return false;
      }
      return true;
    });
    this.keyboardScope.register(["Mod", "Shift"], "ArrowRight", (evt) => {
      if (this.isInEditMode()) {
        Logger.debug("\u{1F6AB} \uD3B8\uC9D1 \uBAA8\uB4DC \uC911 - \uC77C\uAD04 \uBCC0\uACBD \uBE44\uD65C\uC131\uD654");
        return;
      }
      evt.preventDefault();
      this.batchCycleCorrections("next");
      return false;
    });
    this.keyboardScope.register(["Mod", "Shift"], "ArrowLeft", (evt) => {
      if (this.isInEditMode()) {
        Logger.debug("\u{1F6AB} \uD3B8\uC9D1 \uBAA8\uB4DC \uC911 - \uC77C\uAD04 \uBCC0\uACBD \uBE44\uD65C\uC131\uD654");
        return;
      }
      evt.preventDefault();
      this.batchCycleCorrections("prev");
      return false;
    });
    this.keyboardScope.register(["Mod"], "Enter", (evt) => {
      evt.preventDefault();
      evt.stopPropagation();
      evt.stopImmediatePropagation();
      this.applyCorrections();
      return false;
    });
    Logger.log("\uD0A4\uBCF4\uB4DC \uB124\uBE44\uAC8C\uC774\uC158 \uC124\uC815 \uC644\uB8CC");
  }
  /**
   * Îã§Ïùå Ïò§Î•ò Ìï≠Î™©ÏúºÎ°ú Ìè¨Ïª§Ïä§Î•º Ïù¥ÎèôÌï©ÎãàÎã§.
   */
  focusNextError() {
    var _a, _b;
    Logger.debug("========= focusNextError \uC2DC\uC791 =========");
    Logger.debug(`\uD604\uC7AC \uD3EC\uCEE4\uC2A4 \uC778\uB371\uC2A4: ${this.currentFocusIndex}`);
    const rawCorrections = this.getCurrentCorrections();
    Logger.debug(`RAW \uC218\uC815\uC0AC\uD56D \uAC1C\uC218: ${rawCorrections.length}`);
    Logger.debug("RAW \uC218\uC815\uC0AC\uD56D \uBAA9\uB85D:", rawCorrections.map((pc) => ({
      original: pc.correction.original,
      originalIndex: pc.originalIndex,
      uniqueId: pc.uniqueId,
      absolutePosition: pc.absolutePosition
    })));
    this.currentCorrections = this.removeDuplicateCorrections(rawCorrections);
    Logger.debug(`\uC911\uBCF5 \uC81C\uAC70 \uC804\uD6C4: ${rawCorrections.length} \u2192 ${this.currentCorrections.length}`);
    Logger.debug("\uC911\uBCF5 \uC81C\uAC70 \uD6C4 \uBAA9\uB85D:", this.currentCorrections.map((pc) => ({
      original: pc.correction.original,
      originalIndex: pc.originalIndex,
      uniqueId: pc.uniqueId,
      absolutePosition: pc.absolutePosition
    })));
    if (this.currentCorrections.length === 0) {
      Logger.debug("\uC218\uC815\uC0AC\uD56D\uC774 \uC5C6\uC5B4 \uD568\uC218 \uC885\uB8CC");
      return;
    }
    const oldFocusIndex = this.currentFocusIndex;
    if (this.currentFocusIndex === -1) {
      this.currentFocusIndex = 0;
    } else {
      this.currentFocusIndex = (this.currentFocusIndex + 1) % this.currentCorrections.length;
    }
    Logger.debug(`\uD3EC\uCEE4\uC2A4 \uC778\uB371\uC2A4 \uBCC0\uACBD: ${oldFocusIndex} \u2192 ${this.currentFocusIndex}`);
    Logger.debug(`\uD3EC\uCEE4\uC2A4 \uB300\uC0C1: ${(_a = this.currentCorrections[this.currentFocusIndex]) == null ? void 0 : _a.correction.original} (\uACE0\uC720ID: ${(_b = this.currentCorrections[this.currentFocusIndex]) == null ? void 0 : _b.uniqueId})`);
    this.updateFocusHighlight();
    const errorSummary = document.getElementById("errorSummary");
    const isExpanded = errorSummary && !errorSummary.classList.contains("collapsed");
    if (isExpanded) {
      this.scrollToFocusedError(false);
    }
    Logger.debug(`\uD3EC\uCEE4\uC2A4 \uC774\uB3D9 \uC644\uB8CC: ${this.currentFocusIndex}/${this.currentCorrections.length}, \uC0C1\uC138\uBCF4\uAE30 \uD3BC\uCCD0\uC9D0: ${isExpanded}`);
    Logger.debug("========= focusNextError \uC885\uB8CC =========");
  }
  /**
   * Ïù¥Ï†Ñ Ïò§Î•ò Ìï≠Î™©ÏúºÎ°ú Ìè¨Ïª§Ïä§Î•º Ïù¥ÎèôÌï©ÎãàÎã§.
   */
  focusPrevError() {
    const rawCorrections = this.getCurrentCorrections();
    this.currentCorrections = this.removeDuplicateCorrections(rawCorrections);
    if (this.currentCorrections.length === 0)
      return;
    if (this.currentFocusIndex === -1) {
      this.currentFocusIndex = this.currentCorrections.length - 1;
    } else {
      this.currentFocusIndex = this.currentFocusIndex === 0 ? this.currentCorrections.length - 1 : this.currentFocusIndex - 1;
    }
    this.updateFocusHighlight();
    const errorSummary = document.getElementById("errorSummary");
    const isExpanded = errorSummary && !errorSummary.classList.contains("collapsed");
    if (isExpanded) {
      this.scrollToFocusedError(false);
    }
    Logger.debug(`\uD3EC\uCEE4\uC2A4 \uC774\uB3D9: ${this.currentFocusIndex}/${this.currentCorrections.length}, \uC0C1\uC138\uBCF4\uAE30 \uD3BC\uCCD0\uC9D0: ${isExpanded}`);
  }
  /**
   * ÌòÑÏû¨ Ìè¨Ïª§Ïä§Îêú Ìï≠Î™©Ïùò ÏàòÏ†ïÏÇ¨Ìï≠ÏùÑ Ï†ÅÏö©Ìï©ÎãàÎã§.
   */
  applyCurrentSelection() {
    if (this.currentCorrections.length === 0) {
      this.close();
      return;
    }
    const pageCorrection = this.currentCorrections[this.currentFocusIndex];
    if (!pageCorrection)
      return;
    const actualIndex = pageCorrection.originalIndex;
    const currentState = this.stateManager.getValue(actualIndex);
    Logger.debug(`\uD0A4\uBCF4\uB4DC\uB85C \uC218\uC815\uC0AC\uD56D \uC801\uC6A9: ${currentState}`);
  }
  /**
   * ÌòÑÏû¨ Ìè¨Ïª§Ïä§Îêú Ïò§Î•òÏùò Îã§Ïùå ÏàòÏ†ï Ï†úÏïàÏúºÎ°ú ÏàúÌôòÌï©ÎãàÎã§.
   */
  cycleCurrentCorrectionNext() {
    if (this.currentCorrections.length === 0)
      return;
    const pageCorrection = this.currentCorrections[this.currentFocusIndex];
    if (!pageCorrection)
      return;
    const actualIndex = pageCorrection.originalIndex;
    this.cycleCorrectionState(actualIndex, "next");
  }
  /**
   * ÌòÑÏû¨ Ìè¨Ïª§Ïä§Îêú Ïò§Î•òÏùò Ïù¥Ï†Ñ ÏàòÏ†ï Ï†úÏïàÏúºÎ°ú ÏàúÌôòÌï©ÎãàÎã§.
   */
  cycleCurrentCorrectionPrev() {
    if (this.currentCorrections.length === 0)
      return;
    const pageCorrection = this.currentCorrections[this.currentFocusIndex];
    if (!pageCorrection)
      return;
    const actualIndex = pageCorrection.originalIndex;
    this.cycleCorrectionState(actualIndex, "prev");
  }
  /**
   * ÏàòÏ†ï Ï†úÏïà ÏÉÅÌÉúÎ•º ÏàúÌôòÏãúÌÇµÎãàÎã§.
   */
  cycleCorrectionState(correctionIndex, direction) {
    const correction = this.config.corrections[correctionIndex];
    if (!correction)
      return;
    const result = direction === "next" ? this.stateManager.toggleState(correctionIndex) : this.stateManager.toggleStatePrev(correctionIndex);
    Logger.log(`\uC218\uC815 \uC81C\uC548 \uC21C\uD658: ${direction}, index: ${correctionIndex}, \uC0C8\uB85C\uC6B4 \uAC12: ${result.value}`);
    this.updateDisplay();
  }
  /**
   * AI Î∂ÑÏÑùÏùÑ Ìä∏Î¶¨Í±∞Ìï©ÎãàÎã§.
   */
  triggerAIAnalysis() {
    Logger.log("AI \uBD84\uC11D \uD2B8\uB9AC\uAC70\uB428 (\uD0A4\uBCF4\uB4DC \uB2E8\uCD95\uD0A4)");
    const aiBtn = this.element.querySelector("#aiAnalyzeBtn");
    if (aiBtn && !aiBtn.disabled) {
      Logger.log("AI \uBD84\uC11D \uBC84\uD2BC \uD074\uB9AD \uC2E4\uD589");
      aiBtn.click();
    } else {
      Logger.warn("AI \uBD84\uC11D \uBC84\uD2BC\uC774 \uBE44\uD65C\uC131\uD654\uB418\uC5B4 \uC788\uAC70\uB098 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
      if (this.aiService && !this.isAiAnalyzing) {
        this.performAIAnalysis();
      }
    }
  }
  /**
   * Ïù¥Ï†Ñ ÌéòÏù¥ÏßÄÎ°ú Ïù¥ÎèôÌï©ÎãàÎã§.
   */
  goToPrevPage() {
    if (this.currentPreviewPage > 0) {
      this.currentPreviewPage--;
      this.updateDisplay();
      this.resetFocusToFirstError();
    }
  }
  /**
   * Îã§Ïùå ÌéòÏù¥ÏßÄÎ°ú Ïù¥ÎèôÌï©ÎãàÎã§.
   */
  goToNextPage() {
    if (this.currentPreviewPage < this.totalPreviewPages - 1) {
      this.currentPreviewPage++;
      this.updateDisplay();
      this.resetFocusToFirstError();
    }
  }
  /**
   * Ìè¨Ïª§Ïä§Î•º Ï≤´ Î≤àÏß∏ Ïò§Î•òÎ°ú Î¶¨ÏÖãÌï©ÎãàÎã§.
   */
  resetFocusToFirstError() {
    Logger.debug("========= resetFocusToFirstError \uC2DC\uC791 =========");
    const rawCorrections = this.getCurrentCorrections();
    Logger.debug(`RAW \uC624\uB958 \uAC1C\uC218: ${rawCorrections.length}`);
    this.currentCorrections = this.removeDuplicateCorrections(rawCorrections);
    Logger.debug(`\uC911\uBCF5 \uC81C\uAC70 \uD6C4 \uC624\uB958 \uAC1C\uC218: ${this.currentCorrections.length}`);
    if (this.currentCorrections.length > 0) {
      this.currentFocusIndex = 0;
      Logger.debug(`\uD3EC\uCEE4\uC2A4 \uC778\uB371\uC2A4\uB97C 0\uC73C\uB85C \uC124\uC815`);
      setTimeout(() => {
        Logger.debug("\uC9C0\uC5F0 \uD6C4 \uD3EC\uCEE4\uC2A4 \uD558\uC774\uB77C\uC774\uD2B8 \uC5C5\uB370\uC774\uD2B8 \uC2E4\uD589");
        this.updateFocusHighlight();
      }, 100);
      const firstPageCorrection = this.currentCorrections[0];
      const actualIndex = firstPageCorrection.originalIndex;
      Logger.debug(`\uCD08\uAE30 \uD3EC\uCEE4\uC2A4 \uC124\uC815: ${this.currentFocusIndex}/${this.currentCorrections.length}`);
      Logger.debug(`\uCCAB \uBC88\uC9F8 \uC624\uB958: "${firstPageCorrection.correction.original}" (\uC804\uCCB4 \uBC30\uC5F4 \uC778\uB371\uC2A4: ${actualIndex}, \uACE0\uC720ID: ${firstPageCorrection.uniqueId})`);
      Logger.debug("\uD604\uC7AC \uD398\uC774\uC9C0 \uC624\uB958 \uBAA9\uB85D:", this.currentCorrections.map((pc) => ({
        original: pc.correction.original,
        originalIndex: pc.originalIndex,
        uniqueId: pc.uniqueId
      })));
    } else {
      this.currentFocusIndex = -1;
      Logger.debug("\uC624\uB958\uAC00 \uC5C6\uC5B4 \uD3EC\uCEE4\uC2A4 \uC124\uC815\uD558\uC9C0 \uC54A\uC74C");
    }
    Logger.debug("========= resetFocusToFirstError \uC885\uB8CC =========");
  }
  /**
   * ÌòÑÏû¨ Ìè¨Ïª§Ïä§Îêú Ìï≠Î™©ÏùÑ ÏãúÍ∞ÅÏ†ÅÏúºÎ°ú ÌëúÏãúÌï©ÎãàÎã§.
   */
  updateFocusHighlight() {
    var _a;
    Logger.debug("========= updateFocusHighlight \uC2DC\uC791 =========");
    Logger.debug(`currentCorrections \uAE38\uC774: ${this.currentCorrections.length}`);
    Logger.debug(`currentFocusIndex: ${this.currentFocusIndex}`);
    const prevFocused = this.element.querySelectorAll(".keyboard-focused");
    Logger.debug(`\uAE30\uC874 \uD3EC\uCEE4\uC2A4 \uC694\uC18C ${prevFocused.length}\uAC1C \uC81C\uAC70`);
    prevFocused.forEach((el) => el.removeClass("keyboard-focused"));
    if (this.currentCorrections.length > 0 && this.currentFocusIndex >= 0 && this.currentFocusIndex < this.currentCorrections.length) {
      const pageCorrection = this.currentCorrections[this.currentFocusIndex];
      const actualIndex = pageCorrection.originalIndex;
      const uniqueId = pageCorrection.uniqueId;
      Logger.debug(`\uD3EC\uCEE4\uC2A4 \uB300\uC0C1 \uC815\uBCF4:`, {
        original: pageCorrection.correction.original,
        actualIndex,
        uniqueId,
        absolutePosition: pageCorrection.absolutePosition
      });
      let errorItem = this.element.querySelector(`[data-unique-id="${uniqueId}"]`);
      Logger.debug(`\uACE0\uC720 ID\uB85C \uAC80\uC0C9: [data-unique-id="${uniqueId}"] \u2192 ${errorItem ? "\uBC1C\uACAC" : "\uBBF8\uBC1C\uACAC"}`);
      if (!errorItem) {
        errorItem = this.element.querySelector(`[data-correction-index="${actualIndex}"]`);
        Logger.debug(`\uC778\uB371\uC2A4\uB85C \uAC80\uC0C9: [data-correction-index="${actualIndex}"] \u2192 ${errorItem ? "\uBC1C\uACAC" : "\uBBF8\uBC1C\uACAC"}`);
      }
      if (errorItem) {
        errorItem.addClass("keyboard-focused");
        errorItem.scrollIntoView({ behavior: "smooth", block: "nearest" });
        Logger.debug(`\uD3EC\uCEE4\uC2A4 \uD558\uC774\uB77C\uC774\uD2B8 \uC801\uC6A9 \uC131\uACF5: \uACE0\uC720 ID ${uniqueId}, \uC6D0\uBCF8 \uC778\uB371\uC2A4 ${actualIndex}, \uC808\uB300 \uC704\uCE58 ${pageCorrection.absolutePosition}`);
        Logger.debug(`\uD3EC\uCEE4\uC2A4\uB41C \uC694\uC18C \uC815\uBCF4:`, {
          tagName: errorItem.tagName,
          className: errorItem.className,
          textContent: ((_a = errorItem.textContent) == null ? void 0 : _a.substring(0, 50)) + "...",
          dataset: errorItem.dataset
        });
      } else {
        Logger.warn(`\uD3EC\uCEE4\uC2A4 \uB300\uC0C1 \uC694\uC18C\uB97C \uCC3E\uC744 \uC218 \uC5C6\uC74C: \uACE0\uC720 ID ${uniqueId}, \uC778\uB371\uC2A4 ${actualIndex}`);
        const allUniqueIdElements = this.element.querySelectorAll("[data-unique-id]");
        const allCorrectionIndexElements = this.element.querySelectorAll("[data-correction-index]");
        Logger.debug(
          `DOM \uB0B4 data-unique-id \uC18D\uC131 \uC694\uC18C ${allUniqueIdElements.length}\uAC1C:`,
          Array.from(allUniqueIdElements).map((el) => el.dataset.uniqueId)
        );
        Logger.debug(
          `DOM \uB0B4 data-correction-index \uC18D\uC131 \uC694\uC18C ${allCorrectionIndexElements.length}\uAC1C:`,
          Array.from(allCorrectionIndexElements).map((el) => el.dataset.correctionIndex)
        );
      }
    } else {
      Logger.debug("\uD3EC\uCEE4\uC2A4\uD560 \uC624\uB958\uAC00 \uC5C6\uAC70\uB098 \uC778\uB371\uC2A4\uAC00 \uBC94\uC704\uB97C \uBC97\uC5B4\uB0A8");
      Logger.debug(`\uC138\uBD80 \uC815\uBCF4: length=${this.currentCorrections.length}, index=${this.currentFocusIndex}, \uC778\uB371\uC2A4 \uBC94\uC704 \uB0B4? ${this.currentFocusIndex >= 0 && this.currentFocusIndex < this.currentCorrections.length}`);
    }
    Logger.debug("========= updateFocusHighlight \uC885\uB8CC =========");
  }
  /**
   * ÌéòÏù¥ÏßÄÎÑ§Ïù¥ÏÖòÏùÑ Ï¥àÍ∏∞ÌôîÌï©ÎãàÎã§.
   */
  initializePagination() {
    const trimmedText = this.config.selectedText.trim();
    const textLength = trimmedText.length;
    this.isLongText = textLength > 1e3;
    this.charsPerPage = 800;
    this.pageBreaks = [textLength];
    this.totalPreviewPages = 1;
    this.currentPreviewPage = 0;
    Logger.log(`Initial pagination setup: Long text: ${this.isLongText}, Trimmed length: ${textLength}`);
  }
  /**
   * ÌåùÏóÖÏùÑ Î†åÎçîÎßÅÌï©ÎãàÎã§.
   */
  render() {
    this.element.id = "correctionPopup";
    this.element.setAttribute("tabindex", "-1");
    this.createPopupStructure();
    this.bindEvents();
    this.app.keymap.pushScope(this.keyboardScope);
    setTimeout(() => {
      this.element.focus();
    }, 50);
    this.resetFocusToFirstError();
    this.showKeyboardHint();
    document.body.classList.add("spell-popup-open");
    return this.element;
  }
  /**
   * ÌåùÏóÖ DOM Íµ¨Ï°∞Î•º ÏÉùÏÑ±Ìï©ÎãàÎã§.
   */
  createPopupStructure() {
    this.element.empty();
    const overlay = this.element.createDiv("popup-overlay");
    const content = this.element.createDiv("popup-content");
    const header = content.createDiv("header");
    header.createEl("h2", { text: "\uD55C\uAD6D\uC5B4 \uB9DE\uCDA4\uBC95 \uAC80\uC0AC" });
    const headerTop = header.createDiv("preview-header-top");
    const aiBtn = headerTop.createEl("button", {
      cls: "ai-analyze-btn",
      attr: { id: "aiAnalyzeBtn" }
    });
    this.updateAiButtonState(aiBtn);
    headerTop.createEl("button", { cls: "close-btn-header", text: "\xD7" });
    const mainContent = content.createDiv("content");
    const previewSection = mainContent.createDiv("preview-section");
    const previewHeader = previewSection.createDiv("preview-header");
    const previewLabel = previewHeader.createDiv("preview-label");
    previewLabel.createSpan({ text: "\uBBF8\uB9AC\uBCF4\uAE30" });
    previewLabel.createSpan({ cls: "preview-hint", text: "\uD074\uB9AD\uD558\uC5EC \uC218\uC815\uC0AC\uD56D \uC801\uC6A9" });
    const colorLegend = previewHeader.createDiv("color-legend");
    const legendItems = [
      { cls: "error", text: "\uC624\uB958" },
      { cls: "corrected", text: "\uC218\uC815" },
      { cls: "exception-processed", text: "\uC608\uC678\uCC98\uB9AC" },
      { cls: "original-kept", text: "\uC6D0\uBCF8\uC720\uC9C0" },
      { cls: "user-edited", text: "\uD3B8\uC9D1\uB428" }
    ];
    legendItems.forEach((item) => {
      const legendItem = colorLegend.createDiv("color-legend-item");
      legendItem.createDiv(`color-legend-dot ${item.cls}`);
      legendItem.createSpan({ text: item.text });
    });
    const paginationDiv = previewHeader.createDiv();
    paginationDiv.innerHTML = this.createPaginationHTML();
    const previewContent = previewSection.createDiv("preview-text");
    previewContent.id = "resultPreview";
    previewContent.createEl("span", { text: this.config.selectedText.trim() });
    const errorSummary = mainContent.createDiv("error-summary collapsed");
    errorSummary.id = "errorSummary";
    const errorToggle = errorSummary.createDiv("error-summary-toggle");
    const leftSection = errorToggle.createDiv("left-section");
    leftSection.createSpan({ cls: "error-summary-label", text: "\uC624\uB958 \uC0C1\uC138" });
    const badge = leftSection.createSpan({
      cls: "error-count-badge",
      text: this.getErrorStateCount().toString(),
      attr: { id: "errorCountBadge" }
    });
    errorToggle.createSpan({ cls: "toggle-icon", text: "\u25BC" });
    const errorContent = errorSummary.createDiv("error-summary-content");
    errorContent.id = "errorSummaryContent";
    errorContent.innerHTML = this.generateErrorSummaryHTML();
    const buttonArea = content.createDiv("button-area");
    buttonArea.createEl("button", { cls: "cancel-btn", text: "\uCDE8\uC18C" });
    buttonArea.createEl("button", {
      cls: "apply-btn",
      text: "\uC801\uC6A9",
      attr: { id: "applyCorrectionsButton" }
    });
  }
  /**
   * ÌéòÏù¥ÏßÄÎÑ§Ïù¥ÏÖò HTMLÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§.
   */
  createPaginationHTML() {
    if (!this.isLongText || this.totalPreviewPages <= 1) {
      return '<div id="paginationContainer" class="pagination-container-hidden"></div>';
    }
    return `
      <div class="pagination-controls" id="paginationContainer">
        <button class="pagination-btn" id="prevPreviewPage" ${this.currentPreviewPage === 0 ? "disabled" : ""}>\uC774\uC804</button>
        <span class="page-info" id="previewPageInfo">${this.currentPreviewPage + 1} / ${this.totalPreviewPages}</span>
        <button class="pagination-btn" id="nextPreviewPage" ${this.currentPreviewPage === this.totalPreviewPages - 1 ? "disabled" : ""}>\uB2E4\uC74C</button>
        <span class="page-chars-info" id="pageCharsInfo">${this.charsPerPage}\uC790</span>
      </div>
    `;
  }
  /**
   * ÌòÑÏû¨ ÌéòÏù¥ÏßÄÏùò ÍµêÏ†ï Î™©Î°ùÏùÑ Í∞ÄÏ†∏ÏòµÎãàÎã§. (Ï†àÎåÄ ÏúÑÏπò Í∏∞Î∞ò Ï†ïÌôïÌïú ÏàúÏÑú)
   */
  getCurrentCorrections() {
    Logger.debug("========= getCurrentCorrections \uC2DC\uC791 =========");
    Logger.debug(`isLongText: ${this.isLongText}`);
    Logger.debug(`currentPreviewPage: ${this.currentPreviewPage}`);
    Logger.debug(`allErrorPositions \uAC1C\uC218: ${this.allErrorPositions.length}`);
    if (!this.isLongText) {
      const result = this.allErrorPositions.map((errorPos) => ({
        correction: errorPos.correction,
        originalIndex: errorPos.originalIndex,
        positionInPage: errorPos.absolutePosition,
        absolutePosition: errorPos.absolutePosition,
        uniqueId: errorPos.uniqueId
      }));
      Logger.debug(`\uC9E7\uC740 \uD14D\uC2A4\uD2B8 \uBAA8\uB4DC: \uC804\uCCB4 ${result.length}\uAC1C \uC624\uB958 \uBC18\uD658`);
      Logger.debug("\uBC18\uD658 \uC624\uB958 \uBAA9\uB85D:", result.map((pc) => ({
        original: pc.correction.original,
        originalIndex: pc.originalIndex,
        uniqueId: pc.uniqueId,
        absolutePosition: pc.absolutePosition
      })));
      Logger.debug("========= getCurrentCorrections \uC885\uB8CC (\uC9E7\uC740 \uD14D\uC2A4\uD2B8) =========");
      return result;
    }
    const previewStartIndex = this.currentPreviewPage === 0 ? 0 : this.pageBreaks[this.currentPreviewPage - 1];
    const previewEndIndex = this.pageBreaks[this.currentPreviewPage];
    Logger.debug(`\uD398\uC774\uC9C0 \uBC94\uC704: ${previewStartIndex} ~ ${previewEndIndex}`);
    const pageCorrections = [];
    this.allErrorPositions.forEach((errorPos, index) => {
      Logger.debug(`[${index}] \uC624\uB958 \uC704\uCE58 \uAC80\uC0AC: "${errorPos.correction.original}" at ${errorPos.absolutePosition} (\uACE0\uC720ID: ${errorPos.uniqueId})`);
      if (errorPos.absolutePosition >= previewStartIndex && errorPos.absolutePosition < previewEndIndex) {
        const pageCorrection = {
          correction: errorPos.correction,
          originalIndex: errorPos.originalIndex,
          positionInPage: errorPos.absolutePosition - previewStartIndex,
          absolutePosition: errorPos.absolutePosition,
          uniqueId: errorPos.uniqueId
        };
        pageCorrections.push(pageCorrection);
        Logger.debug(`[${index}] \uD398\uC774\uC9C0 \uBC94\uC704 \uB0B4 \uC624\uB958 \uCD94\uAC00: positionInPage=${pageCorrection.positionInPage}`);
      } else {
        Logger.debug(`[${index}] \uD398\uC774\uC9C0 \uBC94\uC704 \uBC16 \uC624\uB958 \uC81C\uC678`);
      }
    });
    pageCorrections.sort((a, b) => a.absolutePosition - b.absolutePosition);
    Logger.debug(`getCurrentCorrections: \uD398\uC774\uC9C0 ${this.currentPreviewPage + 1}, \uC624\uB958 ${pageCorrections.length}\uAC1C`);
    Logger.debug("\uCD5C\uC885 \uC624\uB958 \uC704\uCE58 \uC21C\uC11C:", pageCorrections.map((pc) => ({
      original: pc.correction.original,
      originalIndex: pc.originalIndex,
      positionInPage: pc.positionInPage,
      absolutePosition: pc.absolutePosition,
      uniqueId: pc.uniqueId
    })));
    Logger.debug("========= getCurrentCorrections \uC885\uB8CC (\uAE34 \uD14D\uC2A4\uD2B8) =========");
    return pageCorrections;
  }
  /**
   * Ï§ëÎ≥µÎêú ÍµêÏ†ï Ìï≠Î™©ÏùÑ Ï†úÍ±∞Ìï©ÎãàÎã§.
   * Í∞ôÏùÄ original ÌÖçÏä§Ìä∏Î•º Í∞ÄÏßÑ correctionsÎ•º Í∑∏Î£πÌôîÌïòÏó¨ ÎåÄÌëú Ìï≠Î™©Îßå ÏÑ†ÌÉùÌï©ÎãàÎã§.
   */
  removeDuplicateCorrections(corrections) {
    Logger.debug("========= removeDuplicateCorrections \uC2DC\uC791 =========");
    Logger.debug(`\uC785\uB825 corrections \uAC1C\uC218: ${corrections.length}`);
    Logger.debug("\uC785\uB825 corrections:", corrections.map((pc) => ({
      original: pc.correction.original,
      originalIndex: pc.originalIndex,
      uniqueId: pc.uniqueId,
      absolutePosition: pc.absolutePosition
    })));
    const uniqueMap = /* @__PURE__ */ new Map();
    const duplicateGroups = /* @__PURE__ */ new Map();
    corrections.forEach((correction, index) => {
      const originalText = correction.correction.original;
      const position = correction.absolutePosition;
      Logger.debug(`[${index}] \uADF8\uB8F9\uD654 \uC911: "${originalText}" (\uC704\uCE58: ${position}, \uACE0\uC720ID: ${correction.uniqueId})`);
      let groupKey = originalText;
      let foundOverlap = false;
      for (const [existingKey, existingGroup] of duplicateGroups) {
        if (existingGroup.length > 0) {
          const existingCorrection = existingGroup[0];
          const existingPos = existingCorrection.absolutePosition;
          const existingText = existingCorrection.correction.original;
          if (position === existingPos && (originalText.includes(existingText) || existingText.includes(originalText))) {
            groupKey = existingKey;
            foundOverlap = true;
            Logger.debug(`[${index}] \uC704\uCE58 \uAE30\uBC18 \uC911\uBCF5 \uBC1C\uACAC: "${originalText}" \u2194 "${existingText}" (\uC704\uCE58: ${position})`);
            break;
          }
        }
      }
      if (!duplicateGroups.has(groupKey)) {
        duplicateGroups.set(groupKey, []);
        Logger.debug(`[${index}] \uC0C8\uB85C\uC6B4 \uADF8\uB8F9 \uC0DD\uC131: "${groupKey}"`);
      }
      duplicateGroups.get(groupKey).push(correction);
      Logger.debug(`[${index}] \uADF8\uB8F9 \uCD94\uAC00 \uC644\uB8CC. \uD604\uC7AC "${groupKey}" \uADF8\uB8F9 \uD06C\uAE30: ${duplicateGroups.get(groupKey).length}`);
    });
    Logger.debug(`\uADF8\uB8F9\uD654 \uC644\uB8CC. \uCD1D ${duplicateGroups.size}\uAC1C \uADF8\uB8F9 \uC0DD\uC131`);
    duplicateGroups.forEach((group, originalText) => {
      Logger.debug(`\uCC98\uB9AC \uC911\uC778 \uADF8\uB8F9: "${originalText}", \uADF8\uB8F9 \uD06C\uAE30: ${group.length}`);
      Logger.debug(`\uADF8\uB8F9 \uB0B4 \uD56D\uBAA9\uB4E4:`, group.map((pc) => ({
        originalIndex: pc.originalIndex,
        uniqueId: pc.uniqueId,
        absolutePosition: pc.absolutePosition
      })));
      if (group.length === 1) {
        uniqueMap.set(originalText, group[0]);
        Logger.debug(`[\uB2E8\uC77C \uD56D\uBAA9] "${originalText}" \u2192 \uB300\uD45C \uD56D\uBAA9: ${group[0].uniqueId}`);
      } else {
        const representative = this.selectRepresentativeCorrection(group);
        uniqueMap.set(originalText, representative);
        Logger.debug(`[\uC911\uBCF5 \uD56D\uBAA9] "${originalText}", ${group.length}\uAC1C \uD56D\uBAA9 \u2192 \uB300\uD45C \uD56D\uBAA9 \uC120\uD0DD (uniqueId: ${representative.uniqueId}, originalIndex: ${representative.originalIndex})`);
        Logger.debug(`\uC81C\uC678\uB41C \uD56D\uBAA9\uB4E4:`, group.filter((pc) => pc.uniqueId !== representative.uniqueId).map((pc) => ({
          uniqueId: pc.uniqueId,
          originalIndex: pc.originalIndex,
          absolutePosition: pc.absolutePosition
        })));
      }
    });
    Logger.debug(`\uB300\uD45C \uD56D\uBAA9 \uC120\uD0DD \uC644\uB8CC. uniqueMap \uD06C\uAE30: ${uniqueMap.size}`);
    const result = Array.from(uniqueMap.values()).sort((a, b) => a.absolutePosition - b.absolutePosition);
    Logger.debug(`\uC911\uBCF5 \uC81C\uAC70 \uACB0\uACFC: ${corrections.length}\uAC1C \u2192 ${result.length}\uAC1C`);
    Logger.debug("\uCD5C\uC885 \uC911\uBCF5 \uC81C\uAC70 \uD6C4 \uD56D\uBAA9\uB4E4:", result.map((pc) => ({
      original: pc.correction.original,
      originalIndex: pc.originalIndex,
      uniqueId: pc.uniqueId,
      absolutePosition: pc.absolutePosition
    })));
    Logger.debug("========= removeDuplicateCorrections \uC885\uB8CC =========");
    return result;
  }
  /**
   * Ï§ëÎ≥µÎêú ÍµêÏ†ï Ìï≠Î™©Îì§ Ï§ëÏóêÏÑú ÎåÄÌëú Ìï≠Î™©ÏùÑ ÏÑ†ÌÉùÌï©ÎãàÎã§.
   * ÏÑ†ÌÉù Í∏∞Ï§Ä:
   * 1. Í∞ÄÏû• ÏïûÏóê ÏúÑÏπòÌïú Ìï≠Î™© (absolutePositionÏù¥ Í∞ÄÏû• ÏûëÏùÄ Ìï≠Î™©)
   * 2. ÎèôÏùºÌïú ÏúÑÏπòÏù∏ Í≤ΩÏö∞ Í∞ÄÏû• ÎßéÏùÄ ÏàòÏ†ï Ï†úÏïàÏùÑ Í∞ÄÏßÑ Ìï≠Î™©
   * 3. ÏàòÏ†ï Ï†úÏïàÏù¥ Í∞ôÏùÄ Í≤ΩÏö∞ Îçî Ï¢ãÏùÄ ÎèÑÏõÄÎßêÏùÑ Í∞ÄÏßÑ Ìï≠Î™© (Î¨∏Î≤ï > ÎßûÏ∂§Î≤ï > ÎùÑÏñ¥Ïì∞Í∏∞)
   * 4. Í∑∏ Ïô∏ÏóêÎäî Ï≤´ Î≤àÏß∏ Ìï≠Î™©
   */
  selectRepresentativeCorrection(corrections) {
    if (corrections.length === 0) {
      throw new Error("\uBE48 \uAD50\uC815 \uBC30\uC5F4\uC5D0\uC11C\uB294 \uB300\uD45C \uD56D\uBAA9\uC744 \uC120\uD0DD\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4");
    }
    if (corrections.length === 1) {
      return corrections[0];
    }
    const minPosition = Math.min(...corrections.map((c) => c.absolutePosition));
    const frontmostCorrections = corrections.filter((c) => c.absolutePosition === minPosition);
    if (frontmostCorrections.length === 1) {
      Logger.debug(`\uB300\uD45C \uD56D\uBAA9 \uC120\uD0DD: \uAC00\uC7A5 \uC55E \uC704\uCE58 \uAE30\uC900 (\uC704\uCE58: ${minPosition})`);
      return frontmostCorrections[0];
    }
    const maxSuggestions = Math.max(...frontmostCorrections.map((c) => c.correction.corrected.length));
    const bestSuggestionCorrections = frontmostCorrections.filter((c) => c.correction.corrected.length === maxSuggestions);
    if (bestSuggestionCorrections.length === 1) {
      Logger.debug(`\uB300\uD45C \uD56D\uBAA9 \uC120\uD0DD: \uC218\uC815 \uC81C\uC548 \uC218 \uAE30\uC900 (\uC81C\uC548 \uC218: ${maxSuggestions})`);
      return bestSuggestionCorrections[0];
    }
    const helpPriority = (help) => {
      const helpLower = help.toLowerCase();
      if (helpLower.includes("\uBB38\uBC95"))
        return 3;
      if (helpLower.includes("\uB9DE\uCDA4\uBC95"))
        return 2;
      if (helpLower.includes("\uB744\uC5B4\uC4F0\uAE30"))
        return 1;
      return 0;
    };
    const maxHelpPriority = Math.max(...bestSuggestionCorrections.map((c) => helpPriority(c.correction.help)));
    const bestHelpCorrections = bestSuggestionCorrections.filter((c) => helpPriority(c.correction.help) === maxHelpPriority);
    if (bestHelpCorrections.length === 1) {
      Logger.debug(`\uB300\uD45C \uD56D\uBAA9 \uC120\uD0DD: \uB3C4\uC6C0\uB9D0 \uC6B0\uC120\uC21C\uC704 \uAE30\uC900 (\uC6B0\uC120\uC21C\uC704: ${maxHelpPriority})`);
      return bestHelpCorrections[0];
    }
    Logger.debug(`\uB300\uD45C \uD56D\uBAA9 \uC120\uD0DD: \uCCAB \uBC88\uC9F8 \uD56D\uBAA9 \uAE30\uBCF8 \uC120\uD0DD`);
    return bestHelpCorrections[0];
  }
  /**
   * Ï†ÑÏ≤¥ ÌÖçÏä§Ìä∏ÏóêÏÑú Î™®Îì† Ïò§Î•òÏùò ÏúÑÏπòÎ•º Í≥ÑÏÇ∞Ìï©ÎãàÎã§.
   */
  calculateAllErrorPositions() {
    this.allErrorPositions = [];
    this.config.corrections.forEach((correction, originalIndex) => {
      let searchPos = 0;
      let occurrenceCount = 0;
      while (true) {
        const foundPos = this.config.selectedText.indexOf(correction.original, searchPos);
        if (foundPos === -1)
          break;
        const endPos = foundPos + correction.original.length;
        if (this.config.selectedText.slice(foundPos, endPos) === correction.original) {
          this.allErrorPositions.push({
            correction,
            originalIndex,
            absolutePosition: foundPos,
            uniqueId: `${originalIndex}_${occurrenceCount}`
          });
          occurrenceCount++;
        }
        searchPos = foundPos + 1;
      }
    });
    this.allErrorPositions.sort((a, b) => a.absolutePosition - b.absolutePosition);
    Logger.debug("\uC804\uCCB4 \uC624\uB958 \uC704\uCE58 \uACC4\uC0B0 \uC644\uB8CC:", {
      totalErrors: this.allErrorPositions.length,
      positions: this.allErrorPositions.map((ep) => ({
        original: ep.correction.original,
        originalIndex: ep.originalIndex,
        absolutePosition: ep.absolutePosition,
        uniqueId: ep.uniqueId
      }))
    });
  }
  /**
   * ÌòÑÏû¨ ÌéòÏù¥ÏßÄÏóêÏÑú Ïò§Î•ò ÏÉÅÌÉú(Îπ®Í∞ÑÏÉâ)Ïù∏ Ìï≠Î™©Ïùò Í∞úÏàòÎ•º Í∞ÄÏ†∏ÏòµÎãàÎã§.
   */
  getErrorStateCount() {
    const currentCorrections = this.getCurrentCorrections();
    const uniqueCorrections = this.removeDuplicateCorrections(currentCorrections);
    let errorCount = 0;
    uniqueCorrections.forEach((pageCorrection) => {
      const actualIndex = pageCorrection.originalIndex;
      const correction = pageCorrection.correction;
      const currentValue = this.stateManager.getValue(actualIndex);
      const isException = this.stateManager.isExceptionState(actualIndex);
      const isOriginalKept = this.stateManager.isOriginalKeptState(actualIndex);
      if (currentValue === correction.original && !isException && !isOriginalKept) {
        errorCount++;
      }
    });
    return errorCount;
  }
  /**
   * ÎØ∏Î¶¨Î≥¥Í∏∞ ÏΩòÌÖêÏ∏†Î•º ÏóÖÎç∞Ïù¥Ìä∏Ìï©ÎãàÎã§ (DOM API ÏÇ¨Ïö©).
   */
  updatePreviewContent(previewElement) {
    previewElement.innerHTML = this.generatePreviewHTML();
  }
  /**
   * ÎØ∏Î¶¨Î≥¥Í∏∞ HTMLÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§.
   */
  generatePreviewHTML() {
    const previewText = this.isLongText ? this.getCurrentPreviewText() : this.config.selectedText.trim();
    const rawCorrections = this.getCurrentCorrections();
    const currentCorrections = this.removeDuplicateCorrections(rawCorrections);
    const originalText = this.config.selectedText;
    const trimmedStartOffset = originalText.length - originalText.trimStart().length;
    Logger.debug("generatePreviewHTML \uB514\uBC84\uAE45:", {
      isLongText: this.isLongText,
      originalLength: originalText.length,
      trimmedLength: previewText.length,
      trimmedStartOffset,
      startsWithSpace: previewText.startsWith(" "),
      endsWithSpace: previewText.endsWith(" "),
      firstChars: previewText.substring(0, 20),
      lastChars: previewText.substring(previewText.length - 20),
      correctionsCount: currentCorrections.length
    });
    const processedPositions = /* @__PURE__ */ new Map();
    const segments = [];
    currentCorrections.forEach((pageCorrection) => {
      const correction = pageCorrection.correction;
      const actualIndex = pageCorrection.originalIndex;
      const uniqueId = pageCorrection.uniqueId;
      const positionInPage = pageCorrection.positionInPage;
      const displayClass = this.stateManager.getDisplayClass(actualIndex);
      const currentValue = this.stateManager.getValue(actualIndex);
      const escapedValue = escapeHtml(currentValue);
      const isUserEdited = this.stateManager.isUserEditedState(actualIndex);
      if (isUserEdited) {
        Logger.debug(`\u{1F3A8} \uBBF8\uB9AC\uBCF4\uAE30 \uC0AC\uC6A9\uC790\uD3B8\uC9D1: index=${actualIndex}, original="${correction.original}", currentValue="${currentValue}", displayClass="${displayClass}"`);
      }
      const replacementHtml = `<span class="${displayClass} clickable-error" data-correction-index="${actualIndex}" data-unique-id="${uniqueId}">${escapedValue}</span>`;
      const expectedText = correction.original;
      const expectedEnd = positionInPage + expectedText.length;
      if (positionInPage >= 0 && expectedEnd <= previewText.length) {
        const actualText = previewText.slice(positionInPage, expectedEnd);
        if (actualText === expectedText) {
          const positionKey = `${positionInPage}-${expectedEnd}`;
          if (!processedPositions.has(positionKey)) {
            processedPositions.set(positionKey, true);
            segments.push({
              text: actualText,
              html: replacementHtml,
              start: positionInPage,
              end: expectedEnd
            });
            Logger.debug(`\uBBF8\uB9AC\uBCF4\uAE30 \uC624\uB958 \uCC98\uB9AC: ${actualText} at ${positionInPage}-${expectedEnd}, \uACE0\uC720 ID: ${uniqueId}`);
          }
        } else {
          Logger.warn(`\uD14D\uC2A4\uD2B8 \uBD88\uC77C\uCE58: \uC608\uC0C1 "${expectedText}", \uC2E4\uC81C "${actualText}" at ${positionInPage}-${expectedEnd}`);
        }
      } else {
        Logger.warn(`\uC704\uCE58 \uBC94\uC704 \uCD08\uACFC: ${positionInPage}-${expectedEnd}, \uD14D\uC2A4\uD2B8 \uAE38\uC774: ${previewText.length}`);
      }
    });
    segments.sort((a, b) => a.start - b.start);
    let finalHtml = "";
    let currentPos = 0;
    segments.forEach((segment) => {
      if (segment.start > currentPos) {
        const betweenText = previewText.substring(currentPos, segment.start);
        const cleanedBetweenText = currentPos === 0 ? betweenText.trimStart() : betweenText;
        finalHtml += escapeHtml(cleanedBetweenText);
      }
      if (segment.start >= currentPos) {
        finalHtml += segment.html;
        currentPos = segment.end;
      }
    });
    if (currentPos < previewText.length) {
      const remainingText = previewText.substring(currentPos);
      const cleanedRemainingText = currentPos === 0 ? remainingText.trimStart() : remainingText;
      finalHtml += escapeHtml(cleanedRemainingText);
    }
    return finalHtml;
  }
  /**
   * ÌòÑÏû¨ ÌéòÏù¥ÏßÄÏùò ÎØ∏Î¶¨Î≥¥Í∏∞ ÌÖçÏä§Ìä∏Î•º Í∞ÄÏ†∏ÏòµÎãàÎã§.
   */
  getCurrentPreviewText() {
    if (!this.isLongText)
      return this.config.selectedText.trim();
    const previewStartIndex = this.currentPreviewPage === 0 ? 0 : this.pageBreaks[this.currentPreviewPage - 1];
    const previewEndIndex = this.pageBreaks[this.currentPreviewPage];
    const pageText = this.config.selectedText.slice(previewStartIndex, previewEndIndex);
    const cleanedPageText = pageText.trim();
    Logger.debug("getCurrentPreviewText \uB514\uBC84\uAE45:", {
      currentPage: this.currentPreviewPage,
      startIndex: previewStartIndex,
      endIndex: previewEndIndex,
      originalLength: pageText.length,
      cleanedLength: cleanedPageText.length,
      startsWithSpace: pageText.startsWith(" "),
      endsWithSpace: pageText.endsWith(" "),
      firstChars: pageText.substring(0, 20),
      cleanedFirstChars: cleanedPageText.substring(0, 20)
    });
    return cleanedPageText;
  }
  /**
   * Ïò§Î•ò ÏöîÏïΩ HTMLÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§.
   */
  generateErrorSummaryHTML() {
    Logger.debug(`\u{1F3D7}\uFE0F generateErrorSummaryHTML \uC2DC\uC791`);
    const rawCorrections = this.getCurrentCorrections();
    const currentCorrections = this.removeDuplicateCorrections(rawCorrections);
    Logger.debug(`\u{1F3D7}\uFE0F rawCorrections: ${rawCorrections.length}, currentCorrections: ${currentCorrections.length}`);
    if (currentCorrections.length === 0) {
      Logger.debug(`\u{1F3D7}\uFE0F \uC624\uB958 \uC5C6\uC74C - \uD50C\uB808\uC774\uC2A4\uD640\uB354 \uBC18\uD658`);
      return `
        <div class="error-placeholder">
          <div class="placeholder-icon">\u2713</div>
          <div class="placeholder-text">\uC774 \uD398\uC774\uC9C0\uC5D0\uB294 \uBC1C\uACAC\uB41C \uC624\uB958\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4</div>
          <div class="placeholder-subtext">\uB2E4\uB978 \uD398\uC774\uC9C0\uC5D0\uC11C \uC624\uB958\uB97C \uD655\uC778\uD558\uC138\uC694</div>
        </div>
      `;
    }
    const uniqueCorrections = this.removeDuplicateCorrections(currentCorrections);
    Logger.debug(`\u{1F3D7}\uFE0F uniqueCorrections: ${uniqueCorrections.length}`);
    return uniqueCorrections.map((pageCorrection, index) => {
      const actualIndex = pageCorrection.originalIndex;
      const correction = pageCorrection.correction;
      const isOriginalKept = this.stateManager.isOriginalKeptState(actualIndex);
      const isUserEdited = this.stateManager.isUserEditedState(actualIndex);
      const suggestions = correction.corrected.slice(0, 3);
      Logger.debug(`\u{1F3D7}\uFE0F HTML \uC0DD\uC131: "${correction.original}" \u2192 actualIndex=${actualIndex}, pageIndex=${index}`);
      const aiResult = this.aiAnalysisResults.find((result) => result.correctionIndex === actualIndex);
      const reasoningHTML = aiResult ? `<div class="ai-analysis-result">
             <div class="ai-confidence">\u{1F916} \uC2E0\uB8B0\uB3C4: <span class="confidence-score">${aiResult.confidence}%</span></div>
             <div class="ai-reasoning">${escapeHtml(aiResult.reasoning)}</div>
           </div>` : isOriginalKept ? `<div class="ai-analysis-result">
             <div class="ai-reasoning">\uC0AC\uC6A9\uC790\uAC00 \uC9C1\uC811 \uC120\uD0DD\uD588\uAC70\uB098, \uC608\uC678 \uB2E8\uC5B4\uB85C \uB4F1\uB85D\uB41C \uD56D\uBAA9\uC785\uB2C8\uB2E4.</div>
           </div>` : "";
      const suggestionsHTML = suggestions.map(
        (suggestion) => `<span class="suggestion-compact ${this.stateManager.isSelected(actualIndex, suggestion) ? "selected" : ""}" 
              data-value="${escapeHtml(suggestion)}" 
              data-correction="${actualIndex}"
              ${isOriginalKept ? "disabled" : ""}>
          ${escapeHtml(suggestion)}
        </span>`
      ).join("");
      const stateClass = isUserEdited ? "user-edited" : isOriginalKept ? "original-kept" : this.stateManager.isExceptionState(actualIndex) ? "exception-processed" : this.stateManager.getValue(actualIndex) !== correction.original ? "corrected" : "";
      const htmlString = `
        <div class="error-item-compact ${isOriginalKept ? "spell-original-kept" : ""}" data-correction-index="${actualIndex}">
          <div class="error-row">
            <div class="error-original-compact ${stateClass}" data-correction-index="${actualIndex}">${escapeHtml(this.stateManager.getValue(actualIndex))}</div>
            <div class="error-suggestions-compact">
              ${suggestionsHTML}
              <span class="suggestion-compact ${this.stateManager.isSelected(actualIndex, correction.original) ? "selected" : ""} keep-original" 
                    data-value="${escapeHtml(correction.original)}" 
                    data-correction="${actualIndex}"
                    ${isOriginalKept ? "disabled" : ""}>
                \uC608\uC678\uCC98\uB9AC
              </span>
            </div>
          </div>
          <div class="error-help-compact">${escapeHtml(correction.help)}</div>
          ${reasoningHTML}
        </div>
      `;
      Logger.debug(`\u{1F3D7}\uFE0F HTML \uCCAB \uBD80\uBD84 - actualIndex=${actualIndex}: ${htmlString.substring(0, 200)}...`);
      return htmlString;
    }).join("");
  }
  /**
   * Ïù¥Î≤§Ìä∏Î•º Î∞îÏù∏Îî©Ìï©ÎãàÎã§.
   */
  bindEvents() {
    const cmdEHandler = this.app.scope.register(["Mod"], "KeyE", (evt) => {
      if (this.isInEditMode()) {
        return true;
      }
      evt.preventDefault();
      evt.stopPropagation();
      this.enterEditModeForFocusedError();
      return false;
    });
    const cmdShiftEHandler = this.app.scope.register(["Mod", "Shift"], "KeyE", (evt) => {
      evt.preventDefault();
      evt.stopPropagation();
      this.toggleErrorSummary();
      return false;
    });
    this.cleanupFunctions.push(() => this.app.scope.unregister(cmdEHandler));
    this.cleanupFunctions.push(() => this.app.scope.unregister(cmdShiftEHandler));
    const documentKeyListener = (evt) => {
      if (evt.code === "KeyE" && (evt.metaKey && !evt.ctrlKey || !evt.metaKey && evt.ctrlKey) && !evt.shiftKey) {
        if (this.isInEditMode()) {
          return;
        }
        evt.preventDefault();
        evt.stopPropagation();
        this.enterEditModeForFocusedError();
        return;
      }
      if (evt.code === "KeyE" && (evt.metaKey && !evt.ctrlKey || !evt.metaKey && evt.ctrlKey) && evt.shiftKey) {
        evt.preventDefault();
        evt.stopPropagation();
        this.toggleErrorSummary();
        return;
      }
    };
    document.addEventListener("keydown", documentKeyListener);
    this.cleanupFunctions.push(() => document.removeEventListener("keydown", documentKeyListener));
    this.addEventListener(this.element, "keydown", (evt) => {
      if (evt.code === "KeyA" && evt.shiftKey && evt.metaKey && !evt.ctrlKey) {
        evt.preventDefault();
        evt.stopPropagation();
        this.triggerAIAnalysis();
        return;
      }
      if (evt.code === "KeyE" && (evt.metaKey && !evt.ctrlKey || !evt.metaKey && evt.ctrlKey) && !evt.shiftKey) {
        if (this.isInEditMode()) {
          return;
        }
        evt.preventDefault();
        evt.stopPropagation();
        this.enterEditModeForFocusedError();
        return;
      }
      if (evt.code === "KeyE" && (evt.metaKey && !evt.ctrlKey || !evt.metaKey && evt.ctrlKey) && evt.shiftKey) {
        evt.preventDefault();
        evt.stopPropagation();
        this.toggleErrorSummary();
        return;
      }
    });
    this.bindCloseEvents();
    const overlay = this.element.querySelector(".popup-overlay");
    if (overlay) {
      this.addEventListener(overlay, "click", () => {
        this.close();
      });
    }
    this.bindPaginationEvents();
    this.bindErrorToggleEvents();
    this.bindCorrectionEvents();
    this.bindApplyEvents();
    this.bindAIAnalysisEvents();
  }
  /**
   * Îã´Í∏∞ Ïù¥Î≤§Ìä∏Î•º Î∞îÏù∏Îî©Ìï©ÎãàÎã§.
   */
  bindCloseEvents() {
    const closeButtons = this.element.querySelectorAll(".close-btn-header, .cancel-btn");
    closeButtons.forEach((button) => {
      this.addEventListener(button, "click", () => {
        this.close();
      });
    });
    const escKeyHandler = (e) => {
      if (e.key === "Escape") {
        this.close();
      }
    };
    document.addEventListener("keydown", escKeyHandler);
    this.cleanupFunctions.push(() => document.removeEventListener("keydown", escKeyHandler));
  }
  /**
   * ÌéòÏù¥ÏßÄÎÑ§Ïù¥ÏÖò Ïù¥Î≤§Ìä∏Î•º Î∞îÏù∏Îî©Ìï©ÎãàÎã§.
   */
  bindPaginationEvents() {
    const prevButton = this.element.querySelector("#prevPreviewPage");
    const nextButton = this.element.querySelector("#nextPreviewPage");
    if (prevButton) {
      this.addEventListener(prevButton, "click", () => {
        if (this.currentPreviewPage > 0) {
          this.currentPreviewPage--;
          this.updateDisplay();
        }
      });
    }
    if (nextButton) {
      this.addEventListener(nextButton, "click", () => {
        if (this.currentPreviewPage < this.totalPreviewPages - 1) {
          this.currentPreviewPage++;
          this.updateDisplay();
        }
      });
    }
  }
  /**
   * Ïò§Î•ò ÌÜ†Í∏Ä Ïù¥Î≤§Ìä∏Î•º Î∞îÏù∏Îî©Ìï©ÎãàÎã§.
   */
  bindErrorToggleEvents() {
    const toggleElement = this.element.querySelector(".error-summary-toggle");
    if (toggleElement) {
      this.addEventListener(toggleElement, "click", () => {
        const errorSummary = this.element.querySelector("#errorSummary");
        if (errorSummary) {
          errorSummary.classList.toggle("collapsed");
          setTimeout(() => {
            this.recalculatePagination();
            this.updateDisplay();
          }, 350);
        }
      });
    }
  }
  /**
   * ÍµêÏ†ï ÌÅ¥Î¶≠ Ïù¥Î≤§Ìä∏Î•º Î∞îÏù∏Îî©Ìï©ÎãàÎã§.
   */
  bindCorrectionEvents() {
    this.addEventListener(this.element, "click", (e) => {
      const target = e.target;
      Logger.debug(`\u{1F5B1}\uFE0F \uD074\uB9AD \uC774\uBCA4\uD2B8 \uBC1C\uC0DD: target="${target.tagName}.${target.className}", textContent="${target.textContent}"`);
      if (target.classList.contains("clickable-error")) {
        Logger.debug(`\u{1F5B1}\uFE0F \uBBF8\uB9AC\uBCF4\uAE30 \uD074\uB9AD \uCC98\uB9AC: ${target.textContent}`);
        this.handlePreviewClick(target);
      }
      if (target.classList.contains("error-original-compact")) {
        Logger.debug(`\u{1F5B1}\uFE0F \uC624\uB958 \uCE74\uB4DC \uD14D\uC2A4\uD2B8 \uD074\uB9AD \uAC10\uC9C0: ${target.textContent}`);
        this.handleCardTextClick(target);
      }
      if (target.classList.contains("suggestion-compact")) {
        this.handleSuggestionClick(target);
      }
    });
    this.addEventListener(this.element, "contextmenu", (e) => {
      const target = e.target;
      if (target.classList.contains("clickable-error")) {
        e.preventDefault();
        Logger.debug(`\u{1F5B1}\uFE0F \uBBF8\uB9AC\uBCF4\uAE30 \uC6B0\uD074\uB9AD \uD3B8\uC9D1 \uBAA8\uB4DC: ${target.textContent}`);
        this.handlePreviewRightClick(target);
      }
    });
    this.bindTouchHoldEvents();
  }
  /**
   * Î™®Î∞îÏùºÏö© ÌÑ∞ÏπòÌôÄÎìú Ïù¥Î≤§Ìä∏Î•º Î∞îÏù∏Îî©Ìï©ÎãàÎã§.
   */
  bindTouchHoldEvents() {
    if (!import_obsidian2.Platform.isMobile) {
      Logger.debug("\uB370\uC2A4\uD06C\uD1B1 \uD658\uACBD\uC5D0\uC11C\uB294 \uD130\uCE58\uD640\uB4DC \uC774\uBCA4\uD2B8\uB97C \uB4F1\uB85D\uD558\uC9C0 \uC54A\uC74C");
      return;
    }
    let touchTimer = null;
    let touchTarget = null;
    const TOUCH_HOLD_DURATION = 500;
    this.addEventListener(this.element, "touchstart", (e) => {
      const target = e.target;
      if (target.classList.contains("clickable-error") || target.classList.contains("error-original-compact")) {
        touchTarget = target;
        touchTimer = setTimeout(() => {
          if (touchTarget) {
            Logger.log(`\u{1F4F1} \uD130\uCE58\uD640\uB4DC \uD3B8\uC9D1 \uBAA8\uB4DC \uC9C4\uC785: ${touchTarget.textContent}`);
            if ("vibrate" in navigator) {
              navigator.vibrate(50);
            }
            let editingStarted = false;
            if (touchTarget.classList.contains("clickable-error")) {
              editingStarted = this.handlePreviewRightClick(touchTarget);
            } else if (touchTarget.classList.contains("error-original-compact")) {
              editingStarted = this.handleCardTextClick(touchTarget);
            }
            if (editingStarted) {
              this.enterMobileEditingMode();
            }
            touchTarget = null;
            touchTimer = null;
          }
        }, TOUCH_HOLD_DURATION);
        Logger.debug(`\u{1F4F1} \uD130\uCE58\uD640\uB4DC \uD0C0\uC774\uBA38 \uC2DC\uC791: ${target.textContent}`);
      }
    });
    this.addEventListener(this.element, "touchend", () => {
      if (touchTimer) {
        clearTimeout(touchTimer);
        touchTimer = null;
        Logger.debug("\u{1F4F1} \uD130\uCE58\uD640\uB4DC \uD0C0\uC774\uBA38 \uCDE8\uC18C (touchend)");
      }
      touchTarget = null;
    });
    this.addEventListener(this.element, "touchcancel", () => {
      if (touchTimer) {
        clearTimeout(touchTimer);
        touchTimer = null;
        Logger.debug("\u{1F4F1} \uD130\uCE58\uD640\uB4DC \uD0C0\uC774\uBA38 \uCDE8\uC18C (touchcancel)");
      }
      touchTarget = null;
    });
    this.addEventListener(this.element, "touchmove", (e) => {
      if (touchTimer && touchTarget) {
        const touch = e.touches[0];
        const rect = touchTarget.getBoundingClientRect();
        const moveThreshold = 10;
        const distanceX = Math.abs(touch.clientX - (rect.left + rect.width / 2));
        const distanceY = Math.abs(touch.clientY - (rect.top + rect.height / 2));
        if (distanceX > moveThreshold || distanceY > moveThreshold) {
          clearTimeout(touchTimer);
          touchTimer = null;
          touchTarget = null;
          Logger.debug("\u{1F4F1} \uD130\uCE58\uD640\uB4DC \uD0C0\uC774\uBA38 \uCDE8\uC18C (\uC774\uB3D9 \uAC10\uC9C0)");
        }
      }
    });
    Logger.log("\u{1F4F1} \uBAA8\uBC14\uC77C \uD130\uCE58\uD640\uB4DC \uC774\uBCA4\uD2B8 \uB4F1\uB85D \uC644\uB8CC");
  }
  /**
   * Ï†ÅÏö© Î≤ÑÌäº Ïù¥Î≤§Ìä∏Î•º Î∞îÏù∏Îî©Ìï©ÎãàÎã§.
   */
  bindApplyEvents() {
    const applyButton = this.element.querySelector("#applyCorrectionsButton");
    if (applyButton) {
      this.addEventListener(applyButton, "click", async () => {
        await this.applyCorrections();
      });
    }
  }
  /**
   * AI Î∂ÑÏÑù Î≤ÑÌäº ÏÉÅÌÉúÎ•º ÏóÖÎç∞Ïù¥Ìä∏Ìï©ÎãàÎã§.
   */
  async updateAiButtonState(aiBtn) {
    try {
      if (this.isAiAnalyzing) {
        aiBtn.textContent = "\u{1F916} \uBD84\uC11D \uC911...";
        aiBtn.disabled = true;
        aiBtn.classList.remove("ai-disabled");
        aiBtn.title = "AI \uBD84\uC11D\uC774 \uC9C4\uD589 \uC911\uC785\uB2C8\uB2E4...";
      } else if (this.aiService && await this.aiService.isAvailable()) {
        aiBtn.textContent = "\u{1F916} AI \uBD84\uC11D";
        aiBtn.disabled = false;
        aiBtn.classList.remove("ai-disabled");
        aiBtn.title = "AI\uAC00 \uCD5C\uC801\uC758 \uC218\uC815\uC0AC\uD56D\uC744 \uC790\uB3D9\uC73C\uB85C \uC120\uD0DD\uD569\uB2C8\uB2E4 (Shift+Cmd+A)";
      } else {
        aiBtn.textContent = "\u{1F916} AI \uBBF8\uC124\uC815";
        aiBtn.disabled = true;
        aiBtn.classList.add("ai-disabled");
        if (!this.aiService) {
          aiBtn.title = "AI \uC11C\uBE44\uC2A4\uB97C \uCD08\uAE30\uD654\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4. \uD50C\uB7EC\uADF8\uC778\uC744 \uB2E4\uC2DC \uB85C\uB4DC\uD574\uBCF4\uC138\uC694.";
        } else {
          const providerInfo = this.aiService.getProviderInfo();
          if (!providerInfo.available) {
            aiBtn.title = `AI \uAE30\uB2A5\uC774 \uBE44\uD65C\uC131\uD654\uB418\uC5C8\uC2B5\uB2C8\uB2E4. \uC124\uC815\uC5D0\uC11C ${providerInfo.provider} API \uD0A4\uB97C \uC785\uB825\uD558\uACE0 AI \uAE30\uB2A5\uC744 \uD65C\uC131\uD654\uD558\uC138\uC694.`;
          } else {
            aiBtn.title = "AI \uC11C\uBE44\uC2A4\uB97C \uC0AC\uC6A9\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4. \uC124\uC815\uC744 \uD655\uC778\uD574\uC8FC\uC138\uC694.";
          }
        }
      }
    } catch (error) {
      Logger.error("AI \uBC84\uD2BC \uC0C1\uD0DC \uC5C5\uB370\uC774\uD2B8 \uC2E4\uD328:", error);
      aiBtn.textContent = "\u{1F916} AI \uC624\uB958";
      aiBtn.disabled = true;
      aiBtn.classList.add("ai-disabled");
      aiBtn.title = "AI \uC11C\uBE44\uC2A4 \uC0C1\uD0DC \uD655\uC778 \uC911 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4.";
    }
  }
  /**
   * AI Î∂ÑÏÑù Î≤ÑÌäº Ïù¥Î≤§Ìä∏Î•º Î∞îÏù∏Îî©Ìï©ÎãàÎã§.
   */
  bindAIAnalysisEvents() {
    const aiAnalyzeBtn = this.element.querySelector("#aiAnalyzeBtn");
    if (aiAnalyzeBtn && this.aiService) {
      this.addEventListener(aiAnalyzeBtn, "click", async () => {
        await this.performAIAnalysis();
      });
    }
  }
  /**
   * ÎØ∏Î¶¨Î≥¥Í∏∞ ÌÅ¥Î¶≠ÏùÑ Ï≤òÎ¶¨Ìï©ÎãàÎã§.
   */
  handlePreviewClick(target) {
    const correctionIndex = parseInt(target.dataset.correctionIndex || "-1");
    if (correctionIndex >= 0 && correctionIndex < this.config.corrections.length) {
      this.stateManager.toggleState(correctionIndex);
      this.updateDisplay();
    }
  }
  /**
   * Ï†úÏïà Î≤ÑÌäº ÌÅ¥Î¶≠ÏùÑ Ï≤òÎ¶¨Ìï©ÎãàÎã§.
   */
  handleSuggestionClick(target) {
    var _a;
    const correctionIndex = parseInt(target.dataset.correction || "0");
    const value = target.dataset.value || "";
    this.stateManager.setState(correctionIndex, value, value === ((_a = this.config.corrections[correctionIndex]) == null ? void 0 : _a.original), false);
    this.updateDisplay();
  }
  /**
   * ÌòÑÏû¨ Ìé∏Ïßë Î™®ÎìúÏù∏ÏßÄ ÌôïÏù∏Ìï©ÎãàÎã§.
   */
  isInEditMode() {
    const editingInput = document.querySelector('input[data-edit-mode="true"]');
    return editingInput !== null && document.activeElement === editingInput;
  }
  /**
   * ÎØ∏Î¶¨Î≥¥Í∏∞ ÏòÅÏó≠ÏóêÏÑú Ïö∞ÌÅ¥Î¶≠ Ïãú Ìé∏Ïßë Î™®ÎìúÎ°ú Ï†ÑÌôòÌï©ÎãàÎã§.
   * ÏùºÍ¥Ñ ÎèôÏûë: ÌéºÏπòÍ∏∞ + Ïò§ÌÜ†Ïä§ÌÅ¨Î°§ + Ìé∏Ïßë Î™®Îìú ÏßÑÏûÖ
   */
  handlePreviewRightClick(target) {
    const correctionIndex = parseInt(target.dataset.correctionIndex || "0");
    Logger.debug(`\u{1F527} handlePreviewRightClick \uD638\uCD9C: index=${correctionIndex}, text="${target.textContent}"`);
    if (isNaN(correctionIndex) || correctionIndex < 0 || correctionIndex >= this.config.corrections.length) {
      Logger.debug("Invalid correction index for preview right click:", correctionIndex);
      return false;
    }
    const errorSummary = this.element.querySelector("#errorSummary");
    const wasCollapsed = errorSummary && errorSummary.classList.contains("collapsed");
    if (wasCollapsed) {
      errorSummary.classList.remove("collapsed");
      Logger.debug("\u{1F527} \uC624\uB958 \uC0C1\uC138 \uC601\uC5ED \uD3BC\uCE68");
      this.updateDisplay();
    }
    setTimeout(() => {
      const errorCard = this.element.querySelector(`[data-correction-index="${correctionIndex}"] .error-original-compact`);
      if (errorCard) {
        Logger.debug(`\u{1F527} \uD3B8\uC9D1 \uBAA8\uB4DC \uC9C4\uC785 - \uC624\uB958 \uC0C1\uC138 \uCE74\uB4DC \uCC3E\uC74C: index=${correctionIndex}`);
        errorCard.scrollIntoView({
          behavior: "smooth",
          block: "center"
        });
        Logger.debug("\u{1F527} \uC624\uD1A0\uC2A4\uD06C\uB864 \uC218\uD589");
        setTimeout(() => {
          this.enterCardEditMode(errorCard, correctionIndex);
        }, 300);
      } else {
        Logger.debug(`\u{1F527} \uC624\uB958 \uC0C1\uC138 \uCE74\uB4DC\uB97C \uCC3E\uC744 \uC218 \uC5C6\uC74C: index=${correctionIndex}`);
      }
    }, wasCollapsed ? 100 : 0);
    return true;
  }
  /**
   * Ïò§Î•ò ÏÉÅÏÑ∏ Ïπ¥ÎìúÏùò ÏõêÎ≥∏ ÌÖçÏä§Ìä∏ ÌÅ¥Î¶≠ Ïãú Ìé∏Ïßë Î™®ÎìúÎ°ú Ï†ÑÌôòÌï©ÎãàÎã§.
   */
  handleCardTextClick(target) {
    const correctionIndex = parseInt(target.dataset.correctionIndex || "0");
    Logger.debug(`\u{1F527} handleCardTextClick \uD638\uCD9C: index=${correctionIndex}, text="${target.textContent}"`);
    Logger.debug(`\u{1F527} target.dataset: ${JSON.stringify(target.dataset)}`);
    Logger.debug(`\u{1F527} target HTML: ${target.outerHTML}`);
    if (isNaN(correctionIndex) || correctionIndex < 0 || correctionIndex >= this.config.corrections.length) {
      Logger.debug("Invalid correction index for card text click:", correctionIndex);
      return false;
    }
    Logger.debug(`\u{1F527} enterCardEditMode \uD638\uCD9C \uC608\uC815: index=${correctionIndex}`);
    this.enterCardEditMode(target, correctionIndex);
    return true;
  }
  /**
   * Ïπ¥Îìú Ìé∏Ïßë Î™®ÎìúÎ°ú ÏßÑÏûÖÌï©ÎãàÎã§.
   */
  enterCardEditMode(originalElement, correctionIndex) {
    const currentText = originalElement.textContent || "";
    Logger.debug(`\u{1F527} enterCardEditMode \uC2DC\uC791: index=${correctionIndex}, currentText="${currentText}"`);
    const input = document.createElement("input");
    input.type = "text";
    input.value = currentText;
    input.className = "error-original-input";
    input.dataset.correctionIndex = correctionIndex.toString();
    input.dataset.editMode = "true";
    let isFinished = false;
    if (import_obsidian2.Platform.isMobile) {
      this.createMobileEditContainer(originalElement, input, correctionIndex, () => isFinished, (flag) => isFinished = flag);
    } else {
      this.createDesktopEditMode(originalElement, input, correctionIndex, () => isFinished, (flag) => isFinished = flag);
    }
  }
  /**
   * Îç∞Ïä§ÌÅ¨ÌÜ±Ïö© Ìé∏Ïßë Î™®ÎìúÎ•º ÏÉùÏÑ±Ìï©ÎãàÎã§.
   */
  createDesktopEditMode(originalElement, input, correctionIndex, getIsFinished, setIsFinished) {
    var _a;
    const errorCard = originalElement.closest(".error-card");
    let hiddenElements = [];
    if (errorCard) {
      const suggestions = errorCard.querySelector(".error-suggestions-compact");
      const exceptionBtn = errorCard.querySelector(".error-exception-btn");
      if (suggestions) {
        suggestions.style.display = "none";
        hiddenElements.push(suggestions);
        Logger.debug(`\u{1F5A5}\uFE0F \uC218\uC815 \uC81C\uC548 \uBC84\uD2BC \uC228\uAE40: index=${correctionIndex}`);
      }
      if (exceptionBtn) {
        exceptionBtn.style.display = "none";
        hiddenElements.push(exceptionBtn);
        Logger.debug(`\u{1F5A5}\uFE0F \uC608\uC678 \uCC98\uB9AC \uBC84\uD2BC \uC228\uAE40: index=${correctionIndex}`);
      }
    }
    const finishEdit = () => {
      if (getIsFinished())
        return;
      setIsFinished(true);
      hiddenElements.forEach((el) => {
        el.style.display = "";
        Logger.debug(`\u{1F5A5}\uFE0F \uC228\uACA8\uC9C4 \uC694\uC18C \uBCF5\uC6D0: ${el.className}`);
      });
      this.finishCardEdit(input, correctionIndex);
    };
    const cancelEdit = () => {
      if (getIsFinished())
        return;
      setIsFinished(true);
      hiddenElements.forEach((el) => {
        el.style.display = "";
        Logger.debug(`\u{1F5A5}\uFE0F \uC228\uACA8\uC9C4 \uC694\uC18C \uBCF5\uC6D0 (\uCDE8\uC18C): ${el.className}`);
      });
      this.cancelCardEdit(input, correctionIndex);
    };
    (_a = originalElement.parentElement) == null ? void 0 : _a.replaceChild(input, originalElement);
    input.focus();
    input.select();
    input.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        e.stopPropagation();
        finishEdit();
      } else if (e.key === "Escape") {
        e.preventDefault();
        e.stopPropagation();
        cancelEdit();
      }
    });
    input.addEventListener("blur", () => {
      finishEdit();
    });
  }
  /**
   * Î™®Î∞îÏùº Ìé∏Ïßë Î™®ÎìúÎ°ú ÏßÑÏûÖÌï©ÎãàÎã§.
   */
  enterMobileEditingMode() {
    if (!import_obsidian2.Platform.isMobile)
      return;
    const errorSummary = document.getElementById("errorSummary");
    if (errorSummary) {
      errorSummary.style.height = "auto";
      errorSummary.style.maxHeight = "none";
      errorSummary.style.flex = "1";
      errorSummary.classList.remove("collapsed");
      Logger.debug(`\u{1F4F1} \uC624\uB958 \uC0C1\uC138 \uC601\uC5ED \uC804\uCCB4 \uD655\uC7A5 (\uD3B8\uC9D1 \uBAA8\uB4DC)`);
    }
  }
  /**
   * Î™®Î∞îÏùº Ìé∏Ïßë Î™®ÎìúÏóêÏÑú Î≥µÏõêÌï©ÎãàÎã§.
   */
  exitMobileEditingMode() {
    if (!import_obsidian2.Platform.isMobile)
      return;
    const errorSummary = document.getElementById("errorSummary");
    if (errorSummary) {
      errorSummary.style.height = "";
      errorSummary.style.maxHeight = "";
      errorSummary.style.flex = "";
      Logger.debug(`\u{1F4F1} \uC624\uB958 \uC0C1\uC138 \uC601\uC5ED \uC6D0\uB798 \uD06C\uAE30\uB85C \uBCF5\uC6D0`);
    }
  }
  /**
   * Î™®Î∞îÏùºÏö© Ìé∏Ïßë Ïª®ÌÖåÏù¥ÎÑàÎ•º ÏÉùÏÑ±Ìï©ÎãàÎã§.
   */
  createMobileEditContainer(originalElement, input, correctionIndex, getIsFinished, setIsFinished) {
    var _a;
    let hiddenElements = [];
    const errorCard = originalElement.closest(".error-card");
    if (errorCard) {
      errorCard.classList.add("editing-mode");
      Logger.debug(`\u{1F4F1} editing-mode \uD074\uB798\uC2A4 \uCD94\uAC00: index=${correctionIndex}`);
      const suggestions = errorCard.querySelectorAll(".suggestion-compact");
      const keepOriginals = errorCard.querySelectorAll(".keep-original");
      const suggestionsContainer = errorCard.querySelector(".error-suggestions-compact");
      const exceptionBtn = errorCard.querySelector(".error-exception-btn");
      suggestions.forEach((btn) => {
        const button = btn;
        button.style.display = "none";
        button.style.visibility = "hidden";
        button.style.opacity = "0";
        hiddenElements.push(button);
      });
      keepOriginals.forEach((btn) => {
        const button = btn;
        button.style.display = "none";
        button.style.visibility = "hidden";
        button.style.opacity = "0";
        hiddenElements.push(button);
      });
      if (suggestionsContainer) {
        suggestionsContainer.style.display = "none";
        suggestionsContainer.style.visibility = "hidden";
        suggestionsContainer.style.opacity = "0";
        hiddenElements.push(suggestionsContainer);
        Logger.debug(`\u{1F4F1} \uC218\uC815 \uC81C\uC548 \uCEE8\uD14C\uC774\uB108 \uAC15\uC81C \uC228\uAE40: index=${correctionIndex}`);
      }
      if (exceptionBtn) {
        exceptionBtn.style.display = "none";
        exceptionBtn.style.visibility = "hidden";
        exceptionBtn.style.opacity = "0";
        hiddenElements.push(exceptionBtn);
        Logger.debug(`\u{1F4F1} \uC608\uC678 \uCC98\uB9AC \uBC84\uD2BC \uAC15\uC81C \uC228\uAE40: index=${correctionIndex}`);
      }
    }
    const container = document.createElement("div");
    container.className = "mobile-edit-container";
    const saveBtn = document.createElement("button");
    saveBtn.className = "mobile-edit-btn save";
    saveBtn.textContent = "\u2713";
    saveBtn.title = "\uC800\uC7A5";
    const cancelBtn = document.createElement("button");
    cancelBtn.className = "mobile-edit-btn cancel";
    cancelBtn.textContent = "\u2715";
    cancelBtn.title = "\uCDE8\uC18C";
    const finishEdit = () => {
      if (getIsFinished())
        return;
      setIsFinished(true);
      this.exitMobileEditingMode();
      if (errorCard) {
        errorCard.classList.remove("editing-mode");
        Logger.debug(`\u{1F4F1} editing-mode \uD074\uB798\uC2A4 \uC81C\uAC70: index=${correctionIndex}`);
      }
      hiddenElements.forEach((el) => {
        el.style.display = "";
        el.style.visibility = "";
        el.style.opacity = "";
        Logger.debug(`\u{1F4F1} \uC228\uACA8\uC9C4 \uC694\uC18C \uBCF5\uC6D0: ${el.className}`);
      });
      Logger.debug(`\u{1F4F1} \uBAA8\uBC14\uC77C \uD3B8\uC9D1 \uBAA8\uB4DC \uC885\uB8CC - \uB808\uC774\uC544\uC6C3 \uBCF5\uC6D0`);
      this.finishCardEdit(input, correctionIndex);
    };
    const cancelEdit = () => {
      if (getIsFinished())
        return;
      setIsFinished(true);
      this.exitMobileEditingMode();
      if (errorCard) {
        errorCard.classList.remove("editing-mode");
        Logger.debug(`\u{1F4F1} editing-mode \uD074\uB798\uC2A4 \uC81C\uAC70 (\uCDE8\uC18C): index=${correctionIndex}`);
      }
      hiddenElements.forEach((el) => {
        el.style.display = "";
        el.style.visibility = "";
        el.style.opacity = "";
        Logger.debug(`\u{1F4F1} \uC228\uACA8\uC9C4 \uC694\uC18C \uBCF5\uC6D0 (\uCDE8\uC18C): ${el.className}`);
      });
      Logger.debug(`\u{1F4F1} \uBAA8\uBC14\uC77C \uD3B8\uC9D1 \uBAA8\uB4DC \uCDE8\uC18C - \uB808\uC774\uC544\uC6C3 \uBCF5\uC6D0`);
      this.cancelCardEdit(input, correctionIndex);
    };
    saveBtn.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      finishEdit();
    });
    cancelBtn.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      cancelEdit();
    });
    input.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        e.stopPropagation();
        finishEdit();
      } else if (e.key === "Escape") {
        e.preventDefault();
        e.stopPropagation();
        cancelEdit();
      }
    });
    container.appendChild(input);
    container.appendChild(saveBtn);
    container.appendChild(cancelBtn);
    (_a = originalElement.parentElement) == null ? void 0 : _a.replaceChild(container, originalElement);
    setTimeout(() => {
      input.focus();
      input.select();
    }, 100);
    Logger.log(`\u{1F4F1} \uBAA8\uBC14\uC77C \uD3B8\uC9D1 \uCEE8\uD14C\uC774\uB108 \uC0DD\uC131 \uC644\uB8CC: index=${correctionIndex}`);
  }
  /**
   * Ïπ¥Îìú Ìé∏ÏßëÏùÑ ÏôÑÎ£åÌï©ÎãàÎã§.
   */
  finishCardEdit(input, correctionIndex) {
    const newValue = input.value.trim();
    const currentValue = this.stateManager.getValue(correctionIndex);
    Logger.debug(`\u{1F527} finishCardEdit \uD638\uCD9C: index=${correctionIndex}, newValue="${newValue}", currentValue="${currentValue}"`);
    if (newValue === "") {
      Logger.debug(`\u{1F527} \uBE48 \uAC12\uC73C\uB85C \uD3B8\uC9D1 \uCDE8\uC18C: index=${correctionIndex}`);
      this.cancelCardEdit(input, correctionIndex);
      return;
    }
    if (newValue === currentValue) {
      Logger.debug(`\u{1F527} \uAC12\uC774 \uBCC0\uACBD\uB418\uC9C0 \uC54A\uC544\uC11C \uD3B8\uC9D1 \uCDE8\uC18C: index=${correctionIndex}, value="${newValue}"`);
      this.cancelCardEdit(input, correctionIndex);
      return;
    }
    Logger.debug(`\u{1F527} setUserEdited \uD638\uCD9C \uC608\uC815: index=${correctionIndex}, value="${newValue}"`);
    this.stateManager.setUserEdited(correctionIndex, newValue);
    Logger.debug(`\u{1F527} updateDisplay \uD638\uCD9C \uC608\uC815`);
    this.updateDisplay();
    this.focusPreviewWordAfterEdit(correctionIndex);
  }
  /**
   * Ïπ¥Îìú Ìé∏ÏßëÏùÑ Ï∑®ÏÜåÌï©ÎãàÎã§.
   */
  cancelCardEdit(input, correctionIndex) {
    this.updateDisplay();
  }
  /**
   * Ìé∏Ïßë ÏôÑÎ£å ÌõÑ ÎØ∏Î¶¨Î≥¥Í∏∞Ïùò Ìï¥Îãπ Îã®Ïñ¥Î°ú Ìè¨Ïª§Ïä§Î•º Ïù¥ÎèôÌï©ÎãàÎã§.
   */
  focusPreviewWordAfterEdit(correctionIndex) {
    Logger.debug(`\u{1F3AF} \uD3B8\uC9D1 \uC644\uB8CC \uD6C4 \uBBF8\uB9AC\uBCF4\uAE30 \uD3EC\uCEE4\uC2A4 \uC774\uB3D9: index=${correctionIndex}`);
    setTimeout(() => {
      const rawCorrections = this.getCurrentCorrections();
      const uniqueCorrections = this.removeDuplicateCorrections(rawCorrections);
      const targetCorrectionIndex = uniqueCorrections.findIndex(
        (pc) => pc.originalIndex === correctionIndex
      );
      if (targetCorrectionIndex >= 0) {
        this.currentFocusIndex = targetCorrectionIndex;
        Logger.debug(`\u{1F3AF} \uD3EC\uCEE4\uC2A4 \uC778\uB371\uC2A4 \uC124\uC815: ${targetCorrectionIndex} (correctionIndex: ${correctionIndex})`);
        this.updateFocusHighlight();
        const previewElement = this.element.querySelector(".preview-text");
        if (previewElement) {
          const targetSpan = previewElement.querySelector(`[data-correction-index="${correctionIndex}"]`);
          if (targetSpan) {
            targetSpan.scrollIntoView({
              behavior: "smooth",
              block: "center",
              inline: "nearest"
            });
            Logger.debug(`\u{1F3AF} \uBBF8\uB9AC\uBCF4\uAE30 \uC2A4\uD06C\uB864 \uC644\uB8CC: \uB2E8\uC5B4 "${targetSpan.textContent}"`);
            targetSpan.classList.add("edit-completion-highlight");
            setTimeout(() => {
              targetSpan.classList.remove("edit-completion-highlight");
            }, 2e3);
          } else {
            Logger.debug(`\u{1F3AF} \uBBF8\uB9AC\uBCF4\uAE30\uC5D0\uC11C \uD574\uB2F9 \uB2E8\uC5B4\uB97C \uCC3E\uC744 \uC218 \uC5C6\uC74C: index=${correctionIndex}`);
          }
        }
      } else {
        Logger.debug(`\u{1F3AF} \uD604\uC7AC \uD398\uC774\uC9C0\uC5D0\uC11C \uD574\uB2F9 \uAD50\uC815\uC0AC\uD56D\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC74C: index=${correctionIndex}`);
      }
    }, 100);
  }
  /**
   * ÌéòÏù¥ÏßÄÎÑ§Ïù¥ÏÖòÏùÑ Ïû¨Í≥ÑÏÇ∞Ìï©ÎãàÎã§.
   */
  recalculatePagination() {
    const errorSummary = this.element.querySelector("#errorSummary");
    const isErrorExpanded = errorSummary ? !errorSummary.classList.contains("collapsed") : false;
    const previewElement = this.element.querySelector("#resultPreview");
    this.charsPerPage = calculateDynamicCharsPerPage(previewElement, isErrorExpanded);
    const trimmedText = this.config.selectedText.trim();
    this.pageBreaks = splitTextIntoPages(trimmedText, this.charsPerPage);
    this.totalPreviewPages = this.pageBreaks.length;
    if (this.currentPreviewPage >= this.totalPreviewPages) {
      this.currentPreviewPage = Math.max(0, this.totalPreviewPages - 1);
    }
    Logger.debug(`Recalculated pagination: Chars per page: ${this.charsPerPage}, Total pages: ${this.totalPreviewPages}, Current page: ${this.currentPreviewPage}`);
  }
  /**
   * ÎîîÏä§ÌîåÎ†àÏù¥Î•º ÏóÖÎç∞Ïù¥Ìä∏Ìï©ÎãàÎã§.
   */
  updateDisplay() {
    const previewElement = this.element.querySelector("#resultPreview");
    if (previewElement) {
      this.updatePreviewContent(previewElement);
    }
    const errorSummaryContent = this.element.querySelector("#errorSummaryContent");
    if (errorSummaryContent) {
      clearElement(errorSummaryContent);
      const errorSummaryDOM = this.generateErrorSummaryDOM();
      errorSummaryContent.appendChild(errorSummaryDOM);
    }
    this.updateErrorDetailStyles();
    this.updatePaginationControls();
    const errorCountBadge = this.element.querySelector("#errorCountBadge");
    if (errorCountBadge) {
      errorCountBadge.textContent = this.getErrorStateCount().toString();
    }
  }
  /**
   * Ïò§Î•ò ÏÉÅÏÑ∏ Ìï≠Î™©Ïùò Ïä§ÌÉÄÏùºÏùÑ ÏÉÅÌÉúÏóê Îî∞Îùº ÏóÖÎç∞Ïù¥Ìä∏Ìï©ÎãàÎã§.
   */
  updateErrorDetailStyles() {
    const errorItems = this.element.querySelectorAll(".error-item-compact");
    errorItems.forEach((item, index) => {
      const correctionIndex = parseInt(item.getAttribute("data-correction-index") || "0");
      const originalText = item.querySelector(".error-original-compact");
      if (originalText) {
        originalText.classList.remove("corrected", "exception-processed", "original-kept");
        const currentValue = this.stateManager.getValue(correctionIndex);
        const isException = this.stateManager.isExceptionState(correctionIndex);
        const isOriginalKept = this.stateManager.isOriginalKeptState(correctionIndex);
        const correction = this.config.corrections[correctionIndex];
        if (correction) {
          if (isException) {
            originalText.classList.add("exception-processed");
          } else if (isOriginalKept) {
            originalText.classList.add("original-kept");
          } else if (currentValue !== correction.original) {
            originalText.classList.add("corrected");
          }
        }
      }
    });
  }
  /**
   * ÌéòÏù¥ÏßÄÎÑ§Ïù¥ÏÖò Ïª®Ìä∏Î°§ÏùÑ ÏóÖÎç∞Ïù¥Ìä∏Ìï©ÎãàÎã§.
   */
  updatePaginationControls() {
    const paginationContainer = this.element.querySelector("#paginationContainer");
    const prevButton = this.element.querySelector("#prevPreviewPage");
    const nextButton = this.element.querySelector("#nextPreviewPage");
    const pageInfo = this.element.querySelector("#previewPageInfo");
    const pageCharsInfo = this.element.querySelector("#pageCharsInfo");
    if (paginationContainer) {
      if (this.isLongText && this.totalPreviewPages > 1) {
        paginationContainer.className = "pagination-controls";
        if (!prevButton || !nextButton) {
          clearElement(paginationContainer);
          const paginationFragment = this.createPaginationControls();
          paginationContainer.appendChild(paginationFragment);
          this.bindPaginationEvents();
        }
      } else {
        paginationContainer.className = "pagination-container-hidden";
      }
    }
    const updatedPrevButton = this.element.querySelector("#prevPreviewPage");
    const updatedNextButton = this.element.querySelector("#nextPreviewPage");
    const updatedPageInfo = this.element.querySelector("#previewPageInfo");
    const updatedPageCharsInfo = this.element.querySelector("#pageCharsInfo");
    if (updatedPrevButton)
      updatedPrevButton.disabled = this.currentPreviewPage === 0;
    if (updatedNextButton)
      updatedNextButton.disabled = this.currentPreviewPage === this.totalPreviewPages - 1;
    if (updatedPageInfo)
      updatedPageInfo.textContent = `${this.currentPreviewPage + 1} / ${this.totalPreviewPages}`;
    if (updatedPageCharsInfo)
      updatedPageCharsInfo.textContent = `${this.charsPerPage}\uC790`;
  }
  /**
   * ÍµêÏ†ïÏÇ¨Ìï≠ÏùÑ Ï†ÅÏö©Ìï©ÎãàÎã§.
   */
  async applyCorrections() {
    Logger.log("\u{1F680} applyCorrections \uC2DC\uC791");
    const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
    const currentMode = (markdownView == null ? void 0 : markdownView.getMode) ? markdownView.getMode() : "unknown";
    Logger.log(`\u{1F4DD} \uD604\uC7AC \uC5D0\uB514\uD130 \uBAA8\uB4DC: ${currentMode}`);
    const result = this.stateManager.applyCorrections(this.config.selectedText);
    Logger.log("\u{1F504} \uC5D0\uB514\uD130 \uC801\uC6A9 \uC2DC\uC791:", {
      originalTextLength: this.config.selectedText.length,
      finalTextLength: result.finalText.length,
      start: this.config.start,
      end: this.config.end,
      changed: this.config.selectedText !== result.finalText,
      exceptionWordsCount: result.exceptionWords.length,
      mode: currentMode
    });
    try {
      if (currentMode === "preview") {
        Logger.log("\u{1F4D6} \uC77D\uAE30\uBAA8\uB4DC \uAC10\uC9C0 - Vault.process() \uC0AC\uC6A9");
        const file = markdownView == null ? void 0 : markdownView.file;
        if (!file) {
          throw new Error("\uD30C\uC77C \uC815\uBCF4\uB97C \uAC00\uC838\uC62C \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
        }
        await this.app.vault.process(file, (content) => {
          const lines = content.split("\n");
          let currentLine = 0;
          let currentCol = 0;
          for (let i = 0; i < this.config.start.line; i++) {
            currentLine++;
          }
          const beforeStart = content.substring(0, this.getOffsetFromPosition(content, this.config.start));
          const afterEnd = content.substring(this.getOffsetFromPosition(content, this.config.end));
          return beforeStart + result.finalText + afterEnd;
        });
        Logger.log("\u2705 Vault.process() \uC131\uACF5\uC801\uC73C\uB85C \uC644\uB8CC\uB428");
      } else {
        this.config.editor.replaceRange(result.finalText, this.config.start, this.config.end);
        Logger.log("\u2705 editor.replaceRange \uC131\uACF5\uC801\uC73C\uB85C \uD638\uCD9C\uB428");
        const appliedText = this.config.editor.getRange(this.config.start, this.config.end);
        const actuallyApplied = appliedText === result.finalText;
        Logger.log(`\u{1F50D} \uC801\uC6A9 \uAC80\uC99D: \uC131\uACF5=${actuallyApplied}`, {
          expected: result.finalText.substring(0, 50) + (result.finalText.length > 50 ? "..." : ""),
          actual: appliedText.substring(0, 50) + (appliedText.length > 50 ? "..." : ""),
          lengthMatch: appliedText.length === result.finalText.length
        });
      }
    } catch (error) {
      Logger.error("\u274C \uD14D\uC2A4\uD2B8 \uC801\uC6A9 \uC2E4\uD328:", error);
      new import_obsidian2.Notice("\uD14D\uC2A4\uD2B8 \uC801\uC6A9 \uC911 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4.");
      return;
    }
    if (result.exceptionWords.length > 0 && this.config.onExceptionWordsAdded) {
      this.config.onExceptionWordsAdded(result.exceptionWords);
    }
    this.close();
  }
  /**
   * ÏóêÎîîÌÑ∞ ÏúÑÏπòÎ•º Î¨∏ÏûêÏó¥ Ïò§ÌîÑÏÖãÏúºÎ°ú Î≥ÄÌôòÌï©ÎãàÎã§.
   */
  getOffsetFromPosition(content, pos) {
    const lines = content.split("\n");
    let offset = 0;
    for (let i = 0; i < pos.line; i++) {
      offset += lines[i].length + 1;
    }
    offset += pos.ch;
    return offset;
  }
  /**
   * ÌåùÏóÖÏùÑ ÌëúÏãúÌï©ÎãàÎã§.
   */
  show() {
    document.body.appendChild(this.element);
    if (import_obsidian2.Platform.isMobile) {
      this.element.classList.add("mobile-popup");
      Logger.log("Mobile mode detected, added mobile-popup class");
    }
    requestAnimationFrame(() => {
      Logger.log("DOM \uCD94\uAC00 \uD6C4 \uD398\uC774\uC9C0\uB124\uC774\uC158 \uC7AC\uACC4\uC0B0 \uC2DC\uC791");
      this.recalculatePagination();
      this.updateDisplay();
      Logger.log("DOM \uCD94\uAC00 \uD6C4 \uD398\uC774\uC9C0\uB124\uC774\uC158 \uC7AC\uACC4\uC0B0 \uC644\uB8CC");
    });
  }
  /**
   * AI Î∂ÑÏÑùÏùÑ ÏàòÌñâÌï©ÎãàÎã§.
   * ‚≠ê NEW: ÌòïÌÉúÏÜå Ï†ïÎ≥¥ÏôÄ Ìï®Íªò Î∂ÑÏÑù
   */
  async performAIAnalysis() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    Logger.log("performAIAnalysis \uD638\uCD9C\uB428:", {
      hasAiService: !!this.aiService,
      isAiAnalyzing: this.isAiAnalyzing,
      aiServiceAvailable: (_a = this.aiService) == null ? void 0 : _a.isAvailable(),
      aiServiceSettings: (_b = this.aiService) == null ? void 0 : _b.getSettings()
    });
    if (!this.aiService || this.isAiAnalyzing) {
      Logger.warn("AI \uBD84\uC11D \uC911\uB2E8: aiService \uC5C6\uC74C \uB610\uB294 \uC774\uBBF8 \uBD84\uC11D \uC911");
      return;
    }
    if (!this.aiService.isAvailable()) {
      Logger.error("AI \uC11C\uBE44\uC2A4 \uC0AC\uC6A9 \uBD88\uAC00: \uAE30\uB2A5 \uBE44\uD65C\uC131\uD654 \uB610\uB294 API \uD0A4 \uC5C6\uC74C");
      new import_obsidian2.Notice("\u274C AI \uAE30\uB2A5\uC774 \uBE44\uD65C\uC131\uD654\uB418\uC5B4 \uC788\uAC70\uB098 API \uD0A4\uAC00 \uC124\uC815\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4. \uD50C\uB7EC\uADF8\uC778 \uC124\uC815\uC744 \uD655\uC778\uD574\uC8FC\uC138\uC694.", 5e3);
      return;
    }
    try {
      Logger.debug("\u{1F50D} performAIAnalysis \uBA54\uC778 try \uBE14\uB85D \uC9C4\uC785");
      this.isAiAnalyzing = true;
      const aiBtn = this.element.querySelector("#aiAnalyzeBtn");
      if (aiBtn) {
        aiBtn.disabled = true;
        aiBtn.textContent = "\u{1F916} \uBD84\uC11D \uC911...";
      }
      Logger.log("AI \uBD84\uC11D \uC2DC\uC791 \uC911...");
      Logger.debug("\u{1F50D} \uD615\uD0DC\uC18C \uBD84\uC11D \uC815\uBCF4 \uD655\uC778 \uC911...");
      let morphemeInfo = this.config.morphemeInfo || null;
      if (morphemeInfo) {
        Logger.debug("\u2705 orchestrator\uC5D0\uC11C \uD615\uD0DC\uC18C \uBD84\uC11D \uC815\uBCF4 \uC804\uB2EC\uBC1B\uC74C:", {
          hasMorphemeInfo: !!morphemeInfo,
          sentencesCount: ((_c = morphemeInfo == null ? void 0 : morphemeInfo.sentences) == null ? void 0 : _c.length) || 0,
          tokensCount: ((_d = morphemeInfo == null ? void 0 : morphemeInfo.sentences) == null ? void 0 : _d.reduce((sum, s) => {
            var _a2;
            return sum + (((_a2 = s.tokens) == null ? void 0 : _a2.length) || 0);
          }, 0)) || 0,
          firstFewTokens: ((_h = (_g = (_f = (_e = morphemeInfo == null ? void 0 : morphemeInfo.sentences) == null ? void 0 : _e[0]) == null ? void 0 : _f.tokens) == null ? void 0 : _g.slice(0, 3)) == null ? void 0 : _h.map((t) => {
            var _a2;
            return (_a2 = t.text) == null ? void 0 : _a2.content;
          })) || []
        });
      } else {
        Logger.warn("\u274C \uD615\uD0DC\uC18C \uBD84\uC11D \uC815\uBCF4 \uC5C6\uC74C - \uD328\uD134 \uB9E4\uCE6D\uB9CC \uC0AC\uC6A9");
      }
      const currentStates = this.stateManager.getAllStates();
      const analysisRequest = {
        originalText: this.config.selectedText,
        corrections: this.config.corrections,
        contextWindow: morphemeInfo ? 30 : 100,
        // ‚≠ê NEW: ÌòïÌÉúÏÜå Ï†ïÎ≥¥ ÏûàÏúºÎ©¥ Îçî Ï†ÅÏùÄ Ïª®ÌÖçÏä§Ìä∏ (ÌÜ†ÌÅ∞ Ï†àÏïΩ)
        currentStates,
        // ÌòÑÏû¨ ÏÉÅÌÉú Ï†ÑÎã¨
        editor: this.config.editor,
        // ‚≠ê NEW: Editor Ïù∏Ïä§ÌÑ¥Ïä§ Ï†ÑÎã¨ (Íµ¨Ï°∞ÌôîÎêú Ïª®ÌÖçÏä§Ìä∏ Ï∂îÏ∂úÏö©)
        file: this.config.file,
        // ‚≠ê NEW: File Ïù∏Ïä§ÌÑ¥Ïä§ Ï†ÑÎã¨ (Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ï†ïÎ≥¥Ïö©)
        enhancedContext: true,
        // ‚≠ê NEW: Ìñ•ÏÉÅÎêú Ïª®ÌÖçÏä§Ìä∏ Ï∂îÏ∂ú ÌôúÏÑ±Ìôî
        onProgress: (current, total, status) => {
          const aiBtn2 = this.element.querySelector("#aiAnalyzeBtn");
          if (aiBtn2) {
            aiBtn2.textContent = `\u{1F916} ${status}`;
          }
        }
      };
      if (await this.checkTokenUsageWarning(analysisRequest) === false) {
        return;
      }
      this.aiAnalysisResults = await this.aiService.analyzeCorrections(analysisRequest, morphemeInfo);
      Logger.log("AI \uBD84\uC11D \uC644\uB8CC:", this.aiAnalysisResults);
      this.applyAIAnalysisResults();
      this.updateDisplay();
      new import_obsidian2.Notice(`\u{1F916} AI\uAC00 ${this.aiAnalysisResults.length}\uAC1C\uC758 \uC218\uC815 \uC81C\uC548\uC744 \uBD84\uC11D\uD588\uC2B5\uB2C8\uB2E4.`, 3e3);
    } catch (error) {
      Logger.error("AI \uBD84\uC11D \uC2E4\uD328:", error);
      new import_obsidian2.Notice(`\u274C AI \uBD84\uC11D \uC2E4\uD328: ${error.message}`, 5e3);
    } finally {
      this.isAiAnalyzing = false;
      const aiBtn = this.element.querySelector("#aiAnalyzeBtn");
      if (aiBtn) {
        await this.updateAiButtonState(aiBtn);
      }
    }
  }
  /**
   * Ïò§Î•ò ÏöîÏïΩ ÏÑπÏÖòÏùò DOM Íµ¨Ï°∞Î•º ÏÉùÏÑ±Ìï©ÎãàÎã§.
   */
  generateErrorSummaryDOM() {
    Logger.debug("========= generateErrorSummaryDOM \uC2DC\uC791 =========");
    const container = document.createElement("div");
    const rawCorrections = this.getCurrentCorrections();
    Logger.debug(`RAW corrections: ${rawCorrections.length}\uAC1C`);
    const currentCorrections = this.removeDuplicateCorrections(rawCorrections);
    Logger.debug(`\uC911\uBCF5 \uC81C\uAC70 \uD6C4 corrections: ${currentCorrections.length}\uAC1C`);
    if (currentCorrections.length === 0) {
      const placeholder = document.createElement("div");
      placeholder.className = "error-placeholder";
      const icon = document.createElement("div");
      icon.className = "placeholder-icon";
      icon.textContent = "\u2713";
      placeholder.appendChild(icon);
      const text = document.createElement("div");
      text.className = "placeholder-text";
      text.textContent = "\uC774 \uD398\uC774\uC9C0\uC5D0\uB294 \uBC1C\uACAC\uB41C \uC624\uB958\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4";
      placeholder.appendChild(text);
      const subtext = document.createElement("div");
      subtext.className = "placeholder-subtext";
      subtext.textContent = "\uB2E4\uB978 \uD398\uC774\uC9C0\uC5D0\uC11C \uC624\uB958\uB97C \uD655\uC778\uD558\uC138\uC694";
      placeholder.appendChild(subtext);
      container.appendChild(placeholder);
      Logger.debug("\uC624\uB958 \uC5C6\uC74C - \uD50C\uB808\uC774\uC2A4\uD640\uB354 \uC0DD\uC131");
      Logger.debug("========= generateErrorSummaryDOM \uC885\uB8CC (\uC624\uB958 \uC5C6\uC74C) =========");
      return container;
    }
    Logger.debug("DOM \uC0DD\uC131 \uC2DC\uC791 - \uC911\uBCF5 \uC81C\uAC70 \uC644\uB8CC\uB41C corrections \uC0AC\uC6A9");
    currentCorrections.forEach((pageCorrection, index) => {
      const actualIndex = pageCorrection.originalIndex;
      const correction = pageCorrection.correction;
      const isOriginalKept = this.stateManager.isOriginalKeptState(actualIndex);
      const suggestions = correction.corrected.slice(0, 3);
      Logger.debug(`[${index}] DOM \uC0DD\uC131 \uC911: "${correction.original}" (\uACE0\uC720ID: ${pageCorrection.uniqueId}, \uC2E4\uC81C\uC778\uB371\uC2A4: ${actualIndex})`);
      const errorItem = document.createElement("div");
      errorItem.className = `error-item-compact ${isOriginalKept ? "spell-original-kept" : ""}`;
      errorItem.setAttribute("data-correction-index", actualIndex.toString());
      errorItem.setAttribute("data-unique-id", pageCorrection.uniqueId);
      Logger.debug(`[${index}] DOM \uC18D\uC131 \uC124\uC815: data-correction-index="${actualIndex}", data-unique-id="${pageCorrection.uniqueId}"`);
      const errorRow = document.createElement("div");
      errorRow.className = "error-row";
      const errorOriginal = document.createElement("div");
      const isUserEdited = this.stateManager.isUserEditedState(actualIndex);
      const stateClass = isUserEdited ? "user-edited" : isOriginalKept ? "original-kept" : this.stateManager.isExceptionState(actualIndex) ? "exception-processed" : this.stateManager.getValue(actualIndex) !== correction.original ? "corrected" : "";
      errorOriginal.className = `error-original-compact ${stateClass}`;
      errorOriginal.setAttribute("data-correction-index", actualIndex.toString());
      errorOriginal.textContent = this.stateManager.getValue(actualIndex);
      errorRow.appendChild(errorOriginal);
      const suggestionsContainer = document.createElement("div");
      suggestionsContainer.className = "error-suggestions-compact";
      suggestions.forEach((suggestion) => {
        const suggestionSpan = document.createElement("span");
        suggestionSpan.className = `suggestion-compact ${this.stateManager.isSelected(actualIndex, suggestion) ? "selected" : ""}`;
        suggestionSpan.setAttribute("data-value", suggestion);
        suggestionSpan.setAttribute("data-correction", actualIndex.toString());
        if (isOriginalKept) {
          suggestionSpan.setAttribute("disabled", "");
        }
        suggestionSpan.textContent = suggestion;
        suggestionsContainer.appendChild(suggestionSpan);
      });
      const keepOriginalSpan = document.createElement("span");
      keepOriginalSpan.className = `suggestion-compact ${this.stateManager.isSelected(actualIndex, correction.original) ? "selected" : ""} keep-original`;
      keepOriginalSpan.setAttribute("data-value", correction.original);
      keepOriginalSpan.setAttribute("data-correction", actualIndex.toString());
      if (isOriginalKept) {
        keepOriginalSpan.setAttribute("disabled", "");
      }
      keepOriginalSpan.textContent = "\uC608\uC678\uCC98\uB9AC";
      suggestionsContainer.appendChild(keepOriginalSpan);
      errorRow.appendChild(suggestionsContainer);
      errorItem.appendChild(errorRow);
      const errorHelp = document.createElement("div");
      errorHelp.className = "error-help-compact";
      errorHelp.textContent = correction.help;
      errorItem.appendChild(errorHelp);
      const aiResult = this.aiAnalysisResults.find((result) => result.correctionIndex === actualIndex);
      if (aiResult || isOriginalKept) {
        const aiAnalysis = document.createElement("div");
        aiAnalysis.className = "ai-analysis-result";
        if (aiResult) {
          const aiConfidence = document.createElement("div");
          aiConfidence.className = "ai-confidence";
          aiConfidence.textContent = "\u{1F916} \uC2E0\uB8B0\uB3C4: ";
          const confidenceScore = document.createElement("span");
          confidenceScore.className = "confidence-score";
          confidenceScore.textContent = `${aiResult.confidence}%`;
          aiConfidence.appendChild(confidenceScore);
          aiAnalysis.appendChild(aiConfidence);
          const aiReasoning = document.createElement("div");
          aiReasoning.className = "ai-reasoning";
          aiReasoning.textContent = aiResult.reasoning;
          aiAnalysis.appendChild(aiReasoning);
        } else if (isOriginalKept) {
          const aiReasoning = document.createElement("div");
          aiReasoning.className = "ai-reasoning";
          aiReasoning.textContent = "\uC0AC\uC6A9\uC790\uAC00 \uC9C1\uC811 \uC120\uD0DD\uD588\uAC70\uB098, \uC608\uC678 \uB2E8\uC5B4\uB85C \uB4F1\uB85D\uB41C \uD56D\uBAA9\uC785\uB2C8\uB2E4.";
          aiAnalysis.appendChild(aiReasoning);
        }
        errorItem.appendChild(aiAnalysis);
      }
      container.appendChild(errorItem);
      Logger.debug(`[${index}] DOM \uC0DD\uC131 \uC644\uB8CC: "${correction.original}"`);
    });
    Logger.debug(`DOM \uC0DD\uC131 \uC644\uB8CC: \uCD1D ${currentCorrections.length}\uAC1C \uC624\uB958 \uD56D\uBAA9`);
    Logger.debug("========= generateErrorSummaryDOM \uC885\uB8CC =========");
    return container;
  }
  /**
   * ÌéòÏù¥ÏßÄÎÑ§Ïù¥ÏÖò Ïª®Ìä∏Î°§Ïùò DOM Íµ¨Ï°∞Î•º ÏÉùÏÑ±Ìï©ÎãàÎã§.
   */
  createPaginationControls() {
    const fragment = document.createDocumentFragment();
    const prevButton = document.createElement("button");
    prevButton.className = "pagination-btn";
    prevButton.id = "prevPreviewPage";
    prevButton.textContent = "\uC774\uC804";
    if (this.currentPreviewPage === 0) {
      prevButton.disabled = true;
    }
    fragment.appendChild(prevButton);
    const pageInfo = document.createElement("span");
    pageInfo.className = "page-info";
    pageInfo.id = "previewPageInfo";
    pageInfo.textContent = `${this.currentPreviewPage + 1} / ${this.totalPreviewPages}`;
    fragment.appendChild(pageInfo);
    const nextButton = document.createElement("button");
    nextButton.className = "pagination-btn";
    nextButton.id = "nextPreviewPage";
    nextButton.textContent = "\uB2E4\uC74C";
    if (this.currentPreviewPage === this.totalPreviewPages - 1) {
      nextButton.disabled = true;
    }
    fragment.appendChild(nextButton);
    const charsInfo = document.createElement("span");
    charsInfo.className = "page-chars-info";
    charsInfo.id = "pageCharsInfo";
    charsInfo.textContent = `${this.charsPerPage}\uC790`;
    fragment.appendChild(charsInfo);
    return fragment;
  }
  /**
   * ÌÜ†ÌÅ∞ Í≤ΩÍ≥† Î™®Îã¨Ïùò DOM Íµ¨Ï°∞Î•º ÏÉùÏÑ±Ìï©ÎãàÎã§.
   * ‚≠ê ÌòïÌÉúÏÜå ÏµúÏ†ÅÌôî Ï†ïÎ≥¥ Ìè¨Ìï®
   */
  createTokenWarningModal(tokenUsage, isOverMaxTokens, maxTokens) {
    const content = document.createElement("div");
    content.className = "token-warning-content";
    const header = content.appendChild(document.createElement("div"));
    header.className = "token-warning-header";
    const headerIcon = header.appendChild(document.createElement("div"));
    headerIcon.className = "token-warning-header-icon";
    headerIcon.textContent = "\u26A1";
    const headerInfo = header.appendChild(document.createElement("div"));
    const title = headerInfo.appendChild(document.createElement("h3"));
    title.className = "token-warning-title";
    title.textContent = isOverMaxTokens ? "\uD1A0\uD070 \uC0AC\uC6A9\uB7C9 \uD655\uC778" : "\uD1A0\uD070 \uC0AC\uC6A9\uB7C9 \uC548\uB0B4";
    const description = headerInfo.appendChild(document.createElement("p"));
    description.className = "token-warning-description";
    description.textContent = isOverMaxTokens ? "\uC124\uC815\uB41C \uD55C\uACC4\uB97C \uCD08\uACFC\uD588\uC2B5\uB2C8\uB2E4" : "\uC608\uC0C1 \uC0AC\uC6A9\uB7C9\uC774 \uB192\uC2B5\uB2C8\uB2E4";
    const details = content.appendChild(document.createElement("div"));
    details.className = "token-warning-details";
    const stats = details.appendChild(document.createElement("div"));
    stats.className = "token-warning-stats";
    const totalTokenItem = stats.appendChild(document.createElement("div"));
    totalTokenItem.className = "token-stat-item";
    const totalTokenNumber = totalTokenItem.appendChild(document.createElement("div"));
    totalTokenNumber.className = "token-stat-number";
    totalTokenNumber.textContent = tokenUsage.totalEstimated.toLocaleString();
    const totalTokenLabel = totalTokenItem.appendChild(document.createElement("div"));
    totalTokenLabel.className = "token-stat-label";
    totalTokenLabel.textContent = "\uCD1D \uD1A0\uD070";
    const costItem = stats.appendChild(document.createElement("div"));
    costItem.className = "token-stat-item";
    const costNumber = costItem.appendChild(document.createElement("div"));
    costNumber.className = "token-stat-number orange";
    costNumber.textContent = tokenUsage.estimatedCost;
    const costLabel = costItem.appendChild(document.createElement("div"));
    costLabel.className = "token-stat-label";
    costLabel.textContent = "\uC608\uC0C1 \uBE44\uC6A9";
    const recommendation = details.appendChild(document.createElement("div"));
    recommendation.className = "token-warning-recommendation";
    const recHeader = recommendation.appendChild(document.createElement("div"));
    recHeader.className = "token-warning-recommendation-header";
    const recContent = recHeader.appendChild(document.createElement("div"));
    recContent.className = "token-warning-recommendation-content";
    const recTitle = recContent.appendChild(document.createElement("div"));
    recTitle.className = "token-warning-recommendation-title";
    recTitle.textContent = "\uC0AC\uC6A9\uB7C9 \uC138\uBD80\uC0AC\uD56D";
    const recText = recContent.appendChild(document.createElement("div"));
    recText.className = "token-warning-recommendation-text";
    const detailText = `\uC785\uB825: ${tokenUsage.inputTokens.toLocaleString()} \u2022 \uCD9C\uB825: ${tokenUsage.estimatedOutputTokens.toLocaleString()}`;
    recText.textContent = detailText;
    if (isOverMaxTokens) {
      const overLimit = content.appendChild(document.createElement("div"));
      overLimit.className = "token-warning-over-limit";
      const overLimitContent = overLimit.appendChild(document.createElement("div"));
      overLimitContent.className = "token-warning-over-limit-content";
      const overLimitIcon = overLimitContent.appendChild(document.createElement("div"));
      overLimitIcon.className = "token-warning-over-limit-icon";
      overLimitIcon.textContent = "!";
      const overLimitText = overLimitContent.appendChild(document.createElement("div"));
      overLimitText.className = "token-warning-over-limit-text";
      const overLimitTitle = overLimitText.appendChild(document.createElement("div"));
      overLimitTitle.className = "token-warning-over-limit-title";
      overLimitTitle.textContent = "\uC124\uC815\uB41C \uCD5C\uB300 \uD1A0\uD070\uC744 \uCD08\uACFC\uD588\uC2B5\uB2C8\uB2E4";
      const overLimitDesc = overLimitText.appendChild(document.createElement("div"));
      overLimitDesc.className = "token-warning-over-limit-description";
      overLimitDesc.textContent = `\uD604\uC7AC \uC124\uC815: ${maxTokens.toLocaleString()} \uD1A0\uD070 \u2192 \uCD08\uACFC\uB7C9: ${(tokenUsage.totalEstimated - maxTokens).toLocaleString()} \uD1A0\uD070`;
    }
    const actions = content.appendChild(document.createElement("div"));
    actions.className = "token-warning-actions";
    const cancelBtn = actions.appendChild(document.createElement("button"));
    cancelBtn.id = "token-warning-cancel";
    cancelBtn.className = "token-warning-btn token-warning-btn-cancel";
    cancelBtn.textContent = "\uCDE8\uC18C";
    if (isOverMaxTokens) {
      const updateSettingsBtn = actions.appendChild(document.createElement("button"));
      updateSettingsBtn.id = "token-warning-update-settings";
      updateSettingsBtn.className = "token-warning-btn token-warning-btn-settings";
      updateSettingsBtn.textContent = "\uC124\uC815 \uC5C5\uB370\uC774\uD2B8";
    }
    const proceedBtn = actions.appendChild(document.createElement("button"));
    proceedBtn.id = "token-warning-proceed";
    proceedBtn.className = "token-warning-btn token-warning-btn-proceed";
    proceedBtn.textContent = isOverMaxTokens ? "\uC774\uBC88\uB9CC \uC9C4\uD589" : "\uACC4\uC18D \uC9C4\uD589";
    const keyboardHint = content.appendChild(document.createElement("div"));
    keyboardHint.className = "token-warning-keyboard-hint";
    keyboardHint.textContent = "\u{1F4A1} \uD0A4\uBCF4\uB4DC \uB2E8\uCD95\uD0A4: Enter(\uC9C4\uD589), Esc(\uCDE8\uC18C)";
    return content;
  }
  /**
   * ÌòïÌÉúÏÜå ÏµúÏ†ÅÌôîÎ•º Í≥†Î†§Ìïú ÌÜ†ÌÅ∞ ÏÇ¨Ïö©ÎüâÏùÑ Ï∂îÏ†ïÌï©ÎãàÎã§.
   * ‚≠ê NEW: Ïã§Ï†ú ÏÇ¨Ïö©Îê† ÌîÑÎ°¨ÌîÑÌä∏ Í∏∞Î∞ò Ï†ïÌôïÌïú Ï∂îÏ†ï
   */
  async estimateTokenUsageWithMorphemes(request) {
    var _a, _b;
    try {
      const hasMultipleCorrections = request.corrections.length > 1;
      const morphemeOptimized = hasMultipleCorrections;
      Logger.debug("\uD1A0\uD070 \uACBD\uACE0\uC6A9 \uD615\uD0DC\uC18C \uCD5C\uC801\uD654 \uCD94\uC815:", {
        correctionsCount: request.corrections.length,
        estimatedOptimization: morphemeOptimized,
        reason: morphemeOptimized ? "\uBCF5\uC218 \uAD50\uC815\uC73C\uB85C \uCEE8\uD14D\uC2A4\uD2B8 \uCD95\uC18C \uC608\uC0C1" : "\uB2E8\uC77C \uAD50\uC815\uC73C\uB85C \uCD5C\uC801\uD654 \uBD88\uD544\uC694"
      });
      const adjustedRequest = {
        ...request,
        contextWindow: morphemeOptimized ? 30 : request.contextWindow || 100
      };
      const baseEstimation = ((_a = this.aiService) == null ? void 0 : _a.estimateTokenUsage(adjustedRequest)) || {
        inputTokens: 0,
        estimatedOutputTokens: 0,
        totalEstimated: 0,
        estimatedCost: "$0.00"
      };
      const morphemeTokens = morphemeOptimized ? 50 : 0;
      const finalEstimation = {
        inputTokens: baseEstimation.inputTokens + morphemeTokens,
        estimatedOutputTokens: baseEstimation.estimatedOutputTokens,
        totalEstimated: baseEstimation.totalEstimated + morphemeTokens,
        estimatedCost: baseEstimation.estimatedCost,
        morphemeOptimized
      };
      Logger.debug("\uD615\uD0DC\uC18C \uCD5C\uC801\uD654 \uBC18\uC601 \uD1A0\uD070 \uCD94\uC815:", {
        before: baseEstimation.totalEstimated,
        after: finalEstimation.totalEstimated,
        contextReduction: morphemeOptimized ? 100 - 30 : 0,
        // 70ÌÜ†ÌÅ∞ Ï†àÏïΩ
        morphemeTokens,
        netChange: morphemeOptimized ? morphemeTokens - 70 : 0,
        // Ïàú Î≥ÄÌôîÎüâ
        optimized: morphemeOptimized
      });
      return finalEstimation;
    } catch (error) {
      Logger.error("\uD1A0\uD070 \uCD94\uC815 \uC2E4\uD328, \uAE30\uBCF8\uAC12 \uC0AC\uC6A9:", error);
      Logger.error("\uC5D0\uB7EC \uC2A4\uD0DD:", error == null ? void 0 : error.stack);
      const fallbackEstimation = ((_b = this.aiService) == null ? void 0 : _b.estimateTokenUsage(request)) || {
        inputTokens: 0,
        estimatedOutputTokens: 0,
        totalEstimated: 0,
        estimatedCost: "$0.00"
      };
      Logger.warn("\uD3F4\uBC31 \uD1A0\uD070 \uCD94\uC815 \uC0AC\uC6A9:", fallbackEstimation);
      return {
        ...fallbackEstimation,
        morphemeOptimized: false
      };
    }
  }
  /**
   * ÌÜ†ÌÅ∞ ÏÇ¨Ïö©Îüâ Í≤ΩÍ≥†Î•º ÌôïÏù∏ÌïòÍ≥† ÏÇ¨Ïö©Ïûê ÌôïÏù∏ÏùÑ Î∞õÏäµÎãàÎã§.
   */
  async checkTokenUsageWarning(request) {
    var _a;
    const aiSettings = (_a = this.aiService) == null ? void 0 : _a.getProviderInfo();
    if (!this.aiService || !(aiSettings == null ? void 0 : aiSettings.available)) {
      return true;
    }
    const aiServiceSettings = this.aiService.getSettings();
    const showWarning = aiServiceSettings.showTokenWarning;
    const threshold = aiServiceSettings.tokenWarningThreshold;
    const maxTokens = aiServiceSettings.maxTokens;
    if (!showWarning) {
      return true;
    }
    const tokenUsage = await this.estimateTokenUsageWithMorphemes(request);
    const isOverMaxTokens = tokenUsage.totalEstimated > maxTokens;
    Logger.debug("\uD1A0\uD070 \uACBD\uACE0 \uBAA8\uB2EC \uD1A0\uD070 \uC0AC\uC6A9\uB7C9:", {
      total: tokenUsage.totalEstimated,
      input: tokenUsage.inputTokens,
      output: tokenUsage.estimatedOutputTokens,
      cost: tokenUsage.estimatedCost,
      morphemeOptimized: tokenUsage.morphemeOptimized,
      threshold,
      maxTokens
    });
    if (tokenUsage.totalEstimated < threshold && !isOverMaxTokens) {
      return true;
    }
    return new Promise((resolve) => {
      var _a2, _b, _c;
      const modal = document.createElement("div");
      modal.className = "token-warning-modal";
      const modalContent = this.createTokenWarningModal(tokenUsage, isOverMaxTokens, maxTokens);
      modal.appendChild(modalContent);
      document.body.appendChild(modal);
      modal.setAttribute("tabindex", "-1");
      modal.style.outline = "none";
      setTimeout(() => {
        modal.focus();
        Logger.debug("\uD1A0\uD070 \uACBD\uACE0 \uBAA8\uB2EC: \uD3EC\uCEE4\uC2A4 \uC124\uC815 \uC644\uB8CC");
      }, 10);
      let handleResponse = (action) => {
        modal.remove();
        if (action === "cancel") {
          resolve(false);
        } else if (action === "updateSettings") {
          const recommendedTokens = Math.ceil(tokenUsage.totalEstimated / 100) * 100;
          this.updateMaxTokenSetting(recommendedTokens);
          resolve(true);
        } else {
          resolve(true);
        }
      };
      const handleKeyboard = (e) => {
        Logger.debug(`\uD1A0\uD070 \uACBD\uACE0 \uBAA8\uB2EC: \uD0A4 \uC774\uBCA4\uD2B8 \uAC10\uC9C0 - ${e.key} (\uCF54\uB4DC: ${e.code})`);
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
        if (e.key === "Enter") {
          Logger.debug("\uD1A0\uD070 \uACBD\uACE0 \uBAA8\uB2EC: Enter\uD0A4 \uAC10\uC9C0 - \uC9C4\uD589");
          handleResponse("proceed");
        } else if (e.key === "Escape") {
          Logger.debug("\uD1A0\uD070 \uACBD\uACE0 \uBAA8\uB2EC: Escape\uD0A4 \uAC10\uC9C0 - \uCDE8\uC18C");
          handleResponse("cancel");
        }
      };
      modal.addEventListener("keydown", handleKeyboard, { capture: true });
      modal.addEventListener("keyup", handleKeyboard, { capture: true });
      const globalKeyHandler = (e) => {
        if (document.body.contains(modal)) {
          Logger.debug(`\uD1A0\uD070 \uACBD\uACE0 \uBAA8\uB2EC: \uAE00\uB85C\uBC8C \uD0A4 \uC774\uBCA4\uD2B8 \uCC28\uB2E8 - ${e.key}`);
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
          if (e.key === "Enter") {
            Logger.debug("\uD1A0\uD070 \uACBD\uACE0 \uBAA8\uB2EC: \uAE00\uB85C\uBC8C Enter\uD0A4 \uAC10\uC9C0 - \uC9C4\uD589");
            handleResponse("proceed");
          } else if (e.key === "Escape") {
            Logger.debug("\uD1A0\uD070 \uACBD\uACE0 \uBAA8\uB2EC: \uAE00\uB85C\uBC8C Escape\uD0A4 \uAC10\uC9C0 - \uCDE8\uC18C");
            handleResponse("cancel");
          }
        }
      };
      document.addEventListener("keydown", globalKeyHandler, { capture: true });
      document.addEventListener("keyup", globalKeyHandler, { capture: true });
      window.addEventListener("keydown", globalKeyHandler, { capture: true });
      const originalHandleResponse = handleResponse;
      handleResponse = (action) => {
        document.removeEventListener("keydown", globalKeyHandler, { capture: true });
        document.removeEventListener("keyup", globalKeyHandler, { capture: true });
        window.removeEventListener("keydown", globalKeyHandler, { capture: true });
        Logger.debug("\uD1A0\uD070 \uACBD\uACE0 \uBAA8\uB2EC: \uBAA8\uB4E0 \uC774\uBCA4\uD2B8 \uB9AC\uC2A4\uB108 \uC81C\uAC70 \uC644\uB8CC");
        originalHandleResponse(action);
      };
      (_a2 = modal.querySelector("#token-warning-cancel")) == null ? void 0 : _a2.addEventListener("click", () => handleResponse("cancel"));
      (_b = modal.querySelector("#token-warning-proceed")) == null ? void 0 : _b.addEventListener("click", () => handleResponse("proceed"));
      (_c = modal.querySelector("#token-warning-update-settings")) == null ? void 0 : _c.addEventListener("click", () => handleResponse("updateSettings"));
      modal.addEventListener("click", (e) => {
        if (e.target === modal) {
          handleResponse("cancel");
        }
      });
    });
  }
  /**
   * AI Î∂ÑÏÑù Í≤∞Í≥ºÎ•º ÏÉÅÌÉú Í¥ÄÎ¶¨ÏûêÏóê Ï†ÅÏö©Ìï©ÎãàÎã§.
   */
  applyAIAnalysisResults() {
    for (const result of this.aiAnalysisResults) {
      this.stateManager.setState(
        result.correctionIndex,
        result.selectedValue,
        result.isExceptionProcessed,
        result.isOriginalKept
      );
    }
  }
  /**
   * ÏµúÎåÄ ÌÜ†ÌÅ∞ ÏÑ§Ï†ïÏùÑ ÏóÖÎç∞Ïù¥Ìä∏Ìï©ÎãàÎã§.
   */
  updateMaxTokenSetting(newMaxTokens) {
    if (this.onSettingsUpdate) {
      this.onSettingsUpdate(newMaxTokens);
      Logger.debug(`\uCD5C\uB300 \uD1A0\uD070\uC744 ${newMaxTokens}\uC73C\uB85C \uC5C5\uB370\uC774\uD2B8\uD588\uC2B5\uB2C8\uB2E4.`);
      new import_obsidian2.Notice(`\u2699\uFE0F \uCD5C\uB300 \uD1A0\uD070\uC774 ${newMaxTokens.toLocaleString()}\uC73C\uB85C \uC5C5\uB370\uC774\uD2B8\uB418\uC5C8\uC2B5\uB2C8\uB2E4.`, 3e3);
    } else {
      Logger.warn("\uC124\uC815 \uC5C5\uB370\uC774\uD2B8 \uCF5C\uBC31\uC774 \uC5C6\uC2B5\uB2C8\uB2E4.");
    }
  }
  /**
   * Î™®Îì† Ïò§Î•òÎ•º ÏùºÍ¥ÑÎ°ú ÏàúÌôòÏãúÌÇµÎãàÎã§.
   */
  batchCycleCorrections(direction) {
    const rawCorrections = this.getCurrentCorrections();
    const uniqueCorrections = this.removeDuplicateCorrections(rawCorrections);
    if (uniqueCorrections.length === 0)
      return;
    let changedCount = 0;
    uniqueCorrections.forEach((pageCorrection) => {
      const actualIndex = pageCorrection.originalIndex;
      if (actualIndex !== -1) {
        this.cycleCorrectionState(actualIndex, direction);
        changedCount++;
      }
    });
    new import_obsidian2.Notice(`\u2728 ${changedCount}\uAC1C \uC624\uB958\uAC00 \uC77C\uAD04 ${direction === "next" ? "\uB2E4\uC74C" : "\uC774\uC804"} \uC81C\uC548\uC73C\uB85C \uBCC0\uACBD\uB418\uC5C8\uC2B5\uB2C8\uB2E4.`, 2e3);
    Logger.log(`\uC77C\uAD04 \uBCC0\uACBD \uC644\uB8CC: ${direction}, ${changedCount}\uAC1C \uD56D\uBAA9`);
  }
  /**
   * ÌÇ§Î≥¥Îìú ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò ÌûåÌä∏Î•º ÌëúÏãúÌï©ÎãàÎã§.
   */
  showKeyboardHint() {
    if (import_obsidian2.Platform.isMobile) {
      Logger.debug("\uBAA8\uBC14\uC77C \uD658\uACBD\uC5D0\uC11C\uB294 \uD0A4\uBCF4\uB4DC \uD78C\uD2B8\uB97C \uD45C\uC2DC\uD558\uC9C0 \uC54A\uC74C");
      return;
    }
    const hint = document.createElement("div");
    hint.className = "keyboard-navigation-hint";
    hint.id = "keyboard-hint";
    const header = document.createElement("div");
    header.className = "hint-header";
    const title = document.createElement("div");
    title.className = "hint-title";
    title.textContent = "\u2328\uFE0F \uD0A4\uBCF4\uB4DC \uB2E8\uCD95\uD0A4";
    header.appendChild(title);
    const closeBtn = document.createElement("button");
    closeBtn.className = "hint-close-btn";
    closeBtn.textContent = "\xD7";
    closeBtn.title = "\uB2E8\uCD95\uD0A4 \uAC00\uC774\uB4DC \uB2EB\uAE30";
    closeBtn.addEventListener("click", () => {
      hint.style.opacity = "0";
      setTimeout(() => hint.remove(), 200);
    });
    header.appendChild(closeBtn);
    hint.appendChild(header);
    const shortcuts = [
      { key: "Tab", desc: "\uB2E4\uC74C \uC624\uB958" },
      { key: "\u2190/\u2192", desc: "\uC218\uC815 \uC81C\uC548 \uC21C\uD658" },
      { key: "Enter", desc: "\uC801\uC6A9" },
      { key: "\u2318Enter", desc: "\uBAA8\uB4E0 \uBCC0\uACBD\uC0AC\uD56D \uC800\uC7A5" },
      { key: "\u2318E", desc: "\uD3B8\uC9D1 \uBAA8\uB4DC" },
      { key: "\u21E7\u2318A", desc: "AI \uBD84\uC11D" },
      { key: "\u2318\u21E7E", desc: "\uC624\uB958 \uC0C1\uC138 \uD1A0\uAE00" },
      { key: "\u2318\u21E7\u2190/\u2192", desc: "\uC77C\uAD04 \uBCC0\uACBD" },
      { key: "\u2191/\u2193", desc: "\uD398\uC774\uC9C0 \uC774\uB3D9" },
      { key: "Esc", desc: "\uB2EB\uAE30" }
    ];
    shortcuts.forEach((shortcut) => {
      const item = document.createElement("div");
      item.className = "hint-item";
      const key = document.createElement("span");
      key.className = "hint-key";
      key.textContent = shortcut.key;
      const desc = document.createElement("span");
      desc.className = "hint-desc";
      desc.textContent = shortcut.desc;
      item.appendChild(key);
      item.appendChild(desc);
      hint.appendChild(item);
    });
    document.body.appendChild(hint);
    Logger.log("\uD0A4\uBCF4\uB4DC \uB124\uBE44\uAC8C\uC774\uC158 \uD78C\uD2B8 \uD45C\uC2DC\uB428 (\uB370\uC2A4\uD06C\uD1B1 \uC804\uC6A9)");
  }
  /**
   * Ïò§Î•ò ÏÉÅÏÑ∏Î∂ÄÎ∂Ñ ÌéºÏπ®/Ï†ëÌûòÏùÑ ÌÜ†Í∏ÄÌï©ÎãàÎã§.
   */
  toggleErrorSummary() {
    Logger.log("\uC624\uB958 \uC0C1\uC138\uBD80\uBD84 \uD1A0\uAE00 \uD2B8\uB9AC\uAC70\uB428 (\uD0A4\uBCF4\uB4DC \uB2E8\uCD95\uD0A4: \u2318\u21E7E)");
    const errorSummary = document.getElementById("errorSummary");
    if (!errorSummary) {
      Logger.warn("errorSummary \uC694\uC18C\uB97C \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
      return;
    }
    const isCurrentlyCollapsed = errorSummary.classList.contains("collapsed");
    if (isCurrentlyCollapsed) {
      errorSummary.classList.remove("collapsed");
      Logger.log("\uC624\uB958 \uC0C1\uC138\uBD80\uBD84 \uD3FC\uCE68");
    } else {
      errorSummary.classList.add("collapsed");
      Logger.log("\uC624\uB958 \uC0C1\uC138\uBD80\uBD84 \uC811\uD798");
    }
    this.recalculatePagination();
    this.updateDisplay();
  }
  /**
   * ÌòÑÏû¨ Ìè¨Ïª§Ïä§Îêú Ïò§Î•òÎ°ú Ïä§ÌÅ¨Î°§Ìï©ÎãàÎã§.
   * @param forceOpen Í∞ïÏ†úÎ°ú ÏÉÅÏÑ∏Î∂ÄÎ∂ÑÏùÑ ÌéºÏπ†ÏßÄ Ïó¨Î∂Ä (Í∏∞Î≥∏Í∞í: false)
   */
  scrollToFocusedError(forceOpen = false) {
    const rawCorrections = this.getCurrentCorrections();
    const uniqueCorrections = this.removeDuplicateCorrections(rawCorrections);
    if (uniqueCorrections.length === 0 || this.currentFocusIndex < 0)
      return;
    const pageCorrection = uniqueCorrections[this.currentFocusIndex];
    if (!pageCorrection)
      return;
    const actualIndex = pageCorrection.originalIndex;
    const errorSummary = document.getElementById("errorSummary");
    if (!errorSummary)
      return;
    const errorItems = errorSummary.querySelectorAll(".error-item-compact");
    let targetItem = null;
    errorItems.forEach((item, index) => {
      const itemPageCorrection = uniqueCorrections[index];
      if (itemPageCorrection && itemPageCorrection.originalIndex === actualIndex) {
        targetItem = item;
      }
    });
    if (targetItem) {
      const isCollapsed = errorSummary.classList.contains("collapsed");
      if (isCollapsed && forceOpen) {
        errorSummary.classList.remove("collapsed");
        this.recalculatePagination();
        this.updateDisplay();
        setTimeout(() => {
          targetItem.scrollIntoView({
            behavior: "smooth",
            block: "center",
            inline: "nearest"
          });
          this.highlightFocusedError(targetItem);
        }, 100);
      } else if (!isCollapsed) {
        targetItem.scrollIntoView({
          behavior: "smooth",
          block: "center",
          inline: "nearest"
        });
        this.highlightFocusedError(targetItem);
      }
      Logger.debug(`\uC624\uB958 \uC0C1\uC138\uBD80\uBD84 \uC790\uB3D9\uC2A4\uD06C\uB864: ${pageCorrection.correction.original} (forceOpen: ${forceOpen}, collapsed: ${isCollapsed})`);
    }
  }
  /**
   * Ìè¨Ïª§Ïä§Îêú Ïò§Î•ò Ïπ¥ÎìúÎ•º ÌïòÏù¥ÎùºÏù¥Ìä∏Ìï©ÎãàÎã§.
   */
  highlightFocusedError(targetItem) {
    const existingHighlight = document.querySelector(".error-item-highlighted");
    if (existingHighlight) {
      existingHighlight.classList.remove("error-item-highlighted");
    }
    targetItem.classList.add("error-item-highlighted");
    setTimeout(() => {
      targetItem.classList.remove("error-item-highlighted");
    }, 2e3);
    Logger.log("\uC624\uB958 \uCE74\uB4DC \uD558\uC774\uB77C\uC774\uD2B8 \uC560\uB2C8\uBA54\uC774\uC158 \uC801\uC6A9");
  }
  /**
   * ÌòÑÏû¨ Ìè¨Ïª§Ïä§Îêú Ïò§Î•òÏóê ÎåÄÌï¥ Ìé∏Ïßë Î™®ÎìúÎ°ú ÏßÑÏûÖÌï©ÎãàÎã§.
   */
  enterEditModeForFocusedError() {
    Logger.log(`\u2328\uFE0F enterEditModeForFocusedError \uD638\uCD9C\uB428: currentFocusIndex=${this.currentFocusIndex}`);
    const rawCorrections = this.getCurrentCorrections();
    const uniqueCorrections = this.removeDuplicateCorrections(rawCorrections);
    this.currentCorrections = uniqueCorrections;
    Logger.debug(`\u2328\uFE0F \uAD50\uC815\uC0AC\uD56D \uAC1C\uC218: raw=${rawCorrections.length}, unique=${uniqueCorrections.length}`);
    Logger.debug(`\u2328\uFE0F \uD3EC\uCEE4\uC2A4 \uC778\uB371\uC2A4 \uC720\uD6A8\uC131: currentFocusIndex=${this.currentFocusIndex}, \uBC94\uC704=[0, ${uniqueCorrections.length - 1}]`);
    if (this.currentFocusIndex < 0 || this.currentFocusIndex >= uniqueCorrections.length) {
      if (uniqueCorrections.length > 0) {
        this.currentFocusIndex = 0;
        Logger.debug(`\u2328\uFE0F \uD3EC\uCEE4\uC2A4 \uC778\uB371\uC2A4 \uCD08\uAE30\uD654: ${this.currentFocusIndex}`);
      } else {
        Logger.warn("\u{1F6AB} \uD3B8\uC9D1 \uAC00\uB2A5\uD55C \uC624\uB958\uAC00 \uC5C6\uC74C");
        return;
      }
    }
    const pageCorrection = uniqueCorrections[this.currentFocusIndex];
    const actualIndex = pageCorrection.originalIndex;
    Logger.debug(`\u2328\uFE0F Cmd+E\uD0A4\uB85C \uD3B8\uC9D1 \uBAA8\uB4DC \uC9C4\uC785: index=${actualIndex}, text="${pageCorrection.correction.original}"`);
    const errorSummary = this.element.querySelector("#errorSummary");
    const wasCollapsed = errorSummary && errorSummary.classList.contains("collapsed");
    if (wasCollapsed) {
      errorSummary.classList.remove("collapsed");
      Logger.debug("\u2328\uFE0F \uC624\uB958 \uC0C1\uC138 \uC601\uC5ED \uC790\uB3D9 \uD3BC\uCE68");
      this.updateDisplay();
    }
    setTimeout(() => {
      const errorCard = this.element.querySelector(`[data-correction-index="${actualIndex}"] .error-original-compact`);
      if (errorCard) {
        Logger.debug(`\u2328\uFE0F \uD3B8\uC9D1 \uBAA8\uB4DC \uC9C4\uC785 - \uC624\uB958 \uC0C1\uC138 \uCE74\uB4DC \uCC3E\uC74C: index=${actualIndex}`);
        errorCard.scrollIntoView({
          behavior: "smooth",
          block: "center"
        });
        Logger.debug("\u2328\uFE0F \uC624\uD1A0\uC2A4\uD06C\uB864 \uC218\uD589");
        setTimeout(() => {
          this.enterCardEditMode(errorCard, actualIndex);
        }, 300);
      } else {
        Logger.debug(`\u2328\uFE0F \uC624\uB958 \uC0C1\uC138 \uCE74\uB4DC\uB97C \uCC3E\uC744 \uC218 \uC5C6\uC74C: index=${actualIndex}`);
        Logger.debug(`\u2328\uFE0F \uC7AC\uC2DC\uB3C4: \uBAA8\uB4E0 .error-original-compact \uC694\uC18C \uD655\uC778`);
        const allCards = this.element.querySelectorAll(".error-original-compact");
        Logger.debug(`\u2328\uFE0F \uBC1C\uACAC\uB41C \uCE74\uB4DC \uAC1C\uC218: ${allCards.length}`);
        allCards.forEach((card, index) => {
          var _a, _b;
          const cardIndex = (_b = (_a = card.parentElement) == null ? void 0 : _a.dataset) == null ? void 0 : _b.correctionIndex;
          Logger.debug(`\u2328\uFE0F \uCE74\uB4DC ${index}: correctionIndex=${cardIndex}`);
        });
      }
    }, wasCollapsed ? 100 : 0);
  }
  /**
   * ÌåùÏóÖÏùÑ Îã´ÏäµÎãàÎã§.
   */
  close() {
    this.app.keymap.popScope(this.keyboardScope);
    const hint = document.getElementById("keyboard-hint");
    if (hint) {
      hint.remove();
    }
    document.body.classList.remove("spell-popup-open");
    this.destroy();
  }
};

// src/services/aiAnalysisService.ts
init_aiModels();

// src/utils/tokenEstimator.ts
function estimateTokenCount(text) {
  if (!text)
    return 0;
  const koreanChars = (text.match(/[\u3131-\u3163\uac00-\ud7a3]/g) || []).length;
  const englishChars = (text.match(/[a-zA-Z]/g) || []).length;
  const otherChars = text.length - koreanChars - englishChars;
  const estimatedTokens = Math.ceil(
    koreanChars * 1.8 + // ÌïúÍµ≠Ïñ¥ Î¨∏Ïûê
    englishChars * 0.25 + // ÏòÅÏñ¥ Î¨∏Ïûê (4Í∏ÄÏûêÎãπ 1ÌÜ†ÌÅ∞)
    otherChars * 0.5
    // Í∏∞ÌÉÄ Î¨∏Ïûê (Í≥µÎ∞±, Íµ¨ÎëêÏ†ê Îì±)
  );
  return estimatedTokens;
}
function estimateAnalysisTokenUsage(correctionContexts) {
  const systemPromptTokens = 150;
  let userPromptTokens = 50;
  userPromptTokens += correctionContexts.length * 20;
  correctionContexts.forEach((ctx) => {
    userPromptTokens += estimateTokenCount(ctx.fullContext);
    userPromptTokens += estimateTokenCount(ctx.original);
    userPromptTokens += estimateTokenCount(ctx.corrected.join(", "));
    userPromptTokens += estimateTokenCount(ctx.help);
  });
  const inputTokens = systemPromptTokens + userPromptTokens;
  const estimatedOutputTokens = correctionContexts.length * 75;
  return {
    inputTokens,
    estimatedOutputTokens,
    totalEstimated: inputTokens + estimatedOutputTokens
  };
}
function estimateCost(tokens, provider) {
  const costs = {
    openai: {
      "gpt-4o": { input: 2.5, output: 10 },
      // per 1M tokens (USD)
      "gpt-4o-mini": { input: 0.15, output: 0.6 },
      "gpt-4-turbo": { input: 10, output: 30 },
      "gpt-4": { input: 30, output: 60 }
    },
    anthropic: {
      "claude-3-5-sonnet-20241022": { input: 3, output: 15 },
      "claude-3-5-haiku-20241022": { input: 0.25, output: 1.25 }
    },
    google: {
      "gemini-1.5-pro": { input: 1.25, output: 5 },
      "gemini-1.5-flash": { input: 0.075, output: 0.3 }
    }
  };
  const avgCostPer1M = 2;
  const estimatedCostUSD = tokens / 1e6 * avgCostPer1M;
  const exchangeRate = 1350;
  const estimatedCostKRW = estimatedCostUSD * exchangeRate;
  if (estimatedCostUSD < 1e-3) {
    return "< $0.001 (< \u20A91)";
  } else if (estimatedCostUSD < 0.01) {
    return `~$${estimatedCostUSD.toFixed(4)} (~\u20A9${estimatedCostKRW.toFixed(0)})`;
  } else {
    return `~$${estimatedCostUSD.toFixed(3)} (~\u20A9${estimatedCostKRW.toFixed(0)})`;
  }
}

// src/services/aiAnalysisService.ts
init_logger();
var AIAnalysisService = class {
  constructor(settings) {
    this.settings = settings;
  }
  /**
   * AI ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ìå©ÌÜ†Î¶¨Î•º ÏßÄÏó∞ Î°úÎî©Ìï©ÎãàÎã§ (ÏÑ±Îä• ÏµúÏ†ÅÌôî)
   * @private
   */
  async getClientFactory() {
    const { AIClientFactory: AIClientFactory2 } = await Promise.resolve().then(() => (init_clientFactory(), clientFactory_exports));
    return AIClientFactory2;
  }
  /**
   * API ÌÇ§ Ïú†Ìö®ÏÑ±ÏùÑ ÌôïÏù∏Ìï©ÎãàÎã§ (lazy loading Ìå©ÌÜ†Î¶¨ ÏÇ¨Ïö©)
   * @private
   */
  async hasValidApiKey(settings) {
    const ClientFactory = await this.getClientFactory();
    return ClientFactory.hasValidApiKey(settings);
  }
  /**
   * Í∞Å Ïò§Î•òÏóê ÎåÄÌïú Ïª®ÌÖçÏä§Ìä∏Î•º Ï∂îÏ∂úÌï©ÎãàÎã§.
   */
  extractCorrectionContexts(request, morphemeInfo) {
    const { originalText, corrections, contextWindow = 50, currentStates, editor, file, enhancedContext = true } = request;
    const contexts = [];
    corrections.forEach((correction, index) => {
      const errorIndex = originalText.indexOf(correction.original);
      if (errorIndex === -1) {
        Logger.warn(`\uC624\uB958 \uD14D\uC2A4\uD2B8\uB97C \uCC3E\uC744 \uC218 \uC5C6\uC74C: "${correction.original}"`);
        contexts.push({
          correctionIndex: index,
          original: correction.original,
          corrected: correction.corrected,
          help: correction.help,
          contextBefore: "",
          contextAfter: "",
          fullContext: correction.original
        });
        return;
      }
      const startIndex = Math.max(0, errorIndex - contextWindow);
      const endIndex = Math.min(originalText.length, errorIndex + correction.original.length + contextWindow);
      const contextBefore = originalText.slice(startIndex, errorIndex);
      const contextAfter = originalText.slice(errorIndex + correction.original.length, endIndex);
      const fullContext = originalText.slice(startIndex, endIndex);
      const stateInfo = currentStates ? currentStates[index] : void 0;
      const context = {
        correctionIndex: index,
        original: correction.original,
        corrected: correction.corrected,
        help: correction.help,
        contextBefore: contextBefore.trim(),
        contextAfter: contextAfter.trim(),
        fullContext: fullContext.trim(),
        currentState: stateInfo == null ? void 0 : stateInfo.state,
        currentValue: stateInfo == null ? void 0 : stateInfo.value
      };
      if (enhancedContext && editor) {
        try {
          const enhancedInfo = this.extractEnhancedContext(
            editor,
            file,
            originalText,
            correction,
            errorIndex,
            morphemeInfo
          );
          if (enhancedInfo.isLikelyProperNoun) {
            context.sentenceContext = enhancedInfo.sentenceContext;
            context.isLikelyProperNoun = true;
            context.documentType = enhancedInfo.documentType;
            Logger.debug(`\u{1F50D} \uACE0\uC720\uBA85\uC0AC \uAC10\uC9C0: "${correction.original}" - \uAC10\uC9C0 \uBC29\uBC95: ${enhancedInfo.detectionMethod} - \uBB38\uC7A5 \uCEE8\uD14D\uC2A4\uD2B8 \uCD94\uAC00`);
          }
        } catch (error) {
          Logger.warn("\uD5A5\uC0C1\uB41C \uCEE8\uD14D\uC2A4\uD2B8 \uCD94\uCD9C \uC2E4\uD328:", error);
        }
      }
      contexts.push(context);
    });
    return contexts;
  }
  /**
   * ÌòïÌÉúÏÜå Î∂ÑÏÑù Í≤∞Í≥º Ï†ÑÏ≤¥Î•º Î°úÍπÖÌï©ÎãàÎã§.
   */
  logMorphemeAnalysis(morphemeInfo, corrections) {
    Logger.debug("\u{1F4CB} \uD615\uD0DC\uC18C \uBD84\uC11D \uACB0\uACFC \uC694\uC57D:");
    if (!morphemeInfo || !morphemeInfo.sentences) {
      Logger.warn("\uD615\uD0DC\uC18C \uBD84\uC11D \uB370\uC774\uD130\uAC00 \uC720\uD6A8\uD558\uC9C0 \uC54A\uC74C");
      return;
    }
    const totalSentences = morphemeInfo.sentences.length;
    const totalTokens = morphemeInfo.sentences.reduce((sum, sentence) => sum + (sentence.tokens ? sentence.tokens.length : 0), 0);
    Logger.debug(`  \uCD1D ${totalSentences}\uAC1C \uBB38\uC7A5, ${totalTokens}\uAC1C \uD1A0\uD070 \uBD84\uC11D\uB428`);
    const properNouns = [];
    const foreignWords = [];
    const allTokens = [];
    morphemeInfo.sentences.forEach((sentence, sentenceIdx) => {
      if (!sentence.tokens)
        return;
      sentence.tokens.forEach((token) => {
        var _a, _b;
        const tokenText = ((_a = token.text) == null ? void 0 : _a.content) || "";
        const tags = ((_b = token.morphemes) == null ? void 0 : _b.map((m) => m.tag)) || [];
        allTokens.push({ text: tokenText, tags });
        if (tags.some((tag) => ["NNP"].includes(tag))) {
          if (!properNouns.includes(tokenText)) {
            properNouns.push(tokenText);
          }
        }
        if (tags.some((tag) => ["SL", "SH", "SN"].includes(tag))) {
          if (!foreignWords.includes(tokenText)) {
            foreignWords.push(tokenText);
          }
        }
      });
    });
    if (properNouns.length > 0) {
      Logger.debug(`  \u{1F3F7}\uFE0F  \uACE0\uC720\uBA85\uC0AC (NNP): [${properNouns.map((noun) => `"${noun}"`).join(", ")}]`);
    }
    if (foreignWords.length > 0) {
      Logger.debug(`  \u{1F310} \uC678\uAD6D\uC5B4/\uD2B9\uC218\uC5B4 (SL/SH/SN): [${foreignWords.map((word) => `"${word}"`).join(", ")}]`);
    }
    const errorWords = corrections.map((c) => c.original);
    const matchedErrors = errorWords.filter(
      (word) => properNouns.includes(word) || foreignWords.includes(word)
    );
    if (matchedErrors.length > 0) {
      Logger.debug(`  \u2728 \uB9DE\uCDA4\uBC95 \uC624\uB958 \uC911 \uD615\uD0DC\uC18C \uBD84\uC11D\uC73C\uB85C \uAC10\uC9C0\uB41C \uACE0\uC720\uBA85\uC0AC/\uC678\uAD6D\uC5B4: [${matchedErrors.map((word) => `"${word}"`).join(", ")}]`);
    } else {
      Logger.debug("  \u2753 \uB9DE\uCDA4\uBC95 \uC624\uB958 \uC911 \uD615\uD0DC\uC18C \uBD84\uC11D\uC73C\uB85C \uACE0\uC720\uBA85\uC0AC/\uC678\uAD6D\uC5B4\uB85C \uBD84\uB958\uB41C \uB2E8\uC5B4 \uC5C6\uC74C");
    }
    Logger.debug("\uC0C1\uC138 \uD1A0\uD070 \uC815\uBCF4 (\uCC98\uC74C 10\uAC1C):");
    allTokens.slice(0, 10).forEach((token, idx) => {
      Logger.debug(`  ${idx + 1}. "${token.text}" \u2192 [${token.tags.join(", ")}]`);
    });
    if (allTokens.length > 10) {
      Logger.debug(`  ... \uBC0F ${allTokens.length - 10}\uAC1C \uD1A0\uD070 \uB354 \uC788\uC74C`);
    }
  }
  /**
   * ÌòïÌÉúÏÜå Î∂ÑÏÑù Í≤∞Í≥ºÏóêÏÑú Í≥†Ïú†Î™ÖÏÇ¨Î•º Í∞êÏßÄÌï©ÎãàÎã§.
   */
  isProperNounFromMorphemes(text, morphemeInfo) {
    if (!morphemeInfo || !morphemeInfo.sentences)
      return false;
    for (const sentence of morphemeInfo.sentences) {
      for (const token of sentence.tokens) {
        if (token.text.content === text) {
          for (const morpheme of token.morphemes) {
            const tag = morpheme.tag;
            if (["NNP", "SL", "SH", "SN"].includes(tag)) {
              const tagDescriptions = {
                "NNP": "\uACE0\uC720\uBA85\uC0AC",
                "SL": "\uC678\uAD6D\uC5B4",
                "SH": "\uD55C\uC790",
                "SN": "\uC22B\uC790"
              };
              const tagDescription = tagDescriptions[tag] || tag;
              Logger.debug(`\u{1F3F7}\uFE0F \uD615\uD0DC\uC18C \uACE0\uC720\uBA85\uC0AC \uAC10\uC9C0: "${text}" - \uD488\uC0AC: ${tag}(${tagDescription})`);
              return true;
            }
          }
        }
      }
    }
    return false;
  }
  /**
   * Obsidian EditorÎ•º ÌôúÏö©Ìïú Ìñ•ÏÉÅÎêú Ïª®ÌÖçÏä§Ìä∏ Ï∂îÏ∂ú
   */
  extractEnhancedContext(editor, file, originalText, correction, errorIndex, morphemeInfo) {
    const errorPosition = editor.offsetToPos(errorIndex);
    const sentenceContext = this.extractCurrentSentence(editor, errorPosition);
    const documentType = (file == null ? void 0 : file.extension) || "unknown";
    let isLikelyProperNoun = false;
    let detectionMethod = "";
    if (morphemeInfo) {
      const morphemeDetected = this.isProperNounFromMorphemes(correction.original, morphemeInfo);
      const patternDetected = this.detectProperNounPatterns(correction.original, sentenceContext);
      if (morphemeDetected) {
        isLikelyProperNoun = true;
        detectionMethod = "\uD615\uD0DC\uC18C \uBD84\uC11D";
      } else if (patternDetected) {
        isLikelyProperNoun = true;
        detectionMethod = "\uD328\uD134 \uB9E4\uCE6D";
      }
    } else {
      const patternDetected = this.detectProperNounPatterns(correction.original, sentenceContext);
      if (patternDetected) {
        isLikelyProperNoun = true;
        detectionMethod = "\uD328\uD134 \uB9E4\uCE6D (\uD615\uD0DC\uC18C \uBD84\uC11D \uC5C6\uC74C)";
      }
    }
    return {
      sentenceContext,
      isLikelyProperNoun,
      documentType,
      detectionMethod
    };
  }
  /**
   * ÌòÑÏû¨ Î¨∏Ïû•ÏùÑ Ï∂îÏ∂úÌï©ÎãàÎã§.
   */
  extractCurrentSentence(editor, position) {
    const currentLine = editor.getLine(position.line);
    const sentenceEndPattern = /[.!?„ÄÇÔºÅÔºü]/g;
    let sentenceStart = 0;
    for (let i = position.ch - 1; i >= 0; i--) {
      if (sentenceEndPattern.test(currentLine[i])) {
        sentenceStart = i + 1;
        break;
      }
    }
    let sentenceEnd = currentLine.length;
    for (let i = position.ch; i < currentLine.length; i++) {
      if (sentenceEndPattern.test(currentLine[i])) {
        sentenceEnd = i + 1;
        break;
      }
    }
    return currentLine.slice(sentenceStart, sentenceEnd).trim();
  }
  /**
   * Ìå®ÌÑ¥ Í∏∞Î∞ò Í≥†Ïú†Î™ÖÏÇ¨ Í∞êÏßÄ (ÌòïÌÉúÏÜå Î∂ÑÏÑùÏù¥ ÏóÜÏùÑ Îïå Ìè¥Î∞±)
   */
  detectProperNounPatterns(text, sentenceContext) {
    const patterns = [
      { pattern: /^[A-Z][a-z]+/, name: "\uC601\uC5B4 \uACE0\uC720\uBA85\uC0AC" },
      // GitHub, React Îì±
      { pattern: /^[A-Z]{2,}$/, name: "\uC601\uC5B4 \uC57D\uC5B4" },
      // API, URL, HTTP
      { pattern: /\w+Îãò$/, name: "\uC874\uCE6D" },
      // ÍπÄÏ≤†ÏàòÎãò
      { pattern: /^[Í∞Ä-Ìû£]{2,4}[ÏãúÎèÑÍµ∞Íµ¨]$/, name: "\uC9C0\uBA85" },
      // ÏÑúÏö∏Ïãú, Î∂ÄÏÇ∞Í¥ëÏó≠Ïãú
      { pattern: /\d{4}ÎÖÑ/, name: "\uC5F0\uB3C4" },
      // 2018ÎÖÑ
      { pattern: /^[Í∞Ä-Ìû£]+\.(js|ts|py|css|html|md)$/, name: "\uD30C\uC77C\uBA85" }
      // ÌååÏùºÎ™Ö
    ];
    for (const { pattern, name } of patterns) {
      if (pattern.test(text)) {
        Logger.debug(`\u{1F50D} \uD328\uD134 \uACE0\uC720\uBA85\uC0AC \uAC10\uC9C0: "${text}" - \uD328\uD134: ${name}`);
        return true;
      }
    }
    return false;
  }
  /**
   * AI Î∂ÑÏÑùÏóê ÌïÑÏöîÌïú ÌÜ†ÌÅ∞ ÏÇ¨Ïö©ÎüâÏùÑ Ï∂îÏ†ïÌï©ÎãàÎã§.
   */
  estimateTokenUsage(request) {
    const correctionContexts = this.extractCorrectionContexts(request);
    const tokenUsage = estimateAnalysisTokenUsage(correctionContexts);
    const cost = estimateCost(tokenUsage.totalEstimated, this.settings.provider);
    return {
      ...tokenUsage,
      estimatedCost: cost
    };
  }
  /**
   * ÏµúÏ†ÅÏùò Î∞∞Ïπò ÌÅ¨Í∏∞Î•º Í≥ÑÏÇ∞Ìï©ÎãàÎã§.
   * ‚≠ê JSON ÏûòÎ¶º Î∞©ÏßÄÎ•º ÏúÑÌï¥ Î≥¥ÏàòÏ†Å Î∞∞Ïπò ÌÅ¨Í∏∞ Ï†ÅÏö©
   */
  calculateOptimalBatchSize(correctionContexts, hasMorphemeInfo = false) {
    if (correctionContexts.length === 0)
      return 5;
    const avgContextLength = correctionContexts.reduce((sum, ctx) => sum + ctx.fullContext.length, 0) / correctionContexts.length;
    const systemPromptLength = AI_PROMPTS.analysisSystem.length;
    const maxInputTokens = this.getModelMaxInputTokens(this.settings.model);
    let optimalSize = 6;
    if (avgContextLength < 50) {
      optimalSize = 8;
    } else if (avgContextLength < 100) {
      optimalSize = 6;
    } else if (avgContextLength < 200) {
      optimalSize = 4;
    } else {
      optimalSize = 3;
    }
    if (hasMorphemeInfo) {
      optimalSize = Math.max(3, optimalSize - 1);
    }
    Logger.debug(`JSON \uC798\uB9BC \uBC29\uC9C0 \uBC30\uCE58 \uD06C\uAE30: \uD3C9\uADE0 \uCEE8\uD14D\uC2A4\uD2B8 ${avgContextLength}\uC790, \uD615\uD0DC\uC18C: ${hasMorphemeInfo} \u2192 ${optimalSize}\uAC1C\uC529 \uCC98\uB9AC`);
    return Math.min(optimalSize, 8);
  }
  /**
   * Î™®Îç∏Î≥Ñ ÏµúÎåÄ ÏûÖÎ†• ÌÜ†ÌÅ∞ÏùÑ Í∞ÄÏ†∏ÏòµÎãàÎã§ (ÎåÄÎûµÏ†Å).
   */
  getModelMaxInputTokens(model) {
    const outputLimit = this.getModelMaxTokens(model);
    return outputLimit * 10;
  }
  /**
   * Ïò§Î•òÎì§ÏùÑ Î∞∞ÏπòÎ°ú ÎÇòÎàÑÏñ¥ Ï≤òÎ¶¨Ìï©ÎãàÎã§.
   */
  createBatches(correctionContexts, maxBatchSize = 10) {
    const batches = [];
    for (let i = 0; i < correctionContexts.length; i += maxBatchSize) {
      batches.push(correctionContexts.slice(i, i + maxBatchSize));
    }
    return batches;
  }
  /**
   * Îã®Ïùº Î∞∞ÏπòÎ•º Ï≤òÎ¶¨Ìï©ÎãàÎã§.
   */
  async processBatch(batch, batchIndex, totalBatches, client, adjustedMaxTokens, model, morphemeInfo) {
    var _a;
    Logger.debug(`\uBC30\uCE58 ${batchIndex + 1}/${totalBatches} \uCC98\uB9AC \uC911 (${batch.length}\uAC1C \uC624\uB958)`);
    const systemPrompt = AI_PROMPTS.analysisSystem;
    const userPrompt = morphemeInfo ? AI_PROMPTS.analysisUserWithMorphemes(batch, morphemeInfo) : AI_PROMPTS.analysisUserWithContext(batch);
    if (morphemeInfo) {
      Logger.debug(`\uD615\uD0DC\uC18C \uC815\uBCF4\uC640 \uD568\uAED8 AI \uBD84\uC11D \uC9C4\uD589 (\uD1A0\uD070 \uC808\uC57D \uBAA8\uB4DC)`);
      Logger.debug(`\uD615\uD0DC\uC18C \uD1A0\uD070 \uC218: ${((_a = morphemeInfo.tokens) == null ? void 0 : _a.length) || 0}\uAC1C`);
    }
    const messages = [
      { role: "system", content: systemPrompt },
      { role: "user", content: userPrompt }
    ];
    const response = await client.chat(messages, adjustedMaxTokens, model);
    Logger.debug(`\uBC30\uCE58 ${batchIndex + 1} \uC751\uB2F5 \uC218\uC2E0:`, response.substring(0, 100) + "...");
    return this.parseAIResponse(response, batch);
  }
  /**
   * AIÎ•º ÏÇ¨Ïö©ÌïòÏó¨ ÎßûÏ∂§Î≤ï Ïò§Î•òÎ•º Î∂ÑÏÑùÌïòÍ≥† ÏµúÏ†ÅÏùò ÏàòÏ†ïÏÇ¨Ìï≠ÏùÑ Ï†úÏïàÌï©ÎãàÎã§.
   * ‚≠ê NEW: ÌòïÌÉúÏÜå Ï†ïÎ≥¥ ÌÜµÌï© ÏßÄÏõê
   */
  async analyzeCorrections(request, morphemeInfo) {
    var _a, _b;
    Logger.debug("analyzeCorrections \uC2DC\uC791:", {
      enabled: this.settings.enabled,
      provider: this.settings.provider,
      model: this.settings.model,
      correctionsCount: request.corrections.length
    });
    if (morphemeInfo) {
      this.logMorphemeAnalysis(morphemeInfo, request.corrections);
    }
    if (!this.settings.enabled) {
      throw new Error("AI \uAE30\uB2A5\uC774 \uBE44\uD65C\uC131\uD654\uB418\uC5B4 \uC788\uC2B5\uB2C8\uB2E4.");
    }
    if (!await this.hasValidApiKey(this.settings)) {
      const provider = this.settings.provider;
      const keyName = provider === "openai" ? "OpenAI API \uD0A4" : provider === "anthropic" ? "Anthropic API \uD0A4" : provider === "google" ? "Google API \uD0A4" : provider === "ollama" ? "Ollama \uC5D4\uB4DC\uD3EC\uC778\uD2B8" : "API \uD0A4";
      throw new Error(`${keyName}\uAC00 \uC124\uC815\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4. \uD50C\uB7EC\uADF8\uC778 \uC124\uC815\uC5D0\uC11C ${provider} \uC81C\uACF5\uC790\uC758 ${keyName}\uB97C \uC785\uB825\uD574\uC8FC\uC138\uC694.`);
    }
    const ClientFactory = await this.getClientFactory();
    if (!this.settings.model || this.settings.model.trim() === "") {
      throw new Error(`\uBAA8\uB378\uC774 \uC124\uC815\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4. \uD50C\uB7EC\uADF8\uC778 \uC124\uC815\uC5D0\uC11C ${this.settings.provider} \uBAA8\uB378\uC744 \uC120\uD0DD\uD574\uC8FC\uC138\uC694.`);
    }
    const client = ClientFactory.createClient(this.settings);
    try {
      const allContexts = this.extractCorrectionContexts(request, morphemeInfo);
      const contextsToAnalyze = allContexts.filter(
        (ctx) => ctx.currentState !== "original-kept" && ctx.currentState !== "exception-processed"
      );
      const alreadyResolvedContexts = allContexts.filter(
        (ctx) => ctx.currentState === "original-kept" || ctx.currentState === "exception-processed"
      );
      Logger.debug(`\uBD84\uC11D \uB300\uC0C1: ${contextsToAnalyze.length}\uAC1C, \uC774\uBBF8 \uCC98\uB9AC\uB428: ${alreadyResolvedContexts.length}\uAC1C`);
      let aiResults = [];
      if (contextsToAnalyze.length > 0) {
        const maxBatchSize = this.calculateOptimalBatchSize(contextsToAnalyze, !!morphemeInfo);
        Logger.debug("\uBD84\uC11D \uC694\uCCAD \uC804\uC1A1 \uC911...", {
          provider: this.settings.provider,
          model: this.settings.model,
          totalCorrections: contextsToAnalyze.length,
          batchSize: maxBatchSize,
          estimatedBatches: Math.ceil(contextsToAnalyze.length / maxBatchSize),
          contextWindow: request.contextWindow || 50,
          maxTokens: this.settings.maxTokens,
          apiKeySet: !!this.getApiKey()
        });
        const batches = this.createBatches(contextsToAnalyze, maxBatchSize);
        Logger.debug(`${batches.length}\uAC1C \uBC30\uCE58\uB85C \uBD84\uD560\uD558\uC5EC \uCC98\uB9AC\uD569\uB2C8\uB2E4.`);
        const adjustedMaxTokens = this.adjustTokensForModel(this.settings.maxTokens, this.settings.model);
        if (morphemeInfo) {
          Logger.debug("\uD615\uD0DC\uC18C \uC815\uBCF4 \uD65C\uC6A9 AI \uBD84\uC11D \uC2DC\uC791:", {
            tokensCount: ((_a = morphemeInfo.tokens) == null ? void 0 : _a.length) || 0,
            sentences: ((_b = morphemeInfo.sentences) == null ? void 0 : _b.length) || 0,
            language: morphemeInfo.language || "unknown"
          });
        }
        for (let i = 0; i < batches.length; i++) {
          try {
            if (request.onProgress) {
              const progressMsg = morphemeInfo ? `AI + \uD615\uD0DC\uC18C \uBD84\uC11D \uC911... (${Math.round((i + 1) / batches.length * 100)}%)` : `AI \uBD84\uC11D \uC911... (${Math.round((i + 1) / batches.length * 100)}%)`;
              request.onProgress(i + 1, batches.length, progressMsg);
            }
            const batchResults = await this.processBatch(
              batches[i],
              i,
              batches.length,
              client,
              adjustedMaxTokens,
              this.settings.model,
              morphemeInfo
              // ‚≠ê NEW: ÌòïÌÉúÏÜå Ï†ïÎ≥¥ Ï†ÑÎã¨
            );
            aiResults.push(...batchResults);
            if (i < batches.length - 1) {
              await new Promise((resolve) => setTimeout(resolve, 1500));
            }
          } catch (error) {
            Logger.error(`\uBC30\uCE58 ${i + 1} \uCC98\uB9AC \uC2E4\uD328:`, error);
          }
        }
        Logger.log(`AI \uBD84\uC11D \uC644\uB8CC: ${aiResults.length}\uAC1C \uACB0\uACFC \uC218\uC9D1\uB428`);
      }
      const resolvedResults = alreadyResolvedContexts.map((ctx) => ({
        correctionIndex: ctx.correctionIndex,
        selectedValue: ctx.currentValue || ctx.original,
        isExceptionProcessed: ctx.currentState === "exception-processed",
        isOriginalKept: ctx.currentState === "original-kept",
        confidence: 100,
        reasoning: "\uC0AC\uC6A9\uC790\uAC00 \uC9C1\uC811 \uC120\uD0DD\uD55C \uD56D\uBAA9\uC785\uB2C8\uB2E4."
      }));
      const allResults = [...aiResults, ...resolvedResults];
      allResults.sort((a, b) => a.correctionIndex - b.correctionIndex);
      Logger.debug(`\uCD5C\uC885 \uCC98\uB9AC \uC644\uB8CC: ${allResults.length}\uAC1C \uACB0\uACFC \uBC18\uD658`);
      return allResults;
    } catch (error) {
      Logger.error("\uBD84\uC11D \uC911 \uC624\uB958 \uBC1C\uC0DD:", error);
      throw new Error(`AI \uBD84\uC11D \uC2E4\uD328: ${error.message}`);
    }
  }
  /**
   * AI ÏùëÎãµÏùÑ ÌååÏã±ÌïòÏó¨ Íµ¨Ï°∞ÌôîÎêú Í≤∞Í≥ºÎ°ú Î≥ÄÌôòÌï©ÎãàÎã§.
   */
  parseAIResponse(response, correctionContexts) {
    try {
      let parsedResponse;
      let cleanedResponse = response.trim();
      const codeBlockMatch = cleanedResponse.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
      if (codeBlockMatch) {
        cleanedResponse = codeBlockMatch[1].trim();
      }
      let jsonString = "";
      const jsonArrayMatch = cleanedResponse.match(/\[[\s\S]*\]/);
      if (jsonArrayMatch) {
        jsonString = jsonArrayMatch[0];
      } else {
        jsonString = cleanedResponse;
      }
      if (!jsonString.endsWith("]") && jsonString.includes("[")) {
        Logger.warn("JSON\uC774 \uC798\uB9B0 \uAC83\uC73C\uB85C \uBCF4\uC784, \uAC15\uD654\uB41C \uBCF5\uAD6C \uC2DC\uB3C4");
        let lastCompleteObjectIndex = -1;
        let braceCount = 0;
        let inString = false;
        let escapeNext = false;
        for (let i = 0; i < jsonString.length; i++) {
          const char = jsonString[i];
          if (escapeNext) {
            escapeNext = false;
            continue;
          }
          if (char === "\\") {
            escapeNext = true;
            continue;
          }
          if (char === '"') {
            inString = !inString;
            continue;
          }
          if (!inString) {
            if (char === "{") {
              braceCount++;
            } else if (char === "}") {
              braceCount--;
              if (braceCount === 0) {
                lastCompleteObjectIndex = i;
              }
            }
          }
        }
        if (lastCompleteObjectIndex > 0) {
          jsonString = jsonString.substring(0, lastCompleteObjectIndex + 1) + "]";
          Logger.debug("\uACE0\uAE09 JSON \uBCF5\uAD6C \uC644\uB8CC");
        } else {
          const lastBraceIndex = jsonString.lastIndexOf("}");
          if (lastBraceIndex > 0) {
            jsonString = jsonString.substring(0, lastBraceIndex + 1) + "]";
            Logger.debug("\uAE30\uBCF8 JSON \uBCF5\uAD6C \uC644\uB8CC");
          }
        }
      }
      Logger.debug("\uD30C\uC2F1\uD560 JSON (\uCCAB 200\uC790):", jsonString.substring(0, 200) + (jsonString.length > 200 ? "..." : ""));
      try {
        parsedResponse = JSON.parse(jsonString);
      } catch (parseError) {
        Logger.warn("\uCD08\uAE30 JSON \uD30C\uC2F1 \uC2E4\uD328, \uCD94\uAC00 \uBCF5\uAD6C \uC2DC\uB3C4:", parseError);
        let fixedJson = jsonString.replace(/,\s*$/, "");
        if (!fixedJson.endsWith("]")) {
          fixedJson += "]";
        }
        try {
          parsedResponse = JSON.parse(fixedJson);
          Logger.debug("\uC27C\uD45C \uC81C\uAC70\uB85C JSON \uBCF5\uAD6C \uC131\uACF5");
        } catch (secondError) {
          const lastCommaIndex = jsonString.lastIndexOf(",");
          if (lastCommaIndex > 0) {
            const cutJson = jsonString.substring(0, lastCommaIndex) + "]";
            try {
              parsedResponse = JSON.parse(cutJson);
              Logger.debug("\uBD88\uC644\uC804 \uAC1D\uCCB4 \uC81C\uAC70\uB85C JSON \uBCF5\uAD6C \uC131\uACF5");
            } catch (thirdError) {
              throw parseError;
            }
          } else {
            throw parseError;
          }
        }
      }
      const results = [];
      for (const item of parsedResponse) {
        const batchIndex = parseInt(item.correctionIndex);
        if (isNaN(batchIndex) || batchIndex < 0 || batchIndex >= correctionContexts.length) {
          Logger.warn("\uC720\uD6A8\uD558\uC9C0 \uC54A\uC740 batchIndex:", batchIndex);
          continue;
        }
        const context = correctionContexts[batchIndex];
        const originalCorrectionIndex = context.correctionIndex;
        let selectedValue = item.selectedValue || "";
        const validOptions = [...context.corrected, context.original];
        Logger.debug(`AI \uC120\uD0DD \uBD84\uC11D - \uC624\uB958 "${context.original}":`);
        Logger.debug(`  AI \uC120\uD0DD\uAC12: "${selectedValue}"`);
        Logger.debug(`  \uC720\uD6A8\uD55C \uC635\uC158\uB4E4: [${validOptions.map((opt) => `"${opt}"`).join(", ")}]`);
        Logger.debug(`  \uCD94\uCC9C \uC774\uC720: "${item.reasoning}"`);
        if (!validOptions.includes(selectedValue)) {
          Logger.warn(`\u{1F534} AI\uAC00 \uC720\uD6A8\uD558\uC9C0 \uC54A\uC740 \uAC12\uC744 \uC120\uD0DD\uD588\uC2B5\uB2C8\uB2E4: "${selectedValue}"`);
          if (selectedValue === "\uC6D0\uBCF8\uC720\uC9C0" || selectedValue === "\uC608\uC678\uCC98\uB9AC" || !selectedValue) {
            selectedValue = context.original;
            Logger.debug(`"${item.selectedValue}"\uB97C \uC6D0\uBCF8 "${context.original}"\uB85C \uBCC0\uACBD`);
          } else {
            const matchedOption = this.findBestMatch(selectedValue, validOptions);
            if (matchedOption) {
              Logger.warn(`\u26A0\uFE0F AI \uC120\uD0DD \uBD88\uC77C\uCE58: "${selectedValue}" \u2192 "${matchedOption}" (\uC790\uB3D9 \uB9E4\uCE6D)`);
              selectedValue = matchedOption;
            } else {
              Logger.error(`\u274C \uB9E4\uCE6D \uC2E4\uD328 - \uC6D0\uBCF8\uC73C\uB85C \uB300\uCCB4: "${selectedValue}" \u2192 "${context.original}"`);
              selectedValue = context.original;
            }
          }
        } else {
          Logger.debug(`\u2705 AI \uC120\uD0DD\uAC12\uC774 \uC720\uD6A8\uD568: "${selectedValue}"`);
        }
        const isOriginalSelected = selectedValue === context.original;
        const isOriginalKept = isOriginalSelected && !item.isExceptionProcessed;
        results.push({
          correctionIndex: originalCorrectionIndex,
          selectedValue,
          isExceptionProcessed: item.isExceptionProcessed || false,
          isOriginalKept,
          confidence: Math.max(0, Math.min(100, parseInt(item.confidence) || 0)),
          reasoning: item.reasoning || "\uC774\uC720\uAC00 \uC81C\uACF5\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4."
        });
      }
      Logger.debug(`\uD30C\uC2F1 \uC644\uB8CC: ${results.length}\uAC1C\uC758 \uACB0\uACFC \uCD94\uCD9C\uB428`);
      const processedIndexes = new Set(results.map((r) => r.correctionIndex));
      const missingContexts = correctionContexts.filter((ctx) => !processedIndexes.has(ctx.correctionIndex));
      if (missingContexts.length > 0) {
        Logger.warn(`\uB204\uB77D\uB41C \uC624\uB958\uB4E4 (\uC6D0\uBCF8 \uC778\uB371\uC2A4): ${missingContexts.map((c) => c.correctionIndex).join(", ")}`);
        missingContexts.forEach((context) => {
          const defaultValue = context.corrected[0] || context.original;
          const isDefaultOriginal = defaultValue === context.original;
          results.push({
            correctionIndex: context.correctionIndex,
            selectedValue: defaultValue,
            isExceptionProcessed: false,
            isOriginalKept: isDefaultOriginal,
            confidence: 50,
            reasoning: "AI \uBD84\uC11D\uC5D0\uC11C \uB204\uB77D\uB418\uC5B4 \uAE30\uBCF8\uAC12\uC73C\uB85C \uC124\uC815\uB428"
          });
        });
        results.sort((a, b) => a.correctionIndex - b.correctionIndex);
      }
      return results;
    } catch (error) {
      Logger.error("\uC751\uB2F5 \uD30C\uC2F1 \uC624\uB958:", error);
      Logger.error("\uC6D0\uBCF8 \uC751\uB2F5 (\uCCAB 500\uC790):", response.substring(0, 500));
      if (error instanceof SyntaxError) {
        throw new Error(`JSON \uD615\uC2DD \uC624\uB958: ${error.message}. AI \uC751\uB2F5\uC774 \uC62C\uBC14\uB978 JSON \uD615\uC2DD\uC774 \uC544\uB2D9\uB2C8\uB2E4.`);
      } else {
        throw new Error(`AI \uC751\uB2F5 \uD30C\uC2F1 \uC2E4\uD328: ${error.message}`);
      }
    }
  }
  /**
   * ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Î™®Îç∏ Î™©Î°ùÏùÑ Í∞ÄÏ†∏ÏòµÎãàÎã§.
   */
  async fetchAvailableModels() {
    try {
      const ClientFactory = await this.getClientFactory();
      return await ClientFactory.fetchModels(this.settings);
    } catch (error) {
      Logger.error("\uBAA8\uB378 \uBAA9\uB85D \uAC00\uC838\uC624\uAE30 \uC2E4\uD328:", error);
      return [];
    }
  }
  /**
   * AI ÏÑ§Ï†ïÏùÑ ÏóÖÎç∞Ïù¥Ìä∏Ìï©ÎãàÎã§.
   */
  updateSettings(newSettings) {
    this.settings = newSettings;
  }
  /**
   * AI ÏÑúÎπÑÏä§Í∞Ä ÏÇ¨Ïö© Í∞ÄÎä•ÌïúÏßÄ ÌôïÏù∏Ìï©ÎãàÎã§.
   */
  async isAvailable() {
    return this.settings.enabled && await this.hasValidApiKey(this.settings);
  }
  /**
   * ÌòÑÏû¨ ÏÑ§Ï†ïÎêú Ï†úÍ≥µÏûê Î∞è Î™®Îç∏ Ï†ïÎ≥¥Î•º Î∞òÌôòÌï©ÎãàÎã§.
   */
  getProviderInfo() {
    return {
      provider: this.settings.provider,
      model: this.settings.model,
      available: this.settings.enabled
      // Í∏∞Î≥∏Ï†ÅÏù∏ ÌôúÏÑ±Ìôî ÏÉÅÌÉúÎßå Ï≤¥ÌÅ¨
    };
  }
  /**
   * ÌòÑÏû¨ AI ÏÑ§Ï†ïÏùÑ Î∞òÌôòÌï©ÎãàÎã§.
   */
  getSettings() {
    return this.settings;
  }
  /**
   * Î™®Îç∏Î≥Ñ ÏµúÎåÄ Ï∂úÎ†• ÌÜ†ÌÅ∞ÏùÑ Í∞ÄÏ†∏ÏòµÎãàÎã§.
   */
  getModelMaxTokens(model) {
    return MODEL_TOKEN_LIMITS[model] || 2048;
  }
  /**
   * ÏöîÏ≤≠Ìï† ÌÜ†ÌÅ∞ ÏàòÎ•º Î™®Îç∏ Ï†úÌïúÏóê ÎßûÍ≤å Ï°∞Ï†ïÌï©ÎãàÎã§.
   */
  adjustTokensForModel(requestedTokens, model) {
    const modelLimit = this.getModelMaxTokens(model);
    if (requestedTokens > modelLimit) {
      Logger.warn(`\uC694\uCCAD\uB41C \uD1A0\uD070 \uC218(${requestedTokens})\uAC00 \uBAA8\uB378 \uC81C\uD55C(${modelLimit})\uC744 \uCD08\uACFC\uD569\uB2C8\uB2E4. ${modelLimit}\uB85C \uC870\uC815\uD569\uB2C8\uB2E4.`);
      return modelLimit;
    }
    return requestedTokens;
  }
  /**
   * ÌòÑÏû¨ Ï†úÍ≥µÏûêÏùò API ÌÇ§Î•º Î∞òÌôòÌï©ÎãàÎã§.
   */
  getApiKey() {
    switch (this.settings.provider) {
      case "openai":
        return this.settings.openaiApiKey;
      case "anthropic":
        return this.settings.anthropicApiKey;
      case "google":
        return this.settings.googleApiKey;
      case "ollama":
        return this.settings.ollamaEndpoint;
      default:
        return "";
    }
  }
  /**
   * AIÍ∞Ä Î∞òÌôòÌïú Í∞íÍ≥º Í∞ÄÏû• Ïú†ÏÇ¨Ìïú Ïú†Ìö®Ìïú ÏòµÏÖòÏùÑ Ï∞æÏäµÎãàÎã§.
   */
  findBestMatch(aiValue, validOptions) {
    if (validOptions.includes(aiValue)) {
      return aiValue;
    }
    const cleanAiValue = aiValue.replace(/[\s\*\~\-\+\[\]]/g, "");
    for (const option of validOptions) {
      const cleanOption = option.replace(/[\s\*\~\-\+\[\]]/g, "");
      if (cleanAiValue === cleanOption) {
        return option;
      }
      if (cleanAiValue.includes(cleanOption) || cleanOption.includes(cleanAiValue)) {
        return option;
      }
    }
    let bestMatch = null;
    let bestScore = Infinity;
    for (const option of validOptions) {
      const distance = this.levenshteinDistance(aiValue, option);
      const similarity = 1 - distance / Math.max(aiValue.length, option.length);
      if (similarity >= 0.7 && distance < bestScore) {
        bestMatch = option;
        bestScore = distance;
      }
    }
    return bestMatch;
  }
  /**
   * Îëê Î¨∏ÏûêÏó¥ Í∞ÑÏùò Ìé∏Ïßë Í±∞Î¶¨Î•º Í≥ÑÏÇ∞Ìï©ÎãàÎã§.
   */
  levenshteinDistance(str1, str2) {
    const matrix = [];
    const n = str2.length;
    const m = str1.length;
    if (n === 0)
      return m;
    if (m === 0)
      return n;
    for (let i = 0; i <= n; i++) {
      matrix[i] = [i];
    }
    for (let j = 0; j <= m; j++) {
      matrix[0][j] = j;
    }
    for (let i = 1; i <= n; i++) {
      for (let j = 1; j <= m; j++) {
        if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
          matrix[i][j] = matrix[i - 1][j - 1];
        } else {
          matrix[i][j] = Math.min(
            matrix[i - 1][j - 1] + 1,
            matrix[i][j - 1] + 1,
            matrix[i - 1][j] + 1
          );
        }
      }
    }
    return matrix[n][m];
  }
};

// src/ui/loadingManager.ts
var import_obsidian7 = require("obsidian");
init_logger();
var _LoadingManager = class {
  constructor() {
    this.currentState = "idle";
    this.currentNotice = null;
    this.progressElement = null;
    this.startTime = 0;
    this.currentStep = 0;
    this.steps = [];
    // Í∏∞Î≥∏ Î°úÎî© Îã®Í≥ÑÎì§
    this.defaultSteps = [
      {
        id: "text_analysis",
        title: "\uD14D\uC2A4\uD2B8 \uBD84\uC11D",
        description: "\uC785\uB825\uB41C \uD14D\uC2A4\uD2B8\uB97C \uCC98\uB9AC\uD558\uACE0 \uBD84\uC11D\uD569\uB2C8\uB2E4",
        estimatedDuration: 1e3,
        icon: "\u{1F4DD}"
      },
      {
        id: "api_request",
        title: "API \uC694\uCCAD",
        description: "Bareun.ai \uC11C\uBC84\uC5D0 \uB9DE\uCDA4\uBC95 \uAC80\uC0AC\uB97C \uC694\uCCAD\uD569\uB2C8\uB2E4",
        estimatedDuration: 3e3,
        icon: "\u{1F310}"
      },
      {
        id: "result_parsing",
        title: "\uACB0\uACFC \uCC98\uB9AC",
        description: "\uAC80\uC0AC \uACB0\uACFC\uB97C \uBD84\uC11D\uD558\uACE0 \uC624\uB958\uB97C \uBD84\uB958\uD569\uB2C8\uB2E4",
        estimatedDuration: 800,
        icon: "\u2699\uFE0F"
      },
      {
        id: "ui_preparation",
        title: "UI \uC900\uBE44",
        description: "\uAD50\uC815 \uC778\uD130\uD398\uC774\uC2A4\uB97C \uC900\uBE44\uD569\uB2C8\uB2E4",
        estimatedDuration: 500,
        icon: "\u{1F3A8}"
      }
    ];
    this.aiSteps = [
      {
        id: "ai_context_preparation",
        title: "AI \uCEE8\uD14D\uC2A4\uD2B8 \uC900\uBE44",
        description: "\uB9DE\uCDA4\uBC95 \uC624\uB958\uC640 \uC8FC\uBCC0 \uB9E5\uB77D\uC744 AI\uC5D0\uAC8C \uC81C\uACF5\uD560 \uD615\uD0DC\uB85C \uAC00\uACF5\uD569\uB2C8\uB2E4",
        estimatedDuration: 500,
        icon: "\u{1F916}"
      },
      {
        id: "ai_analysis",
        title: "AI \uBD84\uC11D",
        description: "AI\uAC00 \uCD5C\uC801\uC758 \uC218\uC815\uC0AC\uD56D\uC744 \uBD84\uC11D\uD558\uACE0 \uC788\uC2B5\uB2C8\uB2E4",
        estimatedDuration: 5e3,
        icon: "\u{1F9E0}"
      },
      {
        id: "ai_result_processing",
        title: "AI \uACB0\uACFC \uCC98\uB9AC",
        description: "AI \uBD84\uC11D \uACB0\uACFC\uB97C \uAC80\uC99D\uD558\uACE0 \uC801\uC6A9\uD569\uB2C8\uB2E4",
        estimatedDuration: 800,
        icon: "\u2728"
      }
    ];
    Logger.debug("LoadingManager \uCD08\uAE30\uD654");
  }
  /**
   * Ïã±Í∏ÄÌÜ§ Ïù∏Ïä§ÌÑ¥Ïä§ Î∞òÌôò
   */
  static getInstance() {
    if (!_LoadingManager.instance) {
      _LoadingManager.instance = new _LoadingManager();
    }
    return _LoadingManager.instance;
  }
  /**
   * ÏÉÅÌÉú Î≥ÄÍ≤Ω ÏΩúÎ∞± Îì±Î°ù
   */
  onStateChange(callback) {
    this.onStateChangeCallback = callback;
  }
  /**
   * Î°úÎî© ÏãúÏûë (Í∏∞Î≥∏ ÎßûÏ∂§Î≤ï Í≤ÄÏÇ¨)
   */
  startLoading(includeAI = false) {
    this.steps = includeAI ? [...this.defaultSteps, ...this.aiSteps] : [...this.defaultSteps];
    this.currentState = "analyzing";
    this.currentStep = 0;
    this.startTime = Date.now();
    Logger.debug("\uB85C\uB529 \uC2DC\uC791:", { includeAI, totalSteps: this.steps.length });
    this.showProgressNotice();
    this.updateProgress();
  }
  /**
   * Îã§Ïùå Îã®Í≥ÑÎ°ú ÏßÑÌñâ
   */
  nextStep() {
    if (this.currentStep < this.steps.length - 1) {
      this.currentStep++;
      this.updateProgress();
      Logger.debug(`\uB2E8\uACC4 \uC9C4\uD589: ${this.currentStep + 1}/${this.steps.length}`, {
        currentStep: this.steps[this.currentStep]
      });
    }
  }
  /**
   * ÌäπÏ†ï Îã®Í≥ÑÎ°ú Ï†êÌîÑ
   */
  setStep(stepId) {
    const stepIndex = this.steps.findIndex((step) => step.id === stepId);
    if (stepIndex !== -1) {
      this.currentStep = stepIndex;
      this.updateProgress();
      Logger.debug("\uB2E8\uACC4 \uC124\uC815:", { stepId, stepIndex });
    }
  }
  /**
   * Î°úÎî© ÏôÑÎ£å
   */
  complete() {
    this.currentState = "idle";
    this.hideNotice();
    const totalTime = Date.now() - this.startTime;
    Logger.debug("\uB85C\uB529 \uC644\uB8CC:", { totalTime: `${totalTime}ms` });
    if (this.onStateChangeCallback) {
      this.onStateChangeCallback("idle");
    }
  }
  /**
   * ÏóêÎü¨ ÏÉÅÌÉúÎ°ú Î≥ÄÍ≤Ω
   */
  error(message) {
    this.currentState = "error";
    this.hideNotice();
    new import_obsidian7.Notice(`\u274C ${message}`, 5e3);
    Logger.error("\uB85C\uB529 \uC5D0\uB7EC:", { message });
    if (this.onStateChangeCallback) {
      this.onStateChangeCallback("error");
    }
  }
  /**
   * ÌòÑÏû¨ ÏÉÅÌÉú Î∞òÌôò
   */
  getState() {
    return this.currentState;
  }
  /**
   * ÏßÑÌñâÎ•† Ï†ïÎ≥¥ Î∞òÌôò
   */
  getProgress() {
    const elapsedTime = Date.now() - this.startTime;
    const currentStepInfo = this.steps[this.currentStep];
    const totalEstimatedTime = this.steps.reduce((sum, step) => sum + step.estimatedDuration, 0);
    const completedTime = this.steps.slice(0, this.currentStep).reduce((sum, step) => sum + step.estimatedDuration, 0);
    const currentStepProgress = Math.min(elapsedTime - completedTime, (currentStepInfo == null ? void 0 : currentStepInfo.estimatedDuration) || 0);
    const totalProgress = completedTime + currentStepProgress;
    const percentage = Math.min(95, Math.round(totalProgress / totalEstimatedTime * 100));
    const estimatedRemaining = Math.max(0, totalEstimatedTime - totalProgress);
    return {
      currentStep: this.currentStep + 1,
      totalSteps: this.steps.length,
      percentage,
      message: (currentStepInfo == null ? void 0 : currentStepInfo.description) || "\uCC98\uB9AC \uC911...",
      elapsedTime,
      estimatedRemaining
    };
  }
  /**
   * ÏàòÎèôÏúºÎ°ú ÏßÑÌñâÎ•† ÏóÖÎç∞Ïù¥Ìä∏
   */
  setCustomProgress(percentage, message) {
    if (this.progressElement) {
      this.updateProgressDisplay(percentage, message);
    }
  }
  /**
   * Î°úÎî© Ï∑®ÏÜå
   */
  cancel() {
    this.currentState = "idle";
    this.hideNotice();
    Logger.debug("\uB85C\uB529 \uCDE8\uC18C\uB428");
    if (this.onStateChangeCallback) {
      this.onStateChangeCallback("idle");
    }
  }
  /**
   * Ïª¥Ìå©Ìä∏Ìïú ÌÜ†Ïä§Ìä∏ Ïä§ÌÉÄÏùº ÏßÑÌñâÎ•† ÌëúÏãú ÏÉùÏÑ±
   */
  showProgressNotice() {
    this.hideNotice();
    const toastContainer = document.body.createEl("div", {
      cls: "spell-check-toast",
      attr: {
        style: `
          position: fixed;
          bottom: 20px;
          right: 20px;
          min-width: 280px;
          max-width: 320px;
          background: var(--background-primary);
          border: 1px solid var(--background-modifier-border);
          border-radius: 8px;
          padding: 12px 16px;
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
          z-index: 1000;
          font-family: var(--font-interface);
          font-size: 13px;
          animation: slideInUp 0.3s ease-out;
        `
      }
    });
    if (!document.querySelector("#spell-check-toast-styles")) {
      const style = document.head.createEl("style", { attr: { id: "spell-check-toast-styles" } });
      style.textContent = `
        @keyframes slideInUp {
          from {
            transform: translateY(100%);
            opacity: 0;
          }
          to {
            transform: translateY(0);
            opacity: 1;
          }
        }
        @keyframes slideOutDown {
          from {
            transform: translateY(0);
            opacity: 1;
          }
          to {
            transform: translateY(100%);
            opacity: 0;
          }
        }
      `;
    }
    this.progressElement = toastContainer;
    this.currentNotice = {
      hide: () => {
        toastContainer.style.animation = "slideOutDown 0.2s ease-in";
        setTimeout(() => {
          toastContainer.remove();
        }, 200);
      }
    };
  }
  /**
   * ÏßÑÌñâÎ•† ÏóÖÎç∞Ïù¥Ìä∏
   */
  updateProgress() {
    if (!this.progressElement)
      return;
    const progress = this.getProgress();
    this.updateProgressDisplay(progress.percentage, progress.message);
    if (this.onStateChangeCallback) {
      this.onStateChangeCallback(this.currentState, progress);
    }
  }
  /**
   * Ïª¥Ìå©Ìä∏Ìïú ÏßÑÌñâÎ•† ÎîîÏä§ÌîåÎ†àÏù¥ ÏóÖÎç∞Ïù¥Ìä∏
   */
  updateProgressDisplay(percentage, message) {
    if (!this.progressElement)
      return;
    const currentStepInfo = this.steps[this.currentStep];
    const progress = this.getProgress();
    this.progressElement.empty();
    const header = this.progressElement.createEl("div", {
      attr: {
        style: "display: flex; align-items: center; margin-bottom: 8px;"
      }
    });
    header.createEl("span", {
      text: (currentStepInfo == null ? void 0 : currentStepInfo.icon) || "\u23F3",
      attr: { style: "font-size: 16px; margin-right: 8px;" }
    });
    const titleContainer = header.createEl("div", {
      attr: { style: "flex: 1;" }
    });
    titleContainer.createEl("div", {
      text: (currentStepInfo == null ? void 0 : currentStepInfo.title) || "\uCC98\uB9AC \uC911",
      attr: { style: "font-weight: 500; font-size: 13px; line-height: 1.2;" }
    });
    const progressBarContainer = this.progressElement.createEl("div", {
      attr: {
        style: "background: var(--background-modifier-border); border-radius: 6px; height: 4px; overflow: hidden; margin-bottom: 6px;"
      }
    });
    progressBarContainer.createEl("div", {
      attr: {
        style: `
          background: var(--interactive-accent);
          height: 100%;
          width: ${percentage}%;
          transition: width 0.3s ease;
          border-radius: 6px;
        `
      }
    });
    const footer = this.progressElement.createEl("div", {
      attr: {
        style: "display: flex; justify-content: space-between; font-size: 11px; color: var(--text-muted); line-height: 1;"
      }
    });
    footer.createEl("span", { text: `${percentage}%` });
    footer.createEl("span", { text: `${progress.currentStep}/${progress.totalSteps}` });
  }
  /**
   * Notice Ïà®Í∏∞Í∏∞
   */
  hideNotice() {
    if (this.currentNotice) {
      this.currentNotice.hide();
      this.currentNotice = null;
      this.progressElement = null;
    }
  }
  /**
   * Î¶¨ÏÜåÏä§ Ï†ïÎ¶¨
   */
  static destroy() {
    if (_LoadingManager.instance) {
      _LoadingManager.instance.hideNotice();
      _LoadingManager.instance = null;
      Logger.debug("LoadingManager \uC815\uB9AC\uB428");
    }
  }
};
var LoadingManager = _LoadingManager;
LoadingManager.instance = null;

// src/orchestrator.ts
init_logger();
var SpellCheckOrchestrator = class {
  constructor(app, settings, onSettingsUpdated) {
    this.app = app;
    this.settings = settings;
    this.apiService = new OptimizedSpellCheckService(
      5,
      // maxBatchSize
      2e3,
      // batchTimeoutMs  
      15e3,
      // requestTimeoutMs
      3,
      // maxConcurrentBatches
      {
        maxSize: 1e3,
        // Ï∫êÏãú ÏµúÎåÄ 1000Í∞ú
        ttlMinutes: 30,
        // 30Î∂Ñ TTL
        cleanupIntervalMinutes: 5
        // 5Î∂ÑÎßàÎã§ Ï†ïÎ¶¨
      }
    );
    this.aiService = new AIAnalysisService(settings.ai);
    this.onSettingsUpdated = onSettingsUpdated;
  }
  /**
   * ÎßûÏ∂§Î≤ï Í≤ÄÏÇ¨Î•º Ïã§ÌñâÌï©ÎãàÎã§.
   */
  async execute() {
    var _a;
    try {
      const { editor, selectedText, selectionStart, selectionEnd, file } = this.getEditorInfo();
      if (!selectedText || selectedText.trim().length === 0) {
        new import_obsidian8.Notice("\uAC80\uC0AC\uD560 \uD14D\uC2A4\uD2B8\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.");
        return;
      }
      const validation = SettingsService.validateSettings(this.settings);
      if (!validation.isValid) {
        new import_obsidian8.Notice(`\uC124\uC815 \uC624\uB958: ${validation.errors.join(", ")}`);
        return;
      }
      const loadingManager = LoadingManager.getInstance();
      loadingManager.startLoading(false);
      try {
        loadingManager.setStep("text_analysis");
        await this.sleep(300);
        loadingManager.setStep("api_request");
        const priority = selectedText.length > 1e3 ? "medium" : "high";
        const result = await this.apiService.checkSpelling(selectedText, this.settings, priority);
        let morphemeInfo = null;
        if (result.corrections && result.corrections.length > 0) {
          try {
            Logger.log("\uD615\uD0DC\uC18C \uBD84\uC11D \uC218\uD589 \uC911...");
            morphemeInfo = await this.apiService.analyzeMorphemes(selectedText, this.settings);
            Logger.log("\uD615\uD0DC\uC18C \uBD84\uC11D \uC644\uB8CC:", {
              hasMorphemeInfo: !!morphemeInfo,
              sentences: ((_a = morphemeInfo == null ? void 0 : morphemeInfo.sentences) == null ? void 0 : _a.length) || 0
            });
            if (result.corrections.length > 1) {
              Logger.log("\uD615\uD0DC\uC18C \uAE30\uBC18 \uAD50\uC815 \uAC1C\uC120 \uC218\uD589...");
              result.corrections = await this.apiService.improveCorrectionsWithMorphemeData(
                selectedText,
                result.corrections,
                this.settings,
                morphemeInfo
              );
              Logger.log(`\uAD50\uC815 \uAC1C\uC120 \uC644\uB8CC: ${result.corrections.length}\uAC1C \uC624\uB958`);
            }
          } catch (morphemeError) {
            Logger.warn("\uD615\uD0DC\uC18C \uBD84\uC11D \uC2E4\uD328, \uC6D0\uBCF8 \uAD50\uC815 \uBC0F \uD328\uD134 \uB9E4\uCE6D \uC0AC\uC6A9:", morphemeError);
            morphemeInfo = null;
          }
        }
        loadingManager.setStep("result_parsing");
        await this.sleep(200);
        loadingManager.setStep("ui_preparation");
        await this.sleep(100);
        loadingManager.complete();
        this.handleSpellCheckResult(result, selectedText, selectionStart, selectionEnd, editor, file, morphemeInfo);
      } catch (error) {
        loadingManager.error("\uB9DE\uCDA4\uBC95 \uAC80\uC0AC \uC911 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4");
        Logger.error("\uB9DE\uCDA4\uBC95 \uAC80\uC0AC \uC2E4\uD589 \uC624\uB958:", error);
      }
    } catch (error) {
      Logger.error("Spell check orchestrator error:", error);
      new import_obsidian8.Notice(`\uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4: ${error.message}`);
    }
  }
  /**
   * ÏóêÎîîÌÑ∞ Ï†ïÎ≥¥Î•º Í∞ÄÏ†∏ÏòµÎãàÎã§.
   */
  getEditorInfo() {
    const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian8.MarkdownView);
    const editor = markdownView == null ? void 0 : markdownView.editor;
    const file = markdownView == null ? void 0 : markdownView.file;
    if (!editor) {
      throw new Error("\uC5D0\uB514\uD130\uB97C \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
    }
    let selectedText = editor.getSelection();
    let selectionStart = editor.getCursor("from");
    let selectionEnd = editor.getCursor("to");
    if (!selectedText || selectedText.trim().length === 0) {
      const fullText = editor.getValue();
      if (!fullText || fullText.trim().length === 0) {
        throw new Error("\uBB38\uC11C\uC5D0 \uD14D\uC2A4\uD2B8\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.");
      }
      selectedText = fullText;
      try {
        const totalLines = editor.lineCount();
        const lastLine = totalLines - 1;
        const lastLineText = editor.getLine(lastLine);
        selectionStart = { line: 0, ch: 0 };
        selectionEnd = { line: lastLine, ch: lastLineText.length };
      } catch (error) {
        Logger.warn("Failed to get document bounds using API methods, using fallback:", error);
        const lines = selectedText.split("\n");
        selectionStart = { line: 0, ch: 0 };
        selectionEnd = { line: lines.length - 1, ch: lines[lines.length - 1].length };
      }
    }
    return { editor, selectedText, selectionStart, selectionEnd, file };
  }
  /**
   * ÎßûÏ∂§Î≤ï Í≤ÄÏÇ¨ Í≤∞Í≥ºÎ•º Ï≤òÎ¶¨Ìï©ÎãàÎã§.
   */
  handleSpellCheckResult(result, selectedText, selectionStart, selectionEnd, editor, file, morphemeInfo) {
    if (result.corrections.length === 0) {
      new import_obsidian8.Notice("\uC218\uC815\uD560 \uAC83\uC774 \uC5C6\uC2B5\uB2C8\uB2E4. \uD6CC\uB96D\uD569\uB2C8\uB2E4!");
      return;
    }
    const cleanedText = selectedText.trim();
    Logger.debug("handleSpellCheckResult \uD14D\uC2A4\uD2B8 \uC815\uB9AC:", {
      originalLength: selectedText.length,
      cleanedLength: cleanedText.length,
      correctionsCount: result.corrections.length
    });
    const popup = new CorrectionPopup(this.app, {
      corrections: result.corrections,
      selectedText: cleanedText,
      start: selectionStart,
      end: selectionEnd,
      editor,
      file,
      // ‚≠ê NEW: File Ïù∏Ïä§ÌÑ¥Ïä§ Ï†ÑÎã¨ (Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ï†ïÎ≥¥Ïö©)
      morphemeInfo,
      // ‚≠ê NEW: ÌòïÌÉúÏÜå Î∂ÑÏÑù Ï†ïÎ≥¥ Ï†ÑÎã¨ (AI Î∂ÑÏÑùÏö©)
      ignoredWords: IgnoredWordsService.getIgnoredWords(this.settings),
      onExceptionWordsAdded: (words) => this.handleExceptionWords(words)
    }, this.aiService, (newMaxTokens) => this.handleMaxTokensUpdate(newMaxTokens));
    popup.render();
    popup.show();
  }
  /**
   * API Ïò§Î•òÎ•º Ï≤òÎ¶¨Ìï©ÎãàÎã§.
   */
  handleApiError(error) {
    var _a, _b, _c;
    Logger.error("API Error:", error);
    if ((_a = error.message) == null ? void 0 : _a.includes("API \uD0A4")) {
      new import_obsidian8.Notice("API \uD0A4\uAC00 \uC124\uC815\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4. \uD50C\uB7EC\uADF8\uC778 \uC124\uC815\uC5D0\uC11C Bareun.ai API \uD0A4\uB97C \uC785\uB825\uD574\uC8FC\uC138\uC694.");
    } else if ((_b = error.message) == null ? void 0 : _b.includes("API \uC694\uCCAD \uC2E4\uD328")) {
      new import_obsidian8.Notice(`API \uC694\uCCAD\uC5D0 \uC2E4\uD328\uD588\uC2B5\uB2C8\uB2E4: ${error.message}`);
    } else if ((_c = error.message) == null ? void 0 : _c.includes("\uB124\uD2B8\uC6CC\uD06C")) {
      new import_obsidian8.Notice("\uB124\uD2B8\uC6CC\uD06C \uC5F0\uACB0\uC744 \uD655\uC778\uD574\uC8FC\uC138\uC694.");
    } else {
      new import_obsidian8.Notice(`\uB9DE\uCDA4\uBC95 \uAC80\uC0AC \uC911 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4: ${error.message}`);
    }
  }
  /**
   * ÏòàÏô∏ Ï≤òÎ¶¨Îêú Îã®Ïñ¥Îì§ÏùÑ ÏÑ§Ï†ïÏóê Ï∂îÍ∞ÄÌï©ÎãàÎã§.
   */
  handleExceptionWords(words) {
    if (words.length === 0)
      return;
    const updatedSettings = IgnoredWordsService.addMultipleIgnoredWords(words, this.settings);
    if (updatedSettings.ignoredWords.length > this.settings.ignoredWords.length) {
      this.settings = updatedSettings;
      if (this.onSettingsUpdated) {
        this.onSettingsUpdated(this.settings);
      }
      const addedCount = updatedSettings.ignoredWords.length - this.settings.ignoredWords.length + words.length;
      new import_obsidian8.Notice(`${words.length}\uAC1C\uC758 \uB2E8\uC5B4\uAC00 \uC608\uC678 \uCC98\uB9AC \uBAA9\uB85D\uC5D0 \uCD94\uAC00\uB418\uC5C8\uC2B5\uB2C8\uB2E4.`);
    }
  }
  /**
   * ÏÑ§Ï†ïÏùÑ ÏóÖÎç∞Ïù¥Ìä∏Ìï©ÎãàÎã§.
   */
  updateSettings(newSettings) {
    this.settings = newSettings;
    this.aiService.updateSettings(newSettings.ai);
  }
  /**
   * API ÏÑúÎπÑÏä§ ÏÑ±Îä• Î©îÌä∏Î¶≠ÏùÑ Î∞òÌôòÌï©ÎãàÎã§.
   */
  getPerformanceMetrics() {
    return this.apiService.getMetrics();
  }
  /**
   * Ï∫êÏãúÎ•º ÏàòÎèôÏúºÎ°ú Ï†ïÎ¶¨Ìï©ÎãàÎã§.
   */
  clearCache() {
    this.apiService.clearCache();
    new import_obsidian8.Notice("\uCE90\uC2DC\uAC00 \uC815\uB9AC\uB418\uC5C8\uC2B5\uB2C8\uB2E4.");
  }
  /**
   * ÎåÄÍ∏∞ Ï§ëÏù∏ Î™®Îì† ÏöîÏ≤≠ÏùÑ Ï∑®ÏÜåÌï©ÎãàÎã§.
   */
  cancelPendingRequests() {
    this.apiService.cancelPendingRequests();
    new import_obsidian8.Notice("\uB300\uAE30 \uC911\uC778 \uC694\uCCAD\uB4E4\uC774 \uCDE8\uC18C\uB418\uC5C8\uC2B5\uB2C8\uB2E4.");
  }
  /**
   * Ïò§ÏºÄÏä§Ìä∏Î†àÏù¥ÌÑ∞Î•º Ï¢ÖÎ£åÌïòÍ≥† Î¶¨ÏÜåÏä§Î•º Ï†ïÎ¶¨Ìï©ÎãàÎã§.
   */
  destroy() {
    this.apiService.destroy();
    LoadingManager.destroy();
  }
  /**
   * ÎπÑÎèôÍ∏∞ ÎåÄÍ∏∞ Ìó¨Ìçº Ìï®Ïàò
   */
  sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  /**
   * ÌòÑÏû¨ Î¨∏Îã®Ïùò ÎßûÏ∂§Î≤ïÏùÑ Í≤ÄÏÇ¨Ìï©ÎãàÎã§.
   */
  async executeCurrentParagraph() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian8.MarkdownView);
    if (!activeView) {
      new import_obsidian8.Notice("\uD65C\uC131\uD654\uB41C \uB9C8\uD06C\uB2E4\uC6B4 \uD3B8\uC9D1\uAE30\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.");
      return;
    }
    const editor = activeView.editor;
    if (!editor) {
      new import_obsidian8.Notice("\uD3B8\uC9D1\uAE30\uC5D0 \uC811\uADFC\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
      return;
    }
    try {
      const paragraphData = getCurrentParagraph(editor);
      const selectedText = paragraphData.text.trim();
      if (!selectedText) {
        new import_obsidian8.Notice("\uD604\uC7AC \uBB38\uB2E8\uC5D0 \uAC80\uC0AC\uD560 \uD14D\uC2A4\uD2B8\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.");
        return;
      }
      Logger.debug(`\uD604\uC7AC \uBB38\uB2E8 \uB9DE\uCDA4\uBC95 \uAC80\uC0AC \uC2DC\uC791: ${selectedText.length}\uC790`);
      await this.performSpellCheck(selectedText, editor, paragraphData.from, paragraphData.to);
    } catch (error) {
      Logger.error("\uD604\uC7AC \uBB38\uB2E8 \uB9DE\uCDA4\uBC95 \uAC80\uC0AC \uC911 \uC624\uB958 \uBC1C\uC0DD:", error);
      new import_obsidian8.Notice(`\uD604\uC7AC \uBB38\uB2E8 \uB9DE\uCDA4\uBC95 \uAC80\uC0AC \uC911 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4: ${error.message}`);
    }
  }
  /**
   * ÌòÑÏû¨ Îã®Ïñ¥Ïùò ÎßûÏ∂§Î≤ïÏùÑ Í≤ÄÏÇ¨Ìï©ÎãàÎã§.
   */
  async executeCurrentWord() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian8.MarkdownView);
    if (!activeView) {
      new import_obsidian8.Notice("\uD65C\uC131\uD654\uB41C \uB9C8\uD06C\uB2E4\uC6B4 \uD3B8\uC9D1\uAE30\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.");
      return;
    }
    const editor = activeView.editor;
    if (!editor) {
      new import_obsidian8.Notice("\uD3B8\uC9D1\uAE30\uC5D0 \uC811\uADFC\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
      return;
    }
    try {
      const wordData = getCurrentWord(editor);
      if (!wordData) {
        new import_obsidian8.Notice("\uD604\uC7AC \uC704\uCE58\uC5D0 \uAC80\uC0AC\uD560 \uB2E8\uC5B4\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.");
        return;
      }
      const selectedText = wordData.text.trim();
      if (!selectedText) {
        new import_obsidian8.Notice("\uD604\uC7AC \uB2E8\uC5B4\uC5D0 \uAC80\uC0AC\uD560 \uD14D\uC2A4\uD2B8\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.");
        return;
      }
      Logger.debug(`\uD604\uC7AC \uB2E8\uC5B4 \uB9DE\uCDA4\uBC95 \uAC80\uC0AC \uC2DC\uC791: "${selectedText}"`);
      await this.performSpellCheck(selectedText, editor, wordData.from, wordData.to);
    } catch (error) {
      Logger.error("\uD604\uC7AC \uB2E8\uC5B4 \uB9DE\uCDA4\uBC95 \uAC80\uC0AC \uC911 \uC624\uB958 \uBC1C\uC0DD:", error);
      new import_obsidian8.Notice(`\uD604\uC7AC \uB2E8\uC5B4 \uB9DE\uCDA4\uBC95 \uAC80\uC0AC \uC911 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4: ${error.message}`);
    }
  }
  /**
   * ÌòÑÏû¨ Î¨∏Ïû•Ïùò ÎßûÏ∂§Î≤ïÏùÑ Í≤ÄÏÇ¨Ìï©ÎãàÎã§.
   */
  async executeCurrentSentence() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian8.MarkdownView);
    if (!activeView) {
      new import_obsidian8.Notice("\uD65C\uC131\uD654\uB41C \uB9C8\uD06C\uB2E4\uC6B4 \uD3B8\uC9D1\uAE30\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.");
      return;
    }
    const editor = activeView.editor;
    if (!editor) {
      new import_obsidian8.Notice("\uD3B8\uC9D1\uAE30\uC5D0 \uC811\uADFC\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
      return;
    }
    try {
      const sentenceData = getCurrentSentence(editor);
      const selectedText = sentenceData.text.trim();
      if (!selectedText) {
        new import_obsidian8.Notice("\uD604\uC7AC \uBB38\uC7A5\uC5D0 \uAC80\uC0AC\uD560 \uD14D\uC2A4\uD2B8\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.");
        return;
      }
      Logger.log(`\uD604\uC7AC \uBB38\uC7A5 \uB9DE\uCDA4\uBC95 \uAC80\uC0AC \uC2DC\uC791: "${selectedText}"`);
      await this.performSpellCheck(selectedText, editor, sentenceData.from, sentenceData.to);
    } catch (error) {
      Logger.error("\uD604\uC7AC \uBB38\uC7A5 \uB9DE\uCDA4\uBC95 \uAC80\uC0AC \uC911 \uC624\uB958 \uBC1C\uC0DD:", error);
      new import_obsidian8.Notice(`\uD604\uC7AC \uBB38\uC7A5 \uB9DE\uCDA4\uBC95 \uAC80\uC0AC \uC911 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4: ${error.message}`);
    }
  }
  /**
   * ÎßûÏ∂§Î≤ï Í≤ÄÏÇ¨Î•º ÏàòÌñâÌïòÎäî Í≥µÌÜµ Î©îÏÑúÎìú
   */
  async performSpellCheck(selectedText, editor, from, to) {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian8.MarkdownView);
    const file = activeView == null ? void 0 : activeView.file;
    const cleanedText = selectedText.trim();
    const validation = SettingsService.validateSettings(this.settings);
    if (!validation.isValid) {
      new import_obsidian8.Notice(`\uC124\uC815 \uC624\uB958: ${validation.errors.join(", ")}`);
      return;
    }
    LoadingManager.getInstance().startLoading();
    try {
      const result = await this.apiService.checkSpelling(cleanedText, this.settings);
      if (result.corrections && result.corrections.length > 0) {
        Logger.log(`\uB9DE\uCDA4\uBC95 \uAC80\uC0AC \uC644\uB8CC: ${result.corrections.length}\uAC1C \uC624\uB958 \uBC1C\uACAC`);
        Logger.debug("API \uD638\uCD9C \uD14D\uC2A4\uD2B8:", {
          originalLength: selectedText.length,
          cleanedLength: cleanedText.length,
          originalFirst20: selectedText.substring(0, 20),
          cleanedFirst20: cleanedText.substring(0, 20)
        });
        const popupConfig = {
          selectedText: cleanedText,
          corrections: result.corrections,
          ignoredWords: this.settings.ignoredWords || [],
          editor,
          file,
          // ‚≠ê NEW: File Ïù∏Ïä§ÌÑ¥Ïä§ Ï†ÑÎã¨
          start: from || { line: 0, ch: 0 },
          end: to || { line: 0, ch: cleanedText.length }
        };
        const popup = new CorrectionPopup(
          this.app,
          popupConfig,
          this.aiService,
          (newMaxTokens) => this.handleMaxTokensUpdate(newMaxTokens)
        );
        popup.render();
        popup.show();
      } else {
        new import_obsidian8.Notice("\uC218\uC815\uD560 \uAC83\uC774 \uC5C6\uC2B5\uB2C8\uB2E4. \uD6CC\uB96D\uD569\uB2C8\uB2E4!");
      }
    } catch (error) {
      Logger.error("\uB9DE\uCDA4\uBC95 \uAC80\uC0AC \uC911 \uC624\uB958 \uBC1C\uC0DD:", error);
      if (error.message.includes("API \uD0A4")) {
        new import_obsidian8.Notice("API \uD0A4\uAC00 \uC124\uC815\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4. \uD50C\uB7EC\uADF8\uC778 \uC124\uC815\uC5D0\uC11C Bareun.ai API \uD0A4\uB97C \uC785\uB825\uD574\uC8FC\uC138\uC694.");
      } else if (error.message.includes("\uC694\uCCAD")) {
        new import_obsidian8.Notice(`API \uC694\uCCAD\uC5D0 \uC2E4\uD328\uD588\uC2B5\uB2C8\uB2E4: ${error.message}`);
      } else if (error.message.includes("\uB124\uD2B8\uC6CC\uD06C")) {
        new import_obsidian8.Notice("\uB124\uD2B8\uC6CC\uD06C \uC5F0\uACB0\uC744 \uD655\uC778\uD574\uC8FC\uC138\uC694.");
      } else {
        new import_obsidian8.Notice(`\uB9DE\uCDA4\uBC95 \uAC80\uC0AC \uC911 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4: ${error.message}`);
      }
    } finally {
      LoadingManager.getInstance().complete();
    }
  }
  /**
   * ÏµúÎåÄ ÌÜ†ÌÅ∞ ÏÑ§Ï†ïÏùÑ ÏóÖÎç∞Ïù¥Ìä∏Ìï©ÎãàÎã§.
   */
  handleMaxTokensUpdate(newMaxTokens) {
    this.settings.ai.maxTokens = newMaxTokens;
    this.aiService.updateSettings(this.settings.ai);
    if (this.onSettingsUpdated) {
      this.onSettingsUpdated(this.settings);
    }
  }
};

// src/ui/settingsTab.ts
var import_obsidian9 = require("obsidian");
init_logger();
var ModernSettingsTab = class extends import_obsidian9.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.currentTab = "basic";
    this.tabContainer = null;
    this.contentContainer = null;
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    this.injectGlobalStyles();
    const mainWrapper = containerEl.createEl("div", { cls: "ksc-settings-wrapper" });
    this.createHeader(mainWrapper);
    this.createTabNavigation(mainWrapper);
    this.contentContainer = mainWrapper.createEl("div", { cls: "ksc-content-container" });
    this.renderCurrentTab();
  }
  /**
   * ÌÜµÌï© CSS Ïä§ÌÉÄÏùº Ï£ºÏûÖ
   */
  injectGlobalStyles() {
    if (document.querySelector("#ksc-global-styles"))
      return;
    const style = document.head.createEl("style", { attr: { id: "ksc-global-styles" } });
    style.textContent = `
      /* =================================================================
         Korean Spell Checker - \uD1B5\uD569 \uB514\uC790\uC778 \uC2DC\uC2A4\uD15C
         ================================================================= */
      
      /* \uAE30\uBCF8 \uB798\uD37C */
      .ksc-settings-wrapper {
        max-width: 900px;
        margin: 0 auto;
        padding: 0;
        font-family: var(--font-interface);
        line-height: 1.5;
      }

      /* \uD5E4\uB354 */
      .ksc-header {
        text-align: center;
        margin-bottom: 32px;
        padding: 24px 0;
        border-bottom: 1px solid var(--background-modifier-border);
      }

      .ksc-header-title {
        font-size: 24px;
        font-weight: 600;
        color: var(--text-normal);
        margin: 0 0 8px 0;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 12px;
      }

      .ksc-header-subtitle {
        font-size: 14px;
        color: var(--text-muted);
        margin: 0;
        font-weight: 400;
      }

      /* \uD0ED \uB124\uBE44\uAC8C\uC774\uC158 */
      .ksc-tab-nav {
        display: flex;
        gap: 2px;
        background: var(--background-secondary);
        padding: 4px;
        border-radius: 8px;
        margin-bottom: 24px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }

      .ksc-tab-button {
        flex: 1;
        padding: 16px 12px;
        border: none;
        border-radius: 6px;
        background: transparent;
        color: var(--text-muted);
        font-family: var(--font-interface);
        font-size: 13px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 6px;
        min-height: 60px;
        text-align: center;
      }

      .ksc-tab-button:hover {
        color: var(--text-normal);
        background: var(--background-modifier-hover);
        transform: translateY(-1px);
      }

      .ksc-tab-button.active {
        background: var(--interactive-accent);
        color: var(--text-on-accent);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      }

      .ksc-tab-icon {
        font-size: 18px;
        line-height: 1;
      }

      .ksc-tab-label {
        font-size: 12px;
        line-height: 1.2;
        font-weight: 500;
      }

      /* \uCF58\uD150\uCE20 \uCEE8\uD14C\uC774\uB108 */
      .ksc-content-container {
        background: var(--background-primary);
        border: 1px solid var(--background-modifier-border);
        border-radius: 12px;
        padding: 0;
        min-height: 400px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        overflow: hidden;
      }

      /* \uC139\uC158 */
      .ksc-section {
        padding: 24px;
        border-bottom: 1px solid var(--background-modifier-border);
      }

      .ksc-section:last-child {
        border-bottom: none;
      }

      .ksc-section-header {
        margin-bottom: 20px;
      }

      .ksc-section-title {
        font-size: 16px;
        font-weight: 600;
        color: var(--text-normal);
        margin: 0 0 4px 0;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .ksc-section-desc {
        font-size: 13px;
        color: var(--text-muted);
        margin: 0;
        line-height: 1.4;
      }

      /* \uC815\uBCF4 \uBC15\uC2A4 */
      .ksc-info-box {
        background: var(--background-modifier-form-field);
        border: 1px solid var(--background-modifier-border);
        border-left: 4px solid var(--interactive-accent);
        border-radius: 6px;
        padding: 16px;
        margin: 16px 0;
        font-size: 13px;
        line-height: 1.5;
      }

      .ksc-warning-box {
        background: var(--background-modifier-error);
        border: 1px solid var(--text-error);
        border-left: 4px solid var(--text-error);
        color: var(--text-error);
      }

      .ksc-success-box {
        background: var(--background-modifier-success);
        border: 1px solid var(--text-success);
        border-left: 4px solid var(--text-success);
        color: var(--text-success);
      }

      /* \uC124\uC815 \uADF8\uB8F9 */
      .ksc-setting-group {
        margin-bottom: 24px;
      }

      .ksc-setting-group:last-child {
        margin-bottom: 0;
      }

      /* \uBC84\uD2BC \uADF8\uB8F9 */
      .ksc-button-group {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-top: 16px;
      }

      /* \uC608\uC678 \uB2E8\uC5B4 \uD0DC\uADF8 \uD074\uB77C\uC6B0\uB4DC */
      .ksc-tag-cloud {
        background: var(--background-secondary);
        border: 1px solid var(--background-modifier-border);
        border-radius: 8px;
        padding: 16px;
        margin: 16px 0;
        min-height: 80px;
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        align-items: flex-start;
        align-content: flex-start;
      }

      .ksc-tag {
        display: inline-flex;
        align-items: center;
        background: var(--interactive-accent);
        color: var(--text-on-accent);
        padding: 4px 8px;
        border-radius: 12px;
        font-size: 12px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
        gap: 4px;
      }

      .ksc-tag:hover {
        background: var(--interactive-accent-hover);
        transform: translateY(-1px);
      }

      .ksc-tag-remove {
        background: rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        width: 16px;
        height: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 10px;
        cursor: pointer;
      }

      .ksc-tag-remove:hover {
        background: rgba(255, 255, 255, 0.5);
      }

      /* \uBA54\uD2B8\uB9AD \uB514\uC2A4\uD50C\uB808\uC774 */
      .ksc-metrics {
        background: var(--background-secondary);
        border: 1px solid var(--background-modifier-border);
        border-radius: 8px;
        padding: 16px;
        font-family: var(--font-monospace);
        font-size: 13px;
        line-height: 1.6;
        margin: 16px 0;
        overflow-x: auto;
        white-space: pre-wrap;
        word-break: break-word;
      }

      /* \uBAA8\uB358\uD55C \uBC84\uD2BC \uC2A4\uD0C0\uC77C */
      .ksc-button-group button {
        background: var(--interactive-normal);
        color: var(--text-normal);
        border: 1px solid var(--background-modifier-border);
        border-radius: 6px;
        padding: 8px 16px;
        font-size: 13px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .ksc-button-group button:hover {
        background: var(--interactive-hover);
        border-color: var(--interactive-accent);
        transform: translateY(-1px);
      }

      .ksc-button-group button.mod-cta {
        background: var(--interactive-accent);
        color: var(--text-on-accent);
        border-color: var(--interactive-accent);
      }

      .ksc-button-group button.mod-warning {
        background: var(--text-error);
        color: var(--text-on-accent);
        border-color: var(--text-error);
      }

      /* \uD1A0\uAE00 \uAC1C\uC120 */
      .ksc-setting-group .setting-item {
        border: none !important;
        padding: 16px 0 !important;
        border-bottom: 1px solid var(--background-modifier-border) !important;
      }

      .ksc-setting-group .setting-item:last-child {
        border-bottom: none !important;
      }

      /* \uC785\uB825 \uD544\uB4DC \uC2A4\uD0C0\uC77C \uAC1C\uC120 */
      .ksc-setting-group input[type="text"],
      .ksc-setting-group input[type="number"],
      .ksc-setting-group select,
      .ksc-setting-group textarea {
        background: var(--background-modifier-form-field) !important;
        border: 1px solid var(--background-modifier-border) !important;
        border-radius: 6px !important;
        padding: 8px 12px !important;
        font-size: 13px !important;
        line-height: 1.4 !important;
        transition: border-color 0.2s ease !important;
      }

      /* \uB4DC\uB86D\uB2E4\uC6B4 \uD2B9\uBCC4 \uCC98\uB9AC - \uD14D\uC2A4\uD2B8 \uC798\uB9BC \uBC29\uC9C0 */
      .ksc-setting-group select {
        min-height: 36px !important;
        padding: 10px 12px !important;
        line-height: 1.2 !important;
      }

      .ksc-setting-group input[type="text"]:focus,
      .ksc-setting-group input[type="number"]:focus,
      .ksc-setting-group select:focus,
      .ksc-setting-group textarea:focus {
        border-color: var(--interactive-accent) !important;
        outline: none !important;
        box-shadow: 0 0 0 2px rgba(var(--interactive-accent-rgb), 0.2) !important;
      }

      /* \uBC18\uC751\uD615 \uB514\uC790\uC778 */
      @media (max-width: 768px) {
        .ksc-settings-wrapper {
          max-width: 100%;
          padding: 0 16px;
        }

        .ksc-tab-nav {
          flex-direction: column;
          gap: 4px;
        }

        .ksc-tab-button {
          flex-direction: row;
          justify-content: flex-start;
          padding: 12px 16px;
          min-height: auto;
        }

        .ksc-section {
          padding: 20px;
        }

        .ksc-button-group {
          flex-direction: column;
        }
      }

      /* \uC811\uADFC\uC131 */
      .ksc-tab-button:focus {
        outline: 2px solid var(--interactive-accent);
        outline-offset: 2px;
      }

      /* \uC0C8\uB85C\uC6B4 \uAC80\uC99D \uACB0\uACFC \uC2A4\uD0C0\uC77C - \uB354 \uAE54\uB054\uD558\uACE0 \uD604\uB300\uC801 */
      .ksc-validation-result {
        border-radius: 8px;
        background: var(--background-secondary);
        overflow: hidden;
      }
      
      .ksc-status-card {
        padding: 16px 20px;
        background: var(--background-primary);
        border-bottom: 1px solid var(--background-modifier-border);
      }
      
      .ksc-status-line {
        display: flex;
        align-items: center;
        gap: 12px;
      }
      
      .ksc-status-icon {
        font-size: 18px;
        flex-shrink: 0;
      }
      
      .ksc-status-text {
        font-size: 14px;
        font-weight: 500;
        color: var(--text-normal);
      }
      
      .ksc-section-title {
        font-size: 13px;
        font-weight: 600;
        color: var(--text-muted);
        margin-bottom: 12px;
        padding: 0 20px;
        padding-top: 16px;
      }
      
      .ksc-problems-section {
        border-top: 1px solid var(--background-modifier-border);
      }
      
      .ksc-problems-list {
        margin: 0;
        padding: 0 20px 16px 40px;
        list-style: none;
      }
      
      .ksc-problems-list li {
        color: var(--text-error);
        font-size: 13px;
        line-height: 1.4;
        margin-bottom: 6px;
        position: relative;
      }
      
      .ksc-problems-list li:before {
        content: "\u2022";
        color: var(--text-error);
        position: absolute;
        left: -16px;
      }
      
      .ksc-warnings-section {
        border-top: 1px solid var(--background-modifier-border);
      }
      
      .ksc-warnings-list {
        margin: 0;
        padding: 0 20px 16px 40px;
        list-style: none;
      }
      
      .ksc-warnings-list li {
        color: var(--text-warning);
        font-size: 13px;
        line-height: 1.4;
        margin-bottom: 6px;
        position: relative;
      }
      
      .ksc-warnings-list li:before {
        content: "\u2022";
        color: var(--text-warning);
        position: absolute;
        left: -16px;
      }
      
      .ksc-suggestions-section {
        border-top: 1px solid var(--background-modifier-border);
      }
      
      .ksc-suggestion-card {
        margin: 0 20px 12px 20px;
        padding: 12px;
        background: var(--background-modifier-form-field);
        border-radius: 6px;
        border-left: 3px solid var(--interactive-accent);
      }
      
      .ksc-suggestion-title {
        font-size: 13px;
        font-weight: 500;
        color: var(--text-normal);
        margin-bottom: 4px;
      }
      
      .ksc-suggestion-desc {
        font-size: 12px;
        color: var(--text-muted);
        line-height: 1.3;
      }
      
      .ksc-summary-section {
        border-top: 1px solid var(--background-modifier-border);
        padding-bottom: 16px;
      }
      
      .ksc-summary-grid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 8px;
        padding: 0 20px;
      }
      
      .ksc-summary-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 12px;
        background: var(--background-modifier-form-field);
        border-radius: 4px;
        font-size: 12px;
      }
      
      .ksc-summary-label {
        color: var(--text-muted);
        font-weight: 500;
      }
      
      .ksc-status-ok {
        color: var(--text-success);
        font-weight: 500;
      }
      
      .ksc-status-error {
        color: var(--text-error);
        font-weight: 500;
      }
      
      .ksc-status-warning {
        color: var(--text-warning);
        font-weight: 500;
      }
      
      .ksc-status-disabled {
        color: var(--text-faint);
        font-weight: 500;
      }

      /* \uB85C\uADF8 \uBDF0\uC5B4 \uC2A4\uD0C0\uC77C */
      .ksc-log-filter {
        margin-bottom: 12px;
        display: flex;
        gap: 8px;
        align-items: center;
      }
      
      .ksc-log-content {
        background: var(--background-secondary);
        border: 1px solid var(--background-modifier-border);
        border-radius: 6px;
        padding: 12px;
        max-height: 400px;
        overflow-y: auto;
        font-family: var(--font-monospace);
        font-size: 12px;
        line-height: 1.4;
      }
      
      .ksc-log-empty {
        color: var(--text-muted);
        text-align: center;
        padding: 20px;
      }
      
      .ksc-log-line {
        margin-bottom: 4px;
        padding: 4px 8px;
        border-radius: 4px;
      }
      
      .ksc-log-error {
        background: rgba(255, 0, 0, 0.1);
      }
      
      .ksc-log-warn {
        background: rgba(255, 165, 0, 0.1);
      }
      
      .ksc-log-info {
        background: rgba(0, 123, 255, 0.05);
      }
      
      .ksc-log-debug {
        background: rgba(108, 117, 125, 0.05);
      }
      
      .ksc-log-timestamp {
        color: var(--text-faint);
      }
      
      .ksc-log-message {
        color: var(--text-normal);
      }
      
      .ksc-log-error .ksc-log-message {
        color: var(--text-error);
      }
      
      .ksc-log-warn .ksc-log-message {
        color: var(--text-warning);
      }
      
      .ksc-log-debug .ksc-log-message {
        color: var(--text-muted);
      }
      
      .ksc-log-data {
        color: var(--text-faint);
        font-size: 11px;
      }

      /* \uC560\uB2C8\uBA54\uC774\uC158 */
      .ksc-content-container {
        animation: ksc-fadeIn 0.3s ease-out;
      }

      @keyframes ksc-fadeIn {
        from {
          opacity: 0;
          transform: translateY(8px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
    `;
  }
  /**
   * ÌòÑÏû¨ ÌÉ≠ ÏΩòÌÖêÏ∏† Î†åÎçîÎßÅ
   */
  renderCurrentTab() {
    if (!this.contentContainer)
      return;
    this.contentContainer.empty();
    switch (this.currentTab) {
      case "basic":
        this.createBasicSettingsTab(this.contentContainer);
        break;
      case "ai":
        this.createAISettingsTab(this.contentContainer);
        break;
      case "advanced":
        this.createAdvancedManagementTab(this.contentContainer);
        break;
      case "performance":
        this.createMonitoringTab(this.contentContainer);
        break;
      case "beta":
        this.createBetaFeaturesTab(this.contentContainer);
        break;
    }
  }
  /**
   * Ìó§Îçî ÏÑπÏÖò ÏÉùÏÑ±
   */
  createHeader(containerEl) {
    const header = containerEl.createEl("div", { cls: "ksc-header" });
    const title = header.createEl("h1", {
      cls: "ksc-header-title"
    });
    title.createEl("span", { text: "\u{1F4DD}" });
    title.createEl("span", { text: "\uD55C\uAD6D\uC5B4 \uB9DE\uCDA4\uBC95 \uAC80\uC0AC \uC124\uC815" });
    header.createEl("p", {
      text: "\uD50C\uB7EC\uADF8\uC778 \uB3D9\uC791\uC744 \uCEE4\uC2A4\uD130\uB9C8\uC774\uC9D5\uD558\uACE0 AI \uAE30\uB2A5\uC744 \uC124\uC815\uD558\uC138\uC694",
      cls: "ksc-header-subtitle"
    });
  }
  /**
   * ÌÉ≠ ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò ÏÉùÏÑ±
   */
  createTabNavigation(containerEl) {
    this.tabContainer = containerEl.createEl("div", { cls: "ksc-tab-nav" });
    const tabs = [
      { id: "basic", label: "\uAE30\uBCF8 \uC124\uC815", icon: "\u2699\uFE0F", desc: "API \uD0A4 \uBC0F \uAE30\uBCF8 \uC635\uC158" },
      { id: "ai", label: "AI \uC124\uC815", icon: "\u{1F916}", desc: "AI \uC790\uB3D9 \uAD50\uC815 \uAE30\uB2A5" },
      { id: "advanced", label: "\uACE0\uAE09 \uAD00\uB9AC", icon: "\u{1F527}", desc: "\uBC31\uC5C5, \uBCF5\uC6D0, \uAC80\uC99D" },
      { id: "performance", label: "\uC131\uB2A5 \uBAA8\uB2C8\uD130\uB9C1", icon: "\u{1F4CA}", desc: "\uD1B5\uACC4 \uBC0F \uCD5C\uC801\uD654" },
      { id: "beta", label: "\uBCA0\uD0C0 \uAE30\uB2A5", icon: "\u{1F9EA}", desc: "\uC778\uB77C\uC778 \uBAA8\uB4DC \uB4F1 \uC2E4\uD5D8\uC801 \uAE30\uB2A5" }
    ];
    tabs.forEach((tab) => {
      const isActive = this.currentTab === tab.id;
      const tabButton = this.tabContainer.createEl("button", {
        cls: `ksc-tab-button ${isActive ? "active" : ""}`,
        attr: { "data-tab": tab.id }
      });
      tabButton.createEl("span", {
        text: tab.icon,
        cls: "ksc-tab-icon"
      });
      tabButton.createEl("span", {
        text: tab.label,
        cls: "ksc-tab-label"
      });
      tabButton.addEventListener("click", () => {
        this.switchTab(tab.id);
      });
      tabButton.title = tab.desc;
    });
  }
  /**
   * ÌÉ≠ Ï†ÑÌôò
   */
  switchTab(tabId) {
    this.currentTab = tabId;
    if (this.tabContainer) {
      this.tabContainer.querySelectorAll(".ksc-tab-button").forEach((button) => {
        const isActive = button.getAttribute("data-tab") === tabId;
        if (isActive) {
          button.addClass("active");
        } else {
          button.removeClass("active");
        }
      });
    }
    this.renderCurrentTab();
  }
  /**
   * Í∏∞Î≥∏ ÏÑ§Ï†ï ÌÉ≠ÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§
   */
  createBasicSettingsTab(containerEl) {
    this.createUsageGuideSection(containerEl);
    this.createAPISettingsSection(containerEl);
    this.createFilteringOptionsSection(containerEl);
    this.createIgnoredWordsSection(containerEl);
  }
  /**
   * ÏÇ¨Ïö©Î≤ï ÏïàÎÇ¥ ÏÑπÏÖòÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§
   */
  createUsageGuideSection(containerEl) {
    const section = containerEl.createEl("div", { cls: "ksc-section" });
    new import_obsidian9.Setting(section).setName("\u{1F4D6} \uC0AC\uC6A9\uBC95 \uC548\uB0B4").setDesc("\uD50C\uB7EC\uADF8\uC778\uC758 \uAE30\uBCF8 \uC0AC\uC6A9 \uBC29\uBC95\uC744 \uC548\uB0B4\uD569\uB2C8\uB2E4.").setHeading();
    const infoBox = section.createEl("div", { cls: "ksc-info-box" });
    const steps = [
      "1\uFE0F\u20E3 \uD14D\uC2A4\uD2B8\uB97C \uC120\uD0DD\uD558\uACE0 \uB9AC\uBCF8 \uC544\uC774\uCF58\uC744 \uD074\uB9AD\uD558\uAC70\uB098 \uBA85\uB839 \uD314\uB808\uD2B8\uC5D0\uC11C \uC2E4\uD589",
      "2\uFE0F\u20E3 \uD31D\uC5C5\uC5D0\uC11C \uBE68\uAC04\uC0C9\uC73C\uB85C \uD45C\uC2DC\uB41C \uC624\uB958\uB97C \uD074\uB9AD\uD558\uC5EC \uC218\uC815\uC0AC\uD56D \uD655\uC778",
      "3\uFE0F\u20E3 AI \uBD84\uC11D \uBC84\uD2BC\uC73C\uB85C \uC790\uB3D9 \uAD50\uC815 \uC81C\uC548 \uBC1B\uAE30 (AI \uAE30\uB2A5 \uD65C\uC131\uD654 \uC2DC)",
      "4\uFE0F\u20E3 \uC801\uC6A9 \uBC84\uD2BC\uC73C\uB85C \uBCC0\uACBD\uC0AC\uD56D\uC744 \uC5D0\uB514\uD130\uC5D0 \uBC18\uC601"
    ];
    infoBox.createEl("strong", { text: "\u{1F680} \uAE30\uBCF8 \uC0AC\uC6A9\uBC95" });
    infoBox.createEl("br");
    infoBox.createEl("br");
    steps.forEach((step) => {
      infoBox.createEl("div", {
        text: step,
        attr: { style: "margin-bottom: 4px;" }
      });
    });
  }
  /**
   * API ÏÑ§Ï†ï ÏÑπÏÖòÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§
   */
  createAPISettingsSection(containerEl) {
    const section = containerEl.createEl("div", { cls: "ksc-section" });
    new import_obsidian9.Setting(section).setName("\u{1F310} API \uC124\uC815").setDesc("Bareun.ai \uB9DE\uCDA4\uBC95 \uAC80\uC0AC \uC11C\uBE44\uC2A4 \uC5F0\uACB0\uC744 \uC704\uD55C \uC124\uC815\uC785\uB2C8\uB2E4.").setHeading();
    const settingsGroup = section.createEl("div", { cls: "ksc-setting-group" });
    new import_obsidian9.Setting(settingsGroup).setName("Bareun.ai API \uD0A4").setDesc("\uB9DE\uCDA4\uBC95 \uAC80\uC0AC\uB97C \uC704\uD55C Bareun.ai API \uD0A4\uB97C \uC785\uB825\uD558\uC138\uC694.").addText((text) => {
      text.setPlaceholder("API \uD0A4\uB97C \uC785\uB825\uD558\uC138\uC694").setValue(this.plugin.settings.apiKey).onChange(async (value) => {
        this.plugin.settings.apiKey = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian9.Setting(settingsGroup).setName("API \uD638\uC2A4\uD2B8").setDesc("Bareun.ai API \uC11C\uBC84 \uD638\uC2A4\uD2B8 \uC8FC\uC18C\uC785\uB2C8\uB2E4.").addText((text) => {
      text.setPlaceholder("bareun-api.junlim.org").setValue(this.plugin.settings.apiHost).onChange(async (value) => {
        this.plugin.settings.apiHost = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian9.Setting(settingsGroup).setName("API \uD3EC\uD2B8").setDesc("Bareun.ai API \uC11C\uBC84 \uD3EC\uD2B8 \uBC88\uD638\uC785\uB2C8\uB2E4.").addText((text) => {
      text.setPlaceholder("443").setValue(this.plugin.settings.apiPort.toString()).onChange(async (value) => {
        const port = parseInt(value);
        if (!isNaN(port) && port > 0 && port <= 65535) {
          this.plugin.settings.apiPort = port;
          await this.plugin.saveSettings();
        }
      });
    });
    const apiInfoBox = section.createEl("div", { cls: "ksc-info-box" });
    apiInfoBox.createEl("strong", { text: "\u{1F4A1} API \uD0A4 \uBC1C\uAE09 \uC548\uB0B4" });
    apiInfoBox.createEl("br");
    apiInfoBox.createEl("span", { text: "API \uD0A4\uB294 " });
    const bareunLink = apiInfoBox.createEl("a", {
      text: "Bareun.ai \uC6F9\uC0AC\uC774\uD2B8",
      href: "https://bareun.ai",
      attr: { target: "_blank" }
    });
    apiInfoBox.createEl("span", { text: "\uC5D0\uC11C \uBC1C\uAE09\uBC1B\uC744 \uC218 \uC788\uC2B5\uB2C8\uB2E4." });
  }
  /**
   * AI ÏÑ§Ï†ï ÌÉ≠ÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§
   */
  createAISettingsTab(containerEl) {
    const aiToggleSection = containerEl.createEl("div", { cls: "ksc-section" });
    new import_obsidian9.Setting(aiToggleSection).setName("\u{1F916} AI \uC790\uB3D9 \uAD50\uC815").setDesc("AI\uAC00 \uBB38\uB9E5\uC744 \uBD84\uC11D\uD558\uC5EC \uCD5C\uC801\uC758 \uC218\uC815\uC0AC\uD56D\uC744 \uC790\uB3D9\uC73C\uB85C \uC120\uD0DD\uD569\uB2C8\uB2E4.").setHeading();
    const settingsGroup = aiToggleSection.createEl("div", { cls: "ksc-setting-group" });
    new import_obsidian9.Setting(settingsGroup).setName("AI \uAE30\uB2A5 \uD65C\uC131\uD654").setDesc("AI \uC790\uB3D9 \uAD50\uC815 \uAE30\uB2A5\uC744 \uC0AC\uC6A9\uD569\uB2C8\uB2E4.").addToggle((toggle) => toggle.setValue(this.plugin.settings.ai.enabled).onChange(async (value) => {
      this.plugin.settings.ai.enabled = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.ai.enabled) {
      this.createAIProviderSection(containerEl);
      this.createAIModelSection(containerEl);
      this.createAIAdvancedSection(containerEl);
    } else {
      const disabledInfo = containerEl.createEl("div", { cls: "ksc-info-box" });
      disabledInfo.createEl("strong", { text: "\u{1F4A1} AI \uAE30\uB2A5\uC744 \uD65C\uC131\uD654\uD558\uBA74 \uB2E4\uC74C\uACFC \uAC19\uC740 \uAE30\uB2A5\uC744 \uC0AC\uC6A9\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4:" });
      disabledInfo.createEl("br");
      disabledInfo.createEl("br");
      const features = [
        "\u2022 \uBB38\uB9E5\uC744 \uACE0\uB824\uD55C \uC9C0\uB2A5\uD615 \uC218\uC815 \uC81C\uC548",
        "\u2022 \uACE0\uC720\uBA85\uC0AC \uBC0F \uC804\uBB38\uC6A9\uC5B4 \uC790\uB3D9 \uC778\uC2DD",
        "\u2022 \uC2E0\uB8B0\uB3C4 \uC810\uC218\uC640 \uC0C1\uC138\uD55C \uCD94\uCC9C \uC774\uC720",
        "\u2022 \uC6D0\uD074\uB9AD \uC790\uB3D9 \uAD50\uC815 \uC801\uC6A9"
      ];
      features.forEach((feature) => {
        disabledInfo.createEl("div", { text: feature });
      });
    }
  }
  /**
   * AI Ï†úÍ≥µÏûê ÏÑ†ÌÉù ÏÑπÏÖòÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§
   */
  createAIProviderSection(containerEl) {
    const providerSection = containerEl.createEl("div", { cls: "ksc-section" });
    new import_obsidian9.Setting(providerSection).setName("\u{1F3E2} AI \uC81C\uACF5\uC790").setDesc("\uC0AC\uC6A9\uD560 AI \uC11C\uBE44\uC2A4\uB97C \uC120\uD0DD\uD558\uACE0 API \uD0A4\uB97C \uC124\uC815\uD558\uC138\uC694.").setHeading();
    const settingsGroup = providerSection.createEl("div", { cls: "ksc-setting-group" });
    new import_obsidian9.Setting(settingsGroup).setName("AI \uC81C\uACF5\uC790").setDesc("\uC0AC\uC6A9\uD560 AI \uC11C\uBE44\uC2A4\uB97C \uC120\uD0DD\uD558\uC138\uC694.").addDropdown((dropdown) => {
      dropdown.addOption("openai", "\u{1F535} OpenAI (GPT)").addOption("anthropic", "\u{1F7E0} Anthropic (Claude)").addOption("google", "\u{1F534} Google (Gemini)").addOption("ollama", "\u{1F7E1} Ollama (\uB85C\uCEEC)").setValue(this.plugin.settings.ai.provider).onChange(async (value) => {
        this.plugin.settings.ai.provider = value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    this.createProviderAPIKeySettings(settingsGroup);
  }
  /**
   * Ï†úÍ≥µÏûêÎ≥Ñ API ÌÇ§ ÏÑ§Ï†ïÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§
   */
  createProviderAPIKeySettings(containerEl) {
    const provider = this.plugin.settings.ai.provider;
    if (provider === "openai") {
      new import_obsidian9.Setting(containerEl).setName("OpenAI API \uD0A4").setDesc("OpenAI \uC11C\uBE44\uC2A4 \uC0AC\uC6A9\uC744 \uC704\uD55C API \uD0A4\uC785\uB2C8\uB2E4.").addText((text) => text.setPlaceholder("sk-...").setValue(this.plugin.settings.ai.openaiApiKey).onChange(async (value) => {
        this.plugin.settings.ai.openaiApiKey = value;
        await this.plugin.saveSettings();
      }));
    } else if (provider === "anthropic") {
      new import_obsidian9.Setting(containerEl).setName("Anthropic API \uD0A4").setDesc("Anthropic (Claude) \uC11C\uBE44\uC2A4 \uC0AC\uC6A9\uC744 \uC704\uD55C API \uD0A4\uC785\uB2C8\uB2E4.").addText((text) => text.setPlaceholder("sk-ant-...").setValue(this.plugin.settings.ai.anthropicApiKey).onChange(async (value) => {
        this.plugin.settings.ai.anthropicApiKey = value;
        await this.plugin.saveSettings();
      }));
    } else if (provider === "google") {
      new import_obsidian9.Setting(containerEl).setName("Google AI API \uD0A4").setDesc("Google Gemini \uC11C\uBE44\uC2A4 \uC0AC\uC6A9\uC744 \uC704\uD55C API \uD0A4\uC785\uB2C8\uB2E4.").addText((text) => text.setPlaceholder("AIza...").setValue(this.plugin.settings.ai.googleApiKey).onChange(async (value) => {
        this.plugin.settings.ai.googleApiKey = value;
        await this.plugin.saveSettings();
      }));
    } else if (provider === "ollama") {
      new import_obsidian9.Setting(containerEl).setName("Ollama \uC5D4\uB4DC\uD3EC\uC778\uD2B8").setDesc("\uB85C\uCEEC Ollama \uC11C\uBC84\uC758 \uC5D4\uB4DC\uD3EC\uC778\uD2B8 \uC8FC\uC18C\uC785\uB2C8\uB2E4.").addText((text) => text.setPlaceholder("http://localhost:11434").setValue(this.plugin.settings.ai.ollamaEndpoint).onChange(async (value) => {
        this.plugin.settings.ai.ollamaEndpoint = value;
        await this.plugin.saveSettings();
      }));
    }
  }
  /**
   * AI Î™®Îç∏ ÏÑ§Ï†ï ÏÑπÏÖòÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§
   */
  createAIModelSection(containerEl) {
    const modelSection = containerEl.createEl("div", { cls: "ksc-section" });
    new import_obsidian9.Setting(modelSection).setName("\u{1F3AF} \uBAA8\uB378 \uC124\uC815").setDesc("\uC0AC\uC6A9\uD560 AI \uBAA8\uB378\uACFC \uC138\uBD80 \uC124\uC815\uC744 \uAD6C\uC131\uD558\uC138\uC694.").setHeading();
    const settingsGroup = modelSection.createEl("div", { cls: "ksc-setting-group" });
    const provider = this.plugin.settings.ai.provider;
    const modelOptions = this.getModelOptions(provider);
    new import_obsidian9.Setting(settingsGroup).setName("AI \uBAA8\uB378").setDesc(`${provider.toUpperCase()} \uC81C\uACF5\uC790\uC758 \uC0AC\uC6A9 \uAC00\uB2A5\uD55C \uBAA8\uB378\uC785\uB2C8\uB2E4.`).addDropdown((dropdown) => {
      modelOptions.forEach((model) => {
        dropdown.addOption(model.id, model.name);
      });
      dropdown.setValue(this.plugin.settings.ai.model).onChange(async (value) => {
        this.plugin.settings.ai.model = value;
        await this.plugin.saveSettings();
      });
    });
  }
  /**
   * Ï†úÍ≥µÏûêÎ≥Ñ Î™®Îç∏ ÏòµÏÖòÏùÑ Î∞òÌôòÌï©ÎãàÎã§
   */
  getModelOptions(provider) {
    switch (provider) {
      case "openai":
        return [
          { id: "gpt-4o", name: "GPT-4 Omni" },
          { id: "gpt-4o-mini", name: "GPT-4 Omni Mini" },
          { id: "gpt-4-turbo", name: "GPT-4 Turbo" }
        ];
      case "anthropic":
        return [
          { id: "claude-3-5-sonnet-20241022", name: "Claude 3.5 Sonnet" },
          { id: "claude-3-5-haiku-20241022", name: "Claude 3.5 Haiku" }
        ];
      case "google":
        return [
          { id: "gemini-1.5-pro", name: "Gemini 1.5 Pro" },
          { id: "gemini-1.5-flash", name: "Gemini 1.5 Flash" }
        ];
      case "ollama":
        return [
          { id: "llama3.2:3b", name: "Llama 3.2 3B" },
          { id: "mistral:7b", name: "Mistral 7B" },
          { id: "qwen2.5:7b", name: "Qwen 2.5 7B" }
        ];
      default:
        return [];
    }
  }
  /**
   * AI Í≥†Í∏â ÏÑ§Ï†ï ÏÑπÏÖòÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§
   */
  createAIAdvancedSection(containerEl) {
    const advancedSection = containerEl.createEl("div", { cls: "ksc-section" });
    new import_obsidian9.Setting(advancedSection).setName("\u2699\uFE0F \uACE0\uAE09 \uC124\uC815").setDesc("AI \uBAA8\uB378\uC758 \uC0C1\uC138\uD55C \uB3D9\uC791\uC744 \uC870\uC815\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4.").setHeading();
    const settingsGroup = advancedSection.createEl("div", { cls: "ksc-setting-group" });
    new import_obsidian9.Setting(settingsGroup).setName("\uCD5C\uB300 \uD1A0\uD070 \uC218").setDesc("AI \uC694\uCCAD \uC2DC \uC0AC\uC6A9\uD560 \uCD5C\uB300 \uD1A0\uD070 \uC218\uC785\uB2C8\uB2E4. (\uAD8C\uC7A5: 1000-4000, \uB192\uC744\uC218\uB85D \uB354 \uC0C1\uC138\uD55C \uBD84\uC11D)").addText(
      (text) => text.setPlaceholder("\uC608: 2000").setValue(this.plugin.settings.ai.maxTokens.toString()).onChange(async (value) => {
        const numValue = parseInt(value);
        if (!isNaN(numValue) && numValue > 0) {
          this.plugin.settings.ai.maxTokens = numValue;
          await this.plugin.saveSettings();
        }
      })
    ).then((setting) => {
      setting.controlEl.querySelector("input").type = "number";
      setting.controlEl.querySelector("input").min = "100";
      setting.controlEl.querySelector("input").step = "100";
    });
    new import_obsidian9.Setting(settingsGroup).setName("\uCC3D\uC758\uC131 (Temperature)").setDesc("AI\uC758 \uCC3D\uC758\uC131 \uC218\uC900\uC785\uB2C8\uB2E4. \uB0AE\uC744\uC218\uB85D \uC77C\uAD00\uB41C \uACB0\uACFC, \uB192\uC744\uC218\uB85D \uB2E4\uC591\uD55C \uACB0\uACFC").addSlider((slider) => slider.setLimits(0, 1, 0.1).setValue(this.plugin.settings.ai.temperature).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.ai.temperature = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian9.Setting(settingsGroup).setName("\uD1A0\uD070 \uC0AC\uC6A9\uB7C9 \uACBD\uACE0").setDesc("\uD1A0\uD070 \uC0AC\uC6A9\uB7C9\uC774 \uC784\uACC4\uAC12\uC744 \uCD08\uACFC\uD560 \uB54C \uACBD\uACE0\uB97C \uD45C\uC2DC\uD569\uB2C8\uB2E4.").addToggle((toggle) => toggle.setValue(this.plugin.settings.ai.showTokenWarning).onChange(async (value) => {
      this.plugin.settings.ai.showTokenWarning = value;
      await this.plugin.saveSettings();
    }));
    if (this.plugin.settings.ai.showTokenWarning) {
      new import_obsidian9.Setting(settingsGroup).setName("\uACBD\uACE0 \uC784\uACC4\uAC12").setDesc("\uC774 \uD1A0\uD070 \uC218\uB97C \uCD08\uACFC\uD558\uBA74 \uACBD\uACE0\uB97C \uD45C\uC2DC\uD569\uB2C8\uB2E4.").addSlider((slider) => slider.setLimits(500, 5e3, 100).setValue(this.plugin.settings.ai.tokenWarningThreshold).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.ai.tokenWarningThreshold = value;
        await this.plugin.saveSettings();
      }));
    }
  }
  /**
   * ÏòàÏô∏ Îã®Ïñ¥ Í¥ÄÎ¶¨ ÏÑπÏÖòÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§
   */
  createIgnoredWordsSection(containerEl) {
    const section = containerEl.createEl("div", { cls: "ksc-section" });
    new import_obsidian9.Setting(section).setName("\u{1F4DD} \uC608\uC678 \uB2E8\uC5B4 \uAD00\uB9AC").setDesc("\uB9DE\uCDA4\uBC95 \uAC80\uC0AC\uC5D0\uC11C \uC81C\uC678\uD560 \uB2E8\uC5B4\uB4E4\uC744 \uAD00\uB9AC\uD569\uB2C8\uB2E4.").setHeading();
    const countInfo = section.createEl("div", {
      cls: "ksc-info-box",
      text: `\uD604\uC7AC ${IgnoredWordsService.getIgnoredWordsCount(this.plugin.settings)}\uAC1C\uC758 \uB2E8\uC5B4\uAC00 \uC608\uC678 \uCC98\uB9AC\uB418\uC5B4 \uC788\uC2B5\uB2C8\uB2E4.`
    });
    const tagCloudContainer = section.createEl("div", { cls: "ksc-tag-cloud" });
    const inputContainer = section.createEl("div", { cls: "ksc-setting-group" });
    new import_obsidian9.Setting(inputContainer).setName("\uC608\uC678 \uB2E8\uC5B4 \uCD94\uAC00").setDesc("\uC27C\uD45C\uB85C \uAD6C\uBD84\uD558\uC5EC \uC5EC\uB7EC \uB2E8\uC5B4\uB97C \uD55C \uBC88\uC5D0 \uCD94\uAC00\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4.").addText((text) => {
      text.setPlaceholder("\uC608: \uCE74\uCE74\uC624\uD1A1, \uB124\uC774\uBC84, \uACE0\uC720\uBA85\uC0AC").onChange(async (value) => {
        if (value.includes(",")) {
          const words = value.split(",").map((w) => w.trim()).filter((w) => w.length > 0);
          if (words.length > 0) {
            const updatedSettings = IgnoredWordsService.addMultipleIgnoredWords(words, this.plugin.settings);
            this.plugin.settings = updatedSettings;
            await this.plugin.saveSettings();
            text.setValue("");
            this.renderIgnoredWordsCloud(tagCloudContainer);
            countInfo.textContent = `\uD604\uC7AC ${IgnoredWordsService.getIgnoredWordsCount(this.plugin.settings)}\uAC1C\uC758 \uB2E8\uC5B4\uAC00 \uC608\uC678 \uCC98\uB9AC\uB418\uC5B4 \uC788\uC2B5\uB2C8\uB2E4.`;
          }
        }
      });
      text.inputEl.addEventListener("keydown", async (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          const value = text.getValue().trim();
          if (value) {
            const words = value.split(",").map((w) => w.trim()).filter((w) => w.length > 0);
            if (words.length > 0) {
              const updatedSettings = IgnoredWordsService.addMultipleIgnoredWords(words, this.plugin.settings);
              this.plugin.settings = updatedSettings;
              await this.plugin.saveSettings();
              text.setValue("");
              this.renderIgnoredWordsCloud(tagCloudContainer);
              countInfo.textContent = `\uD604\uC7AC ${IgnoredWordsService.getIgnoredWordsCount(this.plugin.settings)}\uAC1C\uC758 \uB2E8\uC5B4\uAC00 \uC608\uC678 \uCC98\uB9AC\uB418\uC5B4 \uC788\uC2B5\uB2C8\uB2E4.`;
            }
          }
        }
      });
    });
    const buttonContainer = section.createEl("div", { cls: "ksc-button-group" });
    const clearAllButton = buttonContainer.createEl("button", {
      text: "\u{1F5D1}\uFE0F \uC804\uCCB4 \uC0AD\uC81C",
      cls: "mod-warning"
    });
    clearAllButton.onclick = async () => {
      if (confirm("\uBAA8\uB4E0 \uC608\uC678 \uB2E8\uC5B4\uB97C \uC0AD\uC81C\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?")) {
        this.plugin.settings.ignoredWords = [];
        await this.plugin.saveSettings();
        this.renderIgnoredWordsCloud(tagCloudContainer);
        countInfo.textContent = `\uD604\uC7AC ${IgnoredWordsService.getIgnoredWordsCount(this.plugin.settings)}\uAC1C\uC758 \uB2E8\uC5B4\uAC00 \uC608\uC678 \uCC98\uB9AC\uB418\uC5B4 \uC788\uC2B5\uB2C8\uB2E4.`;
      }
    };
    this.renderIgnoredWordsCloud(tagCloudContainer);
  }
  /**
   * ÏòàÏô∏ Îã®Ïñ¥ ÌÅ¥ÎùºÏö∞ÎìúÎ•º Î†åÎçîÎßÅÌï©ÎãàÎã§
   */
  renderIgnoredWordsCloud(container) {
    clearElement(container);
    if (this.plugin.settings.ignoredWords.length === 0) {
      container.createEl("div", {
        text: "\uC608\uC678 \uCC98\uB9AC\uB41C \uB2E8\uC5B4\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.",
        attr: { style: "color: var(--text-muted); text-align: center; padding: 20px;" }
      });
      return;
    }
    this.plugin.settings.ignoredWords.forEach((word) => {
      const tag = container.createEl("span", {
        text: word,
        attr: {
          style: `
            display: inline-block;
            background: var(--interactive-accent);
            color: var(--text-on-accent);
            padding: 4px 8px;
            margin: 2px;
            border-radius: 12px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
          `
        }
      });
      tag.addEventListener("mouseenter", () => {
        tag.style.background = "var(--interactive-accent-hover)";
      });
      tag.addEventListener("mouseleave", () => {
        tag.style.background = "var(--interactive-accent)";
      });
      tag.onclick = async () => {
        if (confirm(`"${word}"\uB97C \uC608\uC678 \uBAA9\uB85D\uC5D0\uC11C \uC81C\uAC70\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?`)) {
          const updatedSettings = IgnoredWordsService.removeIgnoredWord(word, this.plugin.settings);
          this.plugin.settings = updatedSettings;
          await this.plugin.saveSettings();
          this.renderIgnoredWordsCloud(container);
        }
      };
    });
  }
  /**
   * Í≥†Í∏â Í¥ÄÎ¶¨ ÌÉ≠ÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§
   */
  createAdvancedManagementTab(containerEl) {
    this.createValidationSection(containerEl);
    this.createBackupSection(containerEl);
    this.createImportExportSection(containerEl);
  }
  /**
   * ÏÑ§Ï†ï Í≤ÄÏ¶ù ÏÑπÏÖòÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§
   */
  createValidationSection(containerEl) {
    const { AdvancedSettingsService: AdvancedSettingsService2 } = (init_advancedSettingsService(), __toCommonJS(advancedSettingsService_exports));
    const validationSection = containerEl.createEl("div", { cls: "ksc-section" });
    new import_obsidian9.Setting(validationSection).setName("\u2705 \uC124\uC815 \uAC80\uC99D").setDesc("\uD604\uC7AC \uC124\uC815\uC758 \uC720\uD6A8\uC131\uC744 \uAC80\uC0AC\uD558\uACE0 \uCD5C\uC801\uD654 \uC81C\uC548\uC744 \uBC1B\uC2B5\uB2C8\uB2E4.").setHeading();
    const buttonGroup = validationSection.createEl("div", { cls: "ksc-button-group" });
    const validateButton = buttonGroup.createEl("button", { text: "\uC124\uC815 \uAC80\uC99D", cls: "mod-cta" });
    const validationResult = validationSection.createEl("div", {
      attr: {
        style: "display: none; margin-top: 16px;",
        id: "validation-result-container"
      }
    });
    validateButton.onclick = () => {
      try {
        const validation = AdvancedSettingsService2.validateSettings(this.plugin.settings);
        const suggestions = AdvancedSettingsService2.getOptimizationSuggestions(this.plugin.settings);
        this.createImprovedValidationDisplay(validationResult, validation, suggestions);
        validationResult.style.display = "block";
        validationResult.className = "";
      } catch (error) {
        Logger.error("\uC124\uC815 \uAC80\uC99D \uC624\uB958:", error);
        validationResult.style.display = "block";
        validationResult.className = "ksc-warning-box";
        validationResult.textContent = "\uC124\uC815 \uAC80\uC99D \uC911 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4.";
      }
    };
  }
  /**
   * Î∞±ÏóÖ Í¥ÄÎ¶¨ ÏÑπÏÖòÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§
   */
  createBackupSection(containerEl) {
    const { AdvancedSettingsService: AdvancedSettingsService2 } = (init_advancedSettingsService(), __toCommonJS(advancedSettingsService_exports));
    const backupSection = containerEl.createEl("div", { cls: "ksc-section" });
    new import_obsidian9.Setting(backupSection).setName("\u{1F4BE} \uBC31\uC5C5 \uAD00\uB9AC").setDesc("\uC124\uC815\uC744 \uBC31\uC5C5\uD558\uACE0 \uD544\uC694\uC2DC \uC774\uC804 \uC0C1\uD0DC\uB85C \uBCF5\uC6D0\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4.").setHeading();
    const buttonGroup = backupSection.createEl("div", { cls: "ksc-button-group" });
    const createBackupBtn = buttonGroup.createEl("button", { text: "\uBC31\uC5C5 \uC0DD\uC131" });
    const showBackupsBtn = buttonGroup.createEl("button", { text: "\uBC31\uC5C5 \uBAA9\uB85D" });
    const backupListContainer = backupSection.createEl("div", {
      attr: { style: "display: none; margin-top: 16px;" }
    });
    createBackupBtn.onclick = () => {
      AdvancedSettingsService2.backupSettings(this.plugin.settings, "\uC218\uB3D9 \uBC31\uC5C5");
      new import_obsidian9.Notice("\uC124\uC815\uC774 \uBC31\uC5C5\uB418\uC5C8\uC2B5\uB2C8\uB2E4.");
      if (backupListContainer.style.display !== "none") {
        updateBackupList();
      }
    };
    const updateBackupList = () => {
      const backups = AdvancedSettingsService2.getBackups();
      clearElement(backupListContainer);
      if (backups.length === 0) {
        backupListContainer.createEl("div", {
          text: "\uBC31\uC5C5\uC774 \uC5C6\uC2B5\uB2C8\uB2E4.",
          cls: "ksc-info-box"
        });
      } else {
        backups.forEach((backup) => {
          const backupItem = backupListContainer.createEl("div", {
            cls: "ksc-info-box",
            attr: { style: "margin-bottom: 8px;" }
          });
          backupItem.createEl("strong", { text: backup.reason });
          backupItem.createEl("span", { text: ` (${backup.age})` });
          backupItem.createEl("br");
          backupItem.createEl("small", { text: `${backup.timestamp} - \uBC84\uC804 ${backup.version}` });
          backupItem.createEl("br");
          const restoreBtn = backupItem.createEl("button", {
            text: "\uBCF5\uC6D0",
            attr: { style: "margin-top: 8px; font-size: 12px;" }
          });
          restoreBtn.onclick = async () => {
            const restored = AdvancedSettingsService2.restoreSettings(backup.index);
            if (restored) {
              this.plugin.settings = restored;
              await this.plugin.saveSettings();
              this.display();
              new import_obsidian9.Notice("\uC124\uC815\uC774 \uBCF5\uC6D0\uB418\uC5C8\uC2B5\uB2C8\uB2E4.");
            }
          };
        });
      }
    };
    showBackupsBtn.onclick = () => {
      const isVisible = backupListContainer.style.display !== "none";
      backupListContainer.style.display = isVisible ? "none" : "block";
      if (!isVisible) {
        updateBackupList();
      }
    };
  }
  /**
   * ÎÇ¥Î≥¥ÎÇ¥Í∏∞/Í∞ÄÏ†∏Ïò§Í∏∞ ÏÑπÏÖòÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§
   */
  createImportExportSection(containerEl) {
    const { AdvancedSettingsService: AdvancedSettingsService2 } = (init_advancedSettingsService(), __toCommonJS(advancedSettingsService_exports));
    const importExportSection = containerEl.createEl("div", { cls: "ksc-section" });
    new import_obsidian9.Setting(importExportSection).setName("\u{1F4E4} \uB0B4\uBCF4\uB0B4\uAE30/\uAC00\uC838\uC624\uAE30").setDesc("\uC124\uC815\uC744 JSON \uD30C\uC77C\uB85C \uB0B4\uBCF4\uB0B4\uAC70\uB098 \uB2E4\uB978 \uAE30\uAE30\uC5D0\uC11C \uAC00\uC838\uC62C \uC218 \uC788\uC2B5\uB2C8\uB2E4.").setHeading();
    const buttonGroup = importExportSection.createEl("div", { cls: "ksc-button-group" });
    const exportBtn = buttonGroup.createEl("button", { text: "\uC124\uC815 \uB0B4\uBCF4\uB0B4\uAE30" });
    const importBtn = buttonGroup.createEl("button", { text: "\uC124\uC815 \uAC00\uC838\uC624\uAE30" });
    const resetBtn = buttonGroup.createEl("button", {
      text: "\uAE30\uBCF8\uAC12\uC73C\uB85C \uC7AC\uC124\uC815",
      cls: "mod-warning"
    });
    exportBtn.onclick = () => {
      const jsonData = AdvancedSettingsService2.exportSettings(this.plugin.settings);
      const blob = new Blob([jsonData], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `korean-grammar-settings-${new Date().toISOString().split("T")[0]}.json`;
      a.click();
      URL.revokeObjectURL(url);
      new import_obsidian9.Notice("\uC124\uC815\uC774 \uB0B4\uBCF4\uB0B4\uAE30\uB418\uC5C8\uC2B5\uB2C8\uB2E4.");
    };
    importBtn.onclick = () => {
      const input = document.createElement("input");
      input.type = "file";
      input.accept = ".json";
      input.onchange = (e) => {
        var _a;
        const file = (_a = e.target.files) == null ? void 0 : _a[0];
        if (!file)
          return;
        const reader = new FileReader();
        reader.onload = async (e2) => {
          var _a2;
          const content = (_a2 = e2.target) == null ? void 0 : _a2.result;
          const result = AdvancedSettingsService2.importSettings(content);
          if (result.success && result.settings) {
            AdvancedSettingsService2.backupSettings(this.plugin.settings, "\uAC00\uC838\uC624\uAE30 \uC804 \uBC31\uC5C5");
            this.plugin.settings = result.settings;
            await this.plugin.saveSettings();
            this.display();
            new import_obsidian9.Notice("\uC124\uC815\uC774 \uAC00\uC838\uC624\uAE30\uB418\uC5C8\uC2B5\uB2C8\uB2E4.");
          } else {
            new import_obsidian9.Notice(`\uC124\uC815 \uAC00\uC838\uC624\uAE30 \uC2E4\uD328: ${result.error}`);
          }
        };
        reader.readAsText(file);
      };
      input.click();
    };
    resetBtn.onclick = async () => {
      const confirmed = confirm("\uBAA8\uB4E0 \uC124\uC815\uC744 \uAE30\uBCF8\uAC12\uC73C\uB85C \uC7AC\uC124\uC815\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C? \uD604\uC7AC \uC124\uC815\uC740 \uBC31\uC5C5\uB429\uB2C8\uB2E4.");
      if (confirmed) {
        const defaultSettings = AdvancedSettingsService2.resetToDefaults(this.plugin.settings);
        this.plugin.settings = defaultSettings;
        await this.plugin.saveSettings();
        this.display();
        new import_obsidian9.Notice("\uC124\uC815\uC774 \uAE30\uBCF8\uAC12\uC73C\uB85C \uC7AC\uC124\uC815\uB418\uC5C8\uC2B5\uB2C8\uB2E4.");
      }
    };
  }
  /**
   * ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ ÌÉ≠ÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§
   */
  createMonitoringTab(containerEl) {
    this.createMetricsSection(containerEl);
    this.createLogManagementSection(containerEl);
    this.createPerformanceControlSection(containerEl);
  }
  /**
   * Ïã§ÏãúÍ∞Ñ Î©îÌä∏Î¶≠ ÏÑπÏÖòÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§
   */
  createMetricsSection(containerEl) {
    const metricsSection = containerEl.createEl("div", { cls: "ksc-section" });
    new import_obsidian9.Setting(metricsSection).setName("\u{1F4CA} \uC2E4\uC2DC\uAC04 \uC131\uB2A5 \uBA54\uD2B8\uB9AD").setDesc("API \uD638\uCD9C \uC131\uB2A5\uACFC \uCE90\uC2DC \uD6A8\uC728\uC131\uC744 \uC2E4\uC2DC\uAC04\uC73C\uB85C \uBAA8\uB2C8\uD130\uB9C1\uD569\uB2C8\uB2E4.").setHeading();
    const metricsDisplay = metricsSection.createEl("div", {
      cls: "ksc-metrics",
      attr: { id: "metrics-display-container" }
    });
    const additionalStatsContainer = metricsSection.createEl("div", {
      attr: { id: "additional-stats-container" }
    });
    const buttonGroup = metricsSection.createEl("div", { cls: "ksc-button-group" });
    const refreshBtn = buttonGroup.createEl("button", { text: "\uC0C8\uB85C\uACE0\uCE68", cls: "mod-cta" });
    const updateMetrics = () => {
      try {
        const metrics = this.plugin.orchestrator.getPerformanceMetrics();
        const { Logger: Logger2 } = (init_logger(), __toCommonJS(logger_exports));
        const { ErrorHandlerService: ErrorHandlerService2 } = (init_errorHandler(), __toCommonJS(errorHandler_exports));
        const logStats = Logger2.getStats();
        const errorStats = ErrorHandlerService2.getErrorStats();
        const extendedMetrics = { ...metrics, logStats, errorStats };
        createMetricsDisplay(metricsDisplay, extendedMetrics);
        clearElement(additionalStatsContainer);
        const additionalStats = additionalStatsContainer.createEl("div", { cls: "ksc-info-box" });
        additionalStats.createEl("strong", { text: "\uB85C\uADF8 \uD1B5\uACC4:" });
        additionalStats.createEl("br");
        const logMetrics = [
          `\uCD1D \uB85C\uADF8: ${logStats.total}`,
          `\uC5D0\uB7EC: ${logStats.ERROR}`,
          `\uACBD\uACE0: ${logStats.WARN}`,
          `\uC815\uBCF4: ${logStats.INFO}`
        ];
        logMetrics.forEach((metric) => {
          additionalStats.createEl("div", { text: `\u2022 ${metric}` });
        });
        additionalStats.createEl("br");
        additionalStats.createEl("strong", { text: "\uC5D0\uB7EC \uBD84\uB958:" });
        additionalStats.createEl("br");
        const errorMetrics = [
          `\uB124\uD2B8\uC6CC\uD06C: ${errorStats.NETWORK_ERROR}`,
          `API \uD0A4: ${errorStats.API_KEY_ERROR}`,
          `\uC694\uCCAD \uC81C\uD55C: ${errorStats.API_RATE_LIMIT}`,
          `\uC11C\uBC84: ${errorStats.API_SERVER_ERROR}`,
          `\uD0C0\uC784\uC544\uC6C3: ${errorStats.TIMEOUT_ERROR}`
        ];
        errorMetrics.forEach((metric) => {
          additionalStats.createEl("div", { text: `\u2022 ${metric}` });
        });
      } catch (error) {
        clearElement(metricsDisplay);
        metricsDisplay.createEl("div", { text: "\uBA54\uD2B8\uB9AD\uC744 \uAC00\uC838\uC62C \uC218 \uC5C6\uC2B5\uB2C8\uB2E4." });
      }
    };
    refreshBtn.onclick = updateMetrics;
    updateMetrics();
    const metricsInterval = setInterval(updateMetrics, 15e3);
    const originalHide = this.hide.bind(this);
    this.hide = () => {
      clearInterval(metricsInterval);
      originalHide();
    };
  }
  /**
   * Î°úÍ∑∏ Í¥ÄÎ¶¨ ÏÑπÏÖòÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§
   */
  createLogManagementSection(containerEl) {
    const { Logger: Logger2 } = (init_logger(), __toCommonJS(logger_exports));
    const logSection = containerEl.createEl("div", { cls: "ksc-section" });
    new import_obsidian9.Setting(logSection).setName("\u{1F4CB} \uB85C\uADF8 \uAD00\uB9AC").setDesc("\uD50C\uB7EC\uADF8\uC778 \uC2E4\uD589 \uB85C\uADF8\uB97C \uD655\uC778\uD558\uACE0 \uB2E4\uC6B4\uB85C\uB4DC\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4.").setHeading();
    const updateLogStats = () => {
      const stats = Logger2.getStats();
      const memUsage = Logger2.getMemoryUsage();
      const statsContainer2 = logSection.querySelector("#log-stats-container");
      if (statsContainer2) {
        clearElement(statsContainer2);
        const statsBox = statsContainer2.createEl("div", { cls: "ksc-info-box" });
        statsBox.createEl("strong", { text: "\u{1F4CA} \uB85C\uADF8 \uD1B5\uACC4" });
        statsBox.createEl("br");
        statsBox.createEl("div", { text: `\u2022 \uCD1D \uB85C\uADF8: ${stats.total}\uAC1C` });
        statsBox.createEl("div", { text: `\u2022 \uC815\uBCF4: ${stats.INFO}\uAC1C` });
        statsBox.createEl("div", { text: `\u2022 \uACBD\uACE0: ${stats.WARN}\uAC1C` });
        statsBox.createEl("div", { text: `\u2022 \uC624\uB958: ${stats.ERROR}\uAC1C` });
        statsBox.createEl("div", { text: `\u2022 \uB514\uBC84\uADF8: ${stats.DEBUG}\uAC1C` });
        statsBox.createEl("br");
        statsBox.createEl("div", { text: `\u2022 \uBA54\uBAA8\uB9AC \uC0AC\uC6A9\uB7C9: ${Math.round(memUsage.estimatedBytes / 1024)}KB` });
        statsBox.createEl("div", { text: `\u2022 \uCD5C\uB300 \uBCF4\uAD00: 1000\uAC1C` });
      }
    };
    const statsContainer = logSection.createEl("div", {
      attr: { id: "log-stats-container" }
    });
    const logViewerContainer = logSection.createEl("div", {
      attr: {
        id: "log-viewer-container",
        style: "display: none; margin-top: 16px;"
      }
    });
    const buttonGroup = logSection.createEl("div", { cls: "ksc-button-group" });
    const refreshStatsBtn = buttonGroup.createEl("button", { text: "\uD1B5\uACC4 \uC0C8\uB85C\uACE0\uCE68", cls: "mod-cta" });
    const viewLogsBtn = buttonGroup.createEl("button", { text: "\uB85C\uADF8 \uBCF4\uAE30" });
    const downloadLogsBtn = buttonGroup.createEl("button", { text: "\uB85C\uADF8 \uB2E4\uC6B4\uB85C\uB4DC" });
    const clearLogsBtn = buttonGroup.createEl("button", { text: "\uB85C\uADF8 \uC9C0\uC6B0\uAE30", cls: "mod-warning" });
    updateLogStats();
    refreshStatsBtn.onclick = updateLogStats;
    viewLogsBtn.onclick = () => {
      const isVisible = logViewerContainer.style.display !== "none";
      if (isVisible) {
        logViewerContainer.style.display = "none";
        viewLogsBtn.textContent = "\uB85C\uADF8 \uBCF4\uAE30";
      } else {
        this.displayLogViewer(logViewerContainer);
        logViewerContainer.style.display = "block";
        viewLogsBtn.textContent = "\uB85C\uADF8 \uC228\uAE30\uAE30";
      }
    };
    downloadLogsBtn.onclick = () => {
      this.downloadLogs();
    };
    clearLogsBtn.onclick = () => {
      if (confirm("\uBAA8\uB4E0 \uB85C\uADF8\uB97C \uC0AD\uC81C\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?")) {
        Logger2.clearHistory();
        updateLogStats();
        if (logViewerContainer.style.display !== "none") {
          this.displayLogViewer(logViewerContainer);
        }
      }
    };
  }
  /**
   * Î°úÍ∑∏ Î∑∞Ïñ¥Î•º ÌëúÏãúÌï©ÎãàÎã§
   */
  displayLogViewer(container) {
    const { Logger: Logger2 } = (init_logger(), __toCommonJS(logger_exports));
    clearElement(container);
    const logs = Logger2.getHistory();
    const filterContainer = container.createEl("div", { cls: "ksc-log-filter" });
    filterContainer.createEl("label", { text: "\uB808\uBCA8 \uD544\uD130:" });
    const levelSelect = filterContainer.createEl("select");
    levelSelect.createEl("option", { text: "\uC804\uCCB4", value: "" });
    levelSelect.createEl("option", { text: "\uC624\uB958", value: "ERROR" });
    levelSelect.createEl("option", { text: "\uACBD\uACE0", value: "WARN" });
    levelSelect.createEl("option", { text: "\uC815\uBCF4", value: "INFO" });
    levelSelect.createEl("option", { text: "\uB514\uBC84\uADF8", value: "DEBUG" });
    const logContent = container.createEl("div", { cls: "ksc-log-content" });
    const displayLogs = (filteredLogs) => {
      clearElement(logContent);
      if (filteredLogs.length === 0) {
        logContent.createEl("div", {
          text: "\uD45C\uC2DC\uD560 \uB85C\uADF8\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.",
          cls: "ksc-log-empty"
        });
        return;
      }
      const sortedLogs = [...filteredLogs].reverse();
      sortedLogs.forEach((log) => {
        const logLine = logContent.createEl("div", {
          cls: `ksc-log-line ksc-log-${log.level.toLowerCase()}`
        });
        const timestamp = log.timestamp.toLocaleString("ko-KR");
        const levelIcon = this.getLogLevelIcon(log.level);
        logLine.createEl("span", {
          text: `[${timestamp}] ${levelIcon} `,
          cls: "ksc-log-timestamp"
        });
        logLine.createEl("span", {
          text: log.message,
          cls: "ksc-log-message"
        });
        if (log.data) {
          logLine.createEl("br");
          logLine.createEl("span", {
            text: `  \uB370\uC774\uD130: ${JSON.stringify(log.data, null, 2)}`,
            cls: "ksc-log-data"
          });
        }
      });
    };
    displayLogs(logs);
    levelSelect.onchange = () => {
      const selectedLevel = levelSelect.value;
      const filteredLogs = selectedLevel ? logs.filter((log) => log.level === selectedLevel) : logs;
      displayLogs(filteredLogs);
    };
  }
  /**
   * Î°úÍ∑∏ Î†àÎ≤®Î≥Ñ ÏïÑÏù¥ÏΩòÏùÑ Î∞òÌôòÌï©ÎãàÎã§
   */
  getLogLevelIcon(level) {
    switch (level) {
      case "ERROR":
        return "\u274C";
      case "WARN":
        return "\u26A0\uFE0F";
      case "INFO":
        return "\u2139\uFE0F";
      case "DEBUG":
        return "\u{1F41B}";
      default:
        return "\u{1F4DD}";
    }
  }
  /**
   * Î°úÍ∑∏Î•º Îã§Ïö¥Î°úÎìúÌï©ÎãàÎã§
   */
  downloadLogs() {
    const { Logger: Logger2 } = (init_logger(), __toCommonJS(logger_exports));
    try {
      const logs = Logger2.getHistory();
      const stats = Logger2.getStats();
      const memUsage = Logger2.getMemoryUsage();
      const logData = {
        meta: {
          exportDate: new Date().toISOString(),
          pluginVersion: "0.2.0",
          totalLogs: stats.total,
          statistics: stats,
          memoryUsage: memUsage
        },
        logs: logs.map((log) => ({
          timestamp: log.timestamp.toISOString(),
          level: log.level,
          message: log.message,
          data: log.data
        }))
      };
      const jsonString = JSON.stringify(logData, null, 2);
      const blob = new Blob([jsonString], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const now = new Date();
      const timestamp = now.toISOString().replace(/T/, "_").replace(/:/g, "-").replace(/\.\d{3}Z$/, "");
      const a = document.createElement("a");
      a.href = url;
      a.download = `korean-grammar-logs-${timestamp}.json`;
      a.click();
      URL.revokeObjectURL(url);
      new import_obsidian9.Notice("\uB85C\uADF8\uAC00 \uB2E4\uC6B4\uB85C\uB4DC\uB418\uC5C8\uC2B5\uB2C8\uB2E4.");
    } catch (error) {
      Logger2.error("\uB85C\uADF8 \uB2E4\uC6B4\uB85C\uB4DC \uC624\uB958:", error);
      new import_obsidian9.Notice("\uB85C\uADF8 \uB2E4\uC6B4\uB85C\uB4DC \uC911 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4.");
    }
  }
  /**
   * ÏÑ±Îä• Ï†úÏñ¥ ÏÑπÏÖòÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§
   */
  createPerformanceControlSection(containerEl) {
    const controlSection = containerEl.createEl("div", { cls: "ksc-section" });
    new import_obsidian9.Setting(controlSection).setName("\u{1F527} \uC131\uB2A5 \uC81C\uC5B4").setDesc("\uCE90\uC2DC \uBC0F \uB300\uAE30 \uC911\uC778 \uC694\uCCAD\uC744 \uAD00\uB9AC\uD558\uC5EC \uC131\uB2A5\uC744 \uCD5C\uC801\uD654\uD569\uB2C8\uB2E4.").setHeading();
    const buttonGroup = controlSection.createEl("div", { cls: "ksc-button-group" });
    const clearCacheBtn = buttonGroup.createEl("button", { text: "\uCE90\uC2DC \uC815\uB9AC" });
    const cancelRequestsBtn = buttonGroup.createEl("button", { text: "\uB300\uAE30 \uC694\uCCAD \uCDE8\uC18C" });
    clearCacheBtn.onclick = () => {
      this.plugin.orchestrator.clearCache();
      const metricsDisplay = document.getElementById("metrics-display-container");
      const additionalStats = document.getElementById("additional-stats-container");
      if (metricsDisplay && additionalStats) {
        try {
          const metrics = this.plugin.orchestrator.getPerformanceMetrics();
          const { Logger: Logger2 } = (init_logger(), __toCommonJS(logger_exports));
          const { ErrorHandlerService: ErrorHandlerService2 } = (init_errorHandler(), __toCommonJS(errorHandler_exports));
          const logStats = Logger2.getStats();
          const errorStats = ErrorHandlerService2.getErrorStats();
          const extendedMetrics = { ...metrics, logStats, errorStats };
          createMetricsDisplay(metricsDisplay, extendedMetrics);
          clearElement(additionalStats);
          const additionalStatsBox = additionalStats.createEl("div", { cls: "ksc-info-box" });
          additionalStatsBox.createEl("strong", { text: "\uB85C\uADF8 \uD1B5\uACC4:" });
          additionalStatsBox.createEl("br");
          const logMetrics = [
            `\uCD1D \uB85C\uADF8: ${logStats.total}`,
            `\uC5D0\uB7EC: ${logStats.ERROR}`,
            `\uACBD\uACE0: ${logStats.WARN}`,
            `\uC815\uBCF4: ${logStats.INFO}`
          ];
          logMetrics.forEach((metric) => {
            additionalStatsBox.createEl("div", { text: `\u2022 ${metric}` });
          });
          additionalStatsBox.createEl("br");
          additionalStatsBox.createEl("strong", { text: "\uC5D0\uB7EC \uBD84\uB958:" });
          additionalStatsBox.createEl("br");
          const errorMetrics = [
            `\uB124\uD2B8\uC6CC\uD06C: ${errorStats.NETWORK_ERROR}`,
            `API \uD0A4: ${errorStats.API_KEY_ERROR}`,
            `\uC694\uCCAD \uC81C\uD55C: ${errorStats.API_RATE_LIMIT}`,
            `\uC11C\uBC84: ${errorStats.API_SERVER_ERROR}`,
            `\uD0C0\uC784\uC544\uC6C3: ${errorStats.TIMEOUT_ERROR}`
          ];
          errorMetrics.forEach((metric) => {
            additionalStatsBox.createEl("div", { text: `\u2022 ${metric}` });
          });
        } catch (error) {
          Logger.error("\uBA54\uD2B8\uB9AD \uC5C5\uB370\uC774\uD2B8 \uC624\uB958:", error);
        }
      }
    };
    cancelRequestsBtn.onclick = () => {
      this.plugin.orchestrator.cancelPendingRequests();
    };
    const tipsBox = controlSection.createEl("div", { cls: "ksc-info-box" });
    tipsBox.createEl("strong", { text: "\u{1F4A1} \uC131\uB2A5 \uCD5C\uC801\uD654 \uD301:" });
    tipsBox.createEl("br");
    tipsBox.createEl("br");
    const tips = [
      "\u2022 \uCE90\uC2DC \uC815\uB9AC: \uBA54\uBAA8\uB9AC \uC0AC\uC6A9\uB7C9\uC774 \uB192\uC744 \uB54C \uC2E4\uD589\uD558\uC138\uC694",
      "\u2022 \uC694\uCCAD \uCDE8\uC18C: \uB124\uD2B8\uC6CC\uD06C\uAC00 \uB290\uB9B4 \uB54C \uB300\uAE30 \uC911\uC778 \uC694\uCCAD\uC744 \uC815\uB9AC\uD558\uC138\uC694",
      "\u2022 AI \uD1A0\uD070 \uC218: 2000-3000 \uD1A0\uD070\uC774 \uC18D\uB3C4\uC640 \uD488\uC9C8\uC758 \uADE0\uD615\uC810\uC785\uB2C8\uB2E4",
      "\u2022 \uC608\uC678 \uB2E8\uC5B4: 500\uAC1C \uC774\uC0C1\uC77C \uB54C \uC815\uAE30\uC801\uC73C\uB85C \uC815\uB9AC\uD558\uC138\uC694"
    ];
    tips.forEach((tip) => {
      tipsBox.createEl("div", { text: tip });
    });
  }
  /**
   * Í∞úÏÑ†Îêú Í≤ÄÏ¶ù Í≤∞Í≥º ÎîîÏä§ÌîåÎ†àÏù¥
   */
  createImprovedValidationDisplay(parent, validation, suggestions) {
    clearElement(parent);
    const resultContainer = parent.createEl("div", { cls: "ksc-validation-result" });
    const statusCard = resultContainer.createEl("div", { cls: "ksc-status-card" });
    const statusLine = statusCard.createEl("div", { cls: "ksc-status-line" });
    const statusIcon = statusLine.createEl("span", {
      text: validation.isValid ? "\u2705" : "\u274C",
      cls: "ksc-status-icon"
    });
    const statusText = statusLine.createEl("span", {
      text: validation.isValid ? "\uBAA8\uB4E0 \uC124\uC815\uC774 \uC815\uC0C1\uC785\uB2C8\uB2E4" : "\uC77C\uBD80 \uC124\uC815\uC5D0 \uBB38\uC81C\uAC00 \uC788\uC2B5\uB2C8\uB2E4",
      cls: "ksc-status-text"
    });
    if (!validation.isValid) {
      if (validation.errors && validation.errors.length > 0) {
        const problemsSection = resultContainer.createEl("div", { cls: "ksc-problems-section" });
        problemsSection.createEl("div", {
          text: "\u{1F527} \uD574\uACB0\uD574\uC57C \uD560 \uBB38\uC81C",
          cls: "ksc-section-title"
        });
        const problemsList = problemsSection.createEl("ul", { cls: "ksc-problems-list" });
        validation.errors.forEach((error) => {
          problemsList.createEl("li", { text: error });
        });
      }
    }
    if (validation.warnings && validation.warnings.length > 0) {
      const warningsSection = resultContainer.createEl("div", { cls: "ksc-warnings-section" });
      warningsSection.createEl("div", {
        text: "\u26A0\uFE0F \uC8FC\uC758\uC0AC\uD56D",
        cls: "ksc-section-title"
      });
      const warningsList = warningsSection.createEl("ul", { cls: "ksc-warnings-list" });
      validation.warnings.forEach((warning) => {
        warningsList.createEl("li", { text: warning });
      });
    }
    if (suggestions && suggestions.length > 0) {
      const suggestionsSection = resultContainer.createEl("div", { cls: "ksc-suggestions-section" });
      suggestionsSection.createEl("div", {
        text: "\u{1F4A1} \uAC1C\uC120 \uC81C\uC548",
        cls: "ksc-section-title"
      });
      suggestions.forEach((suggestion) => {
        const suggestionCard = suggestionsSection.createEl("div", { cls: "ksc-suggestion-card" });
        const impactBadge = suggestion.impact === "high" ? "\u{1F534}" : suggestion.impact === "medium" ? "\u{1F7E1}" : "\u{1F7E2}";
        suggestionCard.createEl("div", {
          text: `${impactBadge} ${suggestion.title}`,
          cls: "ksc-suggestion-title"
        });
        suggestionCard.createEl("div", {
          text: suggestion.action,
          cls: "ksc-suggestion-desc"
        });
      });
    }
    const summarySection = resultContainer.createEl("div", { cls: "ksc-summary-section" });
    summarySection.createEl("div", {
      text: "\u{1F4CB} \uD604\uC7AC \uC124\uC815 \uC0C1\uD0DC",
      cls: "ksc-section-title"
    });
    const summaryGrid = summarySection.createEl("div", { cls: "ksc-summary-grid" });
    const apiStatus = summaryGrid.createEl("div", { cls: "ksc-summary-item" });
    apiStatus.createEl("span", { text: "API", cls: "ksc-summary-label" });
    apiStatus.createEl("span", {
      text: this.plugin.settings.apiKey ? "\u2713 \uC124\uC815\uB428" : "\u2717 \uBBF8\uC124\uC815",
      cls: this.plugin.settings.apiKey ? "ksc-status-ok" : "ksc-status-error"
    });
    const aiStatus = summaryGrid.createEl("div", { cls: "ksc-summary-item" });
    aiStatus.createEl("span", { text: "AI \uAE30\uB2A5", cls: "ksc-summary-label" });
    const aiText = this.plugin.settings.ai.enabled ? `\u2713 ${this.plugin.settings.ai.provider.toUpperCase()}` : "\u2717 \uBE44\uD65C\uC131\uD654";
    aiStatus.createEl("span", {
      text: aiText,
      cls: this.plugin.settings.ai.enabled ? "ksc-status-ok" : "ksc-status-disabled"
    });
    const ignoredStatus = summaryGrid.createEl("div", { cls: "ksc-summary-item" });
    ignoredStatus.createEl("span", { text: "\uC608\uC678 \uB2E8\uC5B4", cls: "ksc-summary-label" });
    const wordCount = this.plugin.settings.ignoredWords.length;
    const wordStatus = wordCount === 0 ? "\uC5C6\uC74C" : wordCount > 100 ? `${wordCount}\uAC1C (\uB9CE\uC74C)` : `${wordCount}\uAC1C`;
    ignoredStatus.createEl("span", {
      text: wordStatus,
      cls: wordCount > 100 ? "ksc-status-warning" : "ksc-status-ok"
    });
  }
  /**
   * ÌïÑÌÑ∞ÎßÅ ÏòµÏÖò ÏÑπÏÖòÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§
   */
  createFilteringOptionsSection(containerEl) {
    const section = containerEl.createEl("div", { cls: "ksc-section" });
    new import_obsidian9.Setting(section).setName("\u{1F50D} \uD544\uD130\uB9C1 \uC635\uC158").setDesc("\uB9DE\uCDA4\uBC95 \uAC80\uC0AC \uACB0\uACFC\uB97C \uD544\uD130\uB9C1\uD558\uB294 \uC635\uC158\uC744 \uC124\uC815\uD569\uB2C8\uB2E4.").setHeading();
    new import_obsidian9.Setting(section).setName("\uD55C \uAE00\uC790 \uC624\uB958 \uD544\uD130\uB9C1").setDesc("\uD55C \uAE00\uC790\uB85C \uB41C \uB9DE\uCDA4\uBC95 \uC624\uB958 \uC81C\uC548\uC744 \uD544\uD130\uB9C1\uD569\uB2C8\uB2E4. \uC758\uBBF8\uC788\uB294 \uAD50\uC815(\uC870\uC0AC, \uC5B4\uBBF8 \uB4F1)\uC740 \uC608\uC678 \uCC98\uB9AC\uB429\uB2C8\uB2E4.").addToggle((toggle) => toggle.setValue(this.plugin.settings.filterSingleCharErrors).onChange(async (value) => {
      this.plugin.settings.filterSingleCharErrors = value;
      await this.plugin.saveSettings();
    }));
    const infoBox = section.createEl("div", { cls: "ksc-info-box" });
    infoBox.createEl("strong", { text: "\u{1F6E1}\uFE0F \uC608\uC678 \uCC98\uB9AC\uB418\uB294 \uD55C \uAE00\uC790 \uAD50\uC815" });
    infoBox.createEl("br");
    infoBox.createEl("br");
    const exceptions = [
      '\u2022 \uC22B\uC790/\uC601\uBB38 \u2192 \uD55C\uAE00 \uBCC0\uD658 (\uC608: "1" \u2192 "\uC77C")',
      '\u2022 \uD2B9\uC218\uBB38\uC790 \u2192 \uD55C\uAE00 \uBCC0\uD658 (\uC608: "@" \u2192 "\uC5D0")',
      '\u2022 \uC790\uC8FC \uD2C0\uB9AC\uB294 \uC870\uC0AC/\uC5B4\uBBF8 (\uC608: "\uB418" \u2194 "\uB3FC", "\uC548" \u2194 "\uC54A")',
      '\u2022 \uD55C \uAE00\uC790 \u2192 \uC5EC\uB7EC \uAE00\uC790 \uD655\uC7A5 (\uC608: "\uD558" \u2192 "\uD558\uC5EC")'
    ];
    exceptions.forEach((exception) => {
      infoBox.createEl("div", {
        text: exception,
        attr: { style: "margin-bottom: 4px; color: var(--text-muted);" }
      });
    });
    const statsContainer = section.createEl("div", { cls: "ksc-filter-stats" });
    this.updateFilteringStats(statsContainer);
  }
  /**
   * ÌïÑÌÑ∞ÎßÅ ÌÜµÍ≥ÑÎ•º ÏóÖÎç∞Ïù¥Ìä∏Ìï©ÎãàÎã§
   */
  updateFilteringStats(container) {
    container.empty();
    const statsBox = container.createEl("div", {
      cls: "ksc-stats-box",
      attr: { style: "margin-top: 12px; padding: 12px; background: var(--background-secondary); border-radius: 6px;" }
    });
    statsBox.createEl("div", {
      text: "\u{1F4CA} \uD544\uD130\uB9C1 \uD1B5\uACC4",
      attr: { style: "font-weight: 600; margin-bottom: 8px;" }
    });
    const statusText = this.plugin.settings.filterSingleCharErrors ? "\u2705 \uD55C \uAE00\uC790 \uC624\uB958 \uD544\uD130\uB9C1\uC774 \uD65C\uC131\uD654\uB418\uC5B4 \uC788\uC2B5\uB2C8\uB2E4." : "\u26A0\uFE0F \uD55C \uAE00\uC790 \uC624\uB958 \uD544\uD130\uB9C1\uC774 \uBE44\uD65C\uC131\uD654\uB418\uC5B4 \uC788\uC2B5\uB2C8\uB2E4.";
    statsBox.createEl("div", {
      text: statusText,
      attr: { style: "color: var(--text-muted); font-size: 14px;" }
    });
    if (this.plugin.settings.filterSingleCharErrors) {
      statsBox.createEl("div", {
        text: "\u{1F4A1} \uD301: \uC758\uBBF8\uC788\uB294 \uD55C \uAE00\uC790 \uAD50\uC815(\uC870\uC0AC, \uC5B4\uBBF8 \uB4F1)\uC740 \uC790\uB3D9\uC73C\uB85C \uC608\uC678 \uCC98\uB9AC\uB429\uB2C8\uB2E4.",
        attr: { style: "color: var(--text-accent); font-size: 13px; margin-top: 4px;" }
      });
    }
  }
  /**
   * Î≤†ÌÉÄ Í∏∞Îä• ÌÉ≠ÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§
   */
  createBetaFeaturesTab(containerEl) {
    this.createBetaWarningSection(containerEl);
    this.createInlineModeSection(containerEl);
  }
  /**
   * Î≤†ÌÉÄ Í∏∞Îä• Í≤ΩÍ≥† ÏÑπÏÖòÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§
   */
  createBetaWarningSection(containerEl) {
    const section = containerEl.createEl("div", { cls: "ksc-section" });
    section.createEl("h3", {
      text: "\u26A0\uFE0F \uBCA0\uD0C0 \uAE30\uB2A5 \uC548\uB0B4",
      cls: "ksc-section-title"
    });
    const warningBox = section.createEl("div", {
      cls: "ksc-warning-box",
      attr: {
        style: "background: rgba(255, 196, 0, 0.1); border: 1px solid rgba(255, 196, 0, 0.3); border-radius: 8px; padding: 16px; margin-bottom: 20px;"
      }
    });
    warningBox.createEl("div", {
      text: "\u{1F9EA} \uC2E4\uD5D8\uC801 \uAE30\uB2A5",
      attr: { style: "font-weight: 600; color: var(--text-warning); margin-bottom: 8px;" }
    });
    const warnings = [
      "\uC774 \uC139\uC158\uC758 \uAE30\uB2A5\uB4E4\uC740 \uBCA0\uD0C0 \uBC84\uC804\uC785\uB2C8\uB2E4.",
      "\uC77C\uBD80 \uAE30\uB2A5\uC774 \uC608\uC0C1\uACFC \uB2E4\uB974\uAC8C \uB3D9\uC791\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4.",
      "\uD53C\uB4DC\uBC31\uACFC \uBC84\uADF8 \uB9AC\uD3EC\uD2B8\uB294 \uC5B8\uC81C\uB098 \uD658\uC601\uD569\uB2C8\uB2E4.",
      "\uC548\uC815\uD654 \uD6C4 \uC815\uC2DD \uAE30\uB2A5\uC73C\uB85C \uC2B9\uACA9\uB420 \uC608\uC815\uC785\uB2C8\uB2E4."
    ];
    warnings.forEach((warning) => {
      warningBox.createEl("div", {
        text: `\u2022 ${warning}`,
        attr: { style: "color: var(--text-muted); margin-bottom: 4px; font-size: 14px;" }
      });
    });
  }
  /**
   * Ïù∏ÎùºÏù∏ Î™®Îìú ÏÑ§Ï†ï ÏÑπÏÖòÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§
   */
  createInlineModeSection(containerEl) {
    const section = containerEl.createEl("div", { cls: "ksc-section" });
    section.createEl("h3", {
      text: "\u{1F4DD} \uC778\uB77C\uC778 \uBAA8\uB4DC",
      cls: "ksc-section-title"
    });
    const descBox = section.createEl("div", {
      cls: "ksc-info-box",
      attr: {
        style: "background: var(--background-secondary); border-radius: 8px; padding: 16px; margin-bottom: 20px;"
      }
    });
    descBox.createEl("div", {
      text: "\u{1F3AF} \uC5D0\uB514\uD130 \uB0B4 \uC2E4\uC2DC\uAC04 \uB9DE\uCDA4\uBC95 \uAC80\uC0AC",
      attr: { style: "font-weight: 600; margin-bottom: 8px;" }
    });
    const features = [
      "\uC624\uD0C0 \uD14D\uC2A4\uD2B8\uC5D0 \uBC11\uC904 \uD45C\uC2DC",
      "\uD638\uBC84/\uD074\uB9AD\uC73C\uB85C \uC218\uC815 \uC81C\uC548 \uD655\uC778",
      "\uC0AC\uC6A9\uC790 \uD3B8\uC9D1 \uC2DC \uBC11\uC904 \uC790\uB3D9 \uC81C\uAC70",
      "Command Palette\uB85C \uAC80\uC0AC \uC2E4\uD589"
    ];
    features.forEach((feature) => {
      descBox.createEl("div", {
        text: `\u2022 ${feature}`,
        attr: { style: "color: var(--text-muted); margin-bottom: 4px;" }
      });
    });
    new import_obsidian9.Setting(section).setName("\uC778\uB77C\uC778 \uBAA8\uB4DC \uD65C\uC131\uD654").setDesc("\uC5D0\uB514\uD130 \uB0B4\uC5D0\uC11C \uC2E4\uC2DC\uAC04\uC73C\uB85C \uB9DE\uCDA4\uBC95 \uC624\uB958\uB97C \uD45C\uC2DC\uD569\uB2C8\uB2E4.").addToggle((toggle) => toggle.setValue(this.plugin.settings.inlineMode.enabled).onChange(async (value) => {
      this.plugin.settings.inlineMode.enabled = value;
      await this.plugin.saveSettings();
      Logger.log(`\uC778\uB77C\uC778 \uBAA8\uB4DC\uAC00 ${value ? "\uD65C\uC131\uD654" : "\uBE44\uD65C\uC131\uD654"}\uB418\uC5C8\uC2B5\uB2C8\uB2E4.`);
      new import_obsidian9.Notice(`\uC778\uB77C\uC778 \uBAA8\uB4DC\uAC00 ${value ? "\uD65C\uC131\uD654" : "\uBE44\uD65C\uC131\uD654"}\uB418\uC5C8\uC2B5\uB2C8\uB2E4.`);
    }));
    if (this.plugin.settings.inlineMode.enabled) {
      new import_obsidian9.Setting(section).setName("\uBC11\uC904 \uC2A4\uD0C0\uC77C").setDesc("\uC624\uB958 \uD45C\uC2DC\uC5D0 \uC0AC\uC6A9\uD560 \uBC11\uC904 \uC2A4\uD0C0\uC77C\uC744 \uC120\uD0DD\uD558\uC138\uC694.").addDropdown((dropdown) => dropdown.addOption("wavy", "\uBB3C\uACB0\uC120 (\uCD94\uCC9C)").addOption("solid", "\uC9C1\uC120").addOption("dotted", "\uC810\uC120").addOption("dashed", "\uD30C\uC120").setValue(this.plugin.settings.inlineMode.underlineStyle).onChange(async (value) => {
        this.plugin.settings.inlineMode.underlineStyle = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian9.Setting(section).setName("\uBC11\uC904 \uC0C9\uC0C1").setDesc("\uC624\uB958 \uD45C\uC2DC\uC5D0 \uC0AC\uC6A9\uD560 \uBC11\uC904 \uC0C9\uC0C1\uC744 \uC124\uC815\uD558\uC138\uC694.").addText((text) => text.setPlaceholder("#ff0000").setValue(this.plugin.settings.inlineMode.underlineColor).onChange(async (value) => {
        if (/^#[0-9A-Fa-f]{6}$/.test(value)) {
          this.plugin.settings.inlineMode.underlineColor = value;
          await this.plugin.saveSettings();
        }
      }));
      new import_obsidian9.Setting(section).setName("\uD234\uD301 \uD45C\uC2DC \uBC29\uC2DD").setDesc('\uBB38\uBC95 \uC624\uB958 \uC218\uC815 \uC81C\uC548\uC744 \uD45C\uC2DC\uD560 \uBC29\uBC95\uC744 \uC120\uD0DD\uD558\uC138\uC694. "\uC790\uB3D9"\uC740 \uD50C\uB7AB\uD3FC\uC5D0 \uCD5C\uC801\uD654\uB41C \uBC29\uC2DD\uC744 \uC0AC\uC6A9\uD569\uB2C8\uB2E4.').addDropdown((dropdown) => dropdown.addOption("auto", "\u{1F916} \uC790\uB3D9 (\uAD8C\uC7A5) - \uD50C\uB7AB\uD3FC\uBCC4 \uCD5C\uC801\uD654").addOption("hover", "\u{1F5B1}\uFE0F \uB9C8\uC6B0\uC2A4 \uD638\uBC84 - \uB370\uC2A4\uD06C\uD1B1 \uC804\uC6A9").addOption("click", "\u{1F446} \uD074\uB9AD/\uD0ED - \uBAA8\uBC14\uC77C \uCE5C\uD654\uC801").addOption("disabled", "\u{1F6AB} \uD234\uD301 \uBE44\uD65C\uC131\uD654").setValue(this.plugin.settings.inlineMode.tooltipTrigger || "auto").onChange(async (value) => {
        this.plugin.settings.inlineMode.tooltipTrigger = value;
        switch (value) {
          case "auto":
            this.plugin.settings.inlineMode.showTooltipOnHover = true;
            this.plugin.settings.inlineMode.showTooltipOnClick = true;
            break;
          case "hover":
            this.plugin.settings.inlineMode.showTooltipOnHover = true;
            this.plugin.settings.inlineMode.showTooltipOnClick = false;
            break;
          case "click":
            this.plugin.settings.inlineMode.showTooltipOnHover = false;
            this.plugin.settings.inlineMode.showTooltipOnClick = true;
            break;
          case "disabled":
            this.plugin.settings.inlineMode.showTooltipOnHover = false;
            this.plugin.settings.inlineMode.showTooltipOnClick = false;
            break;
        }
        await this.plugin.saveSettings();
        const modeNames = {
          "auto": "\uC790\uB3D9 \uBAA8\uB4DC (\uD50C\uB7AB\uD3FC\uBCC4 \uCD5C\uC801\uD654)",
          "hover": "\uD638\uBC84 \uBAA8\uB4DC (\uB370\uC2A4\uD06C\uD1B1 \uC804\uC6A9)",
          "click": "\uD074\uB9AD \uBAA8\uB4DC (\uBAA8\uBC14\uC77C \uCE5C\uD654\uC801)",
          "disabled": "\uD234\uD301 \uBE44\uD65C\uC131\uD654"
        };
        new import_obsidian9.Notice(`\uD234\uD301 \uD45C\uC2DC \uBC29\uC2DD: ${modeNames[value]}`);
      }));
      section.createEl("div", {
        text: "\u{1F4A1} \uC790\uB3D9 \uBAA8\uB4DC: \uB370\uC2A4\uD06C\uD1B1\uC5D0\uC11C\uB294 \uD638\uBC84, \uBAA8\uBC14\uC77C\uC5D0\uC11C\uB294 \uD0ED\uC73C\uB85C \uC790\uB3D9 \uB3D9\uC791",
        attr: {
          style: "font-size: 0.9em; color: var(--text-muted); margin-top: 8px; padding: 8px; background: var(--background-secondary); border-radius: 4px;"
        }
      });
    }
  }
};

// main.ts
init_logger();

// src/services/inlineModeService.ts
var import_view = require("@codemirror/view");
var import_state = require("@codemirror/state");
init_logger();

// src/ui/inlineTooltip.ts
init_logger();
var import_obsidian10 = require("obsidian");
var InlineTooltip = class {
  constructor() {
    this.tooltip = null;
    this.currentError = null;
    this.isVisible = false;
    this.hoverTimeout = null;
    this.hideTimeout = null;
  }
  /**
   * Ìà¥ÌåÅ ÌëúÏãú
   */
  show(error, targetElement, triggerType, mousePosition) {
    var _a;
    if (this.isVisible && ((_a = this.currentError) == null ? void 0 : _a.uniqueId) === error.uniqueId) {
      Logger.debug(`\uC778\uB77C\uC778 \uD234\uD301 \uC774\uBBF8 \uD45C\uC2DC \uC911: ${error.correction.original}`);
      return;
    }
    this.hide();
    this.currentError = error;
    this.hideCursorInBackground();
    if (import_obsidian10.Platform.isMobile) {
      this.hideKeyboardAndBlurEditor();
    }
    this.createTooltip(error, targetElement, triggerType);
    this.positionTooltip(targetElement, mousePosition);
    this.isVisible = true;
    Logger.log(`\uC778\uB77C\uC778 \uD234\uD301 \uD45C\uC2DC: "${error.correction.original}" (${triggerType})`);
  }
  /**
   * Ìà¥ÌåÅ Ïà®ÍπÄ
   */
  hide() {
    if (this.tooltip) {
      this.tooltip.remove();
      this.tooltip = null;
    }
    this.showCursorInBackground();
    this.isVisible = false;
    this.currentError = null;
    if (this.hoverTimeout) {
      clearTimeout(this.hoverTimeout);
      this.hoverTimeout = null;
    }
    if (this.hideTimeout) {
      clearTimeout(this.hideTimeout);
      this.hideTimeout = null;
    }
  }
  /**
   * Ìà¥ÌåÅÏù¥ ÌëúÏãú Ï§ëÏù∏ÏßÄ ÌôïÏù∏
   */
  get visible() {
    return this.isVisible;
  }
  /**
   * Ìà¥ÌåÅ ÏÉùÏÑ±
   */
  createTooltip(error, targetElement, triggerType) {
    this.tooltip = document.createElement("div");
    this.tooltip.className = "korean-grammar-inline-tooltip";
    const isMobile = import_obsidian10.Platform.isMobile;
    this.tooltip.style.cssText = `
      position: absolute;
      background: var(--background-primary);
      border: 1px solid var(--background-modifier-border);
      border-radius: ${isMobile ? "12px" : "6px"};
      padding: 0;
      box-shadow: ${isMobile ? "0 8px 32px rgba(0, 0, 0, 0.3)" : "var(--shadow-s)"};
      z-index: 1000;
      font-size: ${isMobile ? "14px" : "13px"};
      color: var(--text-normal);
      display: flex;
      flex-direction: column;
      ${isMobile ? "max-height: 200px;" : "max-height: 300px;"}
      overflow-y: auto;
      ${isMobile ? "touch-action: manipulation;" : ""}
    `;
    if (isMobile) {
      this.tooltip.addEventListener("touchstart", (e) => {
        e.stopPropagation();
      }, { passive: true });
      this.tooltip.addEventListener("touchend", (e) => {
        e.stopPropagation();
      }, { passive: true });
    }
    if (error.isMerged && error.originalErrors && error.originalErrors.length > 0) {
      this.createMergedErrorTooltip(error, targetElement);
    } else {
      this.createSingleErrorTooltip(error, targetElement, triggerType);
    }
    document.body.appendChild(this.tooltip);
    if (isMobile) {
      Logger.log(`\u{1F4F1} \uBAA8\uBC14\uC77C \uD234\uD301 \uC0DD\uC131: ${error.correction.original} (${triggerType})`);
    }
  }
  /**
   * Ìà¥ÌåÅ ÏúÑÏπò Ï°∞Ï†ï (Obsidian API Í∏∞Î∞ò Í≥†Í∏â Ï≤òÎ¶¨)
   */
  positionTooltip(targetElement, mousePosition) {
    if (!this.tooltip)
      return;
    const targetRect = targetElement.getBoundingClientRect();
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    const isMobile = import_obsidian10.Platform.isMobile;
    const isPhone = import_obsidian10.Platform.isPhone || viewportWidth <= 480;
    const isTablet = import_obsidian10.Platform.isTablet || viewportWidth <= 768 && viewportWidth > 480;
    const app = window.app;
    let editorScrollInfo = null;
    let editorContainerRect = null;
    if (app && app.workspace) {
      try {
        const activeView = app.workspace.getActiveViewOfType(import_obsidian10.MarkdownView);
        if (activeView && activeView.editor) {
          editorScrollInfo = activeView.editor.getScrollInfo();
          if (activeView.containerEl) {
            editorContainerRect = activeView.containerEl.getBoundingClientRect();
          }
        }
      } catch (error) {
        Logger.debug("Obsidian API \uC811\uADFC \uC911 \uC624\uB958 (\uBB34\uC2DC\uB428):", error);
      }
    }
    const scrollTop = (editorScrollInfo == null ? void 0 : editorScrollInfo.top) || window.pageYOffset || document.documentElement.scrollTop;
    const scrollLeft = (editorScrollInfo == null ? void 0 : editorScrollInfo.left) || window.pageXOffset || document.documentElement.scrollLeft;
    const baseViewportHeight = window.screen.height || viewportHeight;
    const keyboardVisible = isMobile && viewportHeight < baseViewportHeight * 0.75;
    const keyboardHeight = keyboardVisible ? baseViewportHeight - viewportHeight : 0;
    Logger.debug(`\u{1F527} \uC704\uCE58 \uACC4\uC0B0 \uC815\uBCF4:`, {
      isMobile,
      isPhone,
      isTablet,
      viewportSize: `${viewportWidth}x${viewportHeight}`,
      keyboardVisible,
      keyboardHeight,
      targetRect: `${targetRect.left},${targetRect.top} ${targetRect.width}x${targetRect.height}`,
      scroll: `${scrollLeft},${scrollTop}`,
      editorContainer: editorContainerRect ? `${editorContainerRect.width}x${editorContainerRect.height}` : "none",
      obsidianAPI: !!app
    });
    if (isMobile) {
      this.positionTooltipMobile(targetElement, targetRect, viewportWidth, viewportHeight, keyboardHeight, isPhone, editorContainerRect, mousePosition);
    } else {
      this.positionTooltipDesktop(targetElement, targetRect, viewportWidth, viewportHeight, editorContainerRect, mousePosition);
    }
  }
  /**
   * Î™®Î∞îÏùº Ìà¥ÌåÅ ÏúÑÏπò Í≥ÑÏÇ∞ (ÌôîÎ©¥ Íµ¨ÏÑù ÏôÑÏ†Ñ ÎåÄÏùë)
   */
  positionTooltipMobile(targetElement, targetRect, viewportWidth, viewportHeight, keyboardHeight, isPhone, editorContainerRect = null, mousePosition) {
    if (!this.tooltip)
      return;
    const editorLeft = (editorContainerRect == null ? void 0 : editorContainerRect.left) || 0;
    const editorTop = (editorContainerRect == null ? void 0 : editorContainerRect.top) || 0;
    const editorWidth = (editorContainerRect == null ? void 0 : editorContainerRect.width) || viewportWidth;
    const editorHeight = (editorContainerRect == null ? void 0 : editorContainerRect.height) || viewportHeight;
    const adaptiveSize = this.calculateAdaptiveTooltipSize(
      viewportWidth,
      viewportHeight,
      keyboardHeight,
      isPhone,
      editorWidth,
      editorHeight
    );
    this.tooltip.style.width = `${adaptiveSize.width}px`;
    this.tooltip.style.maxHeight = `${adaptiveSize.maxHeight}px`;
    this.tooltip.style.minWidth = `${adaptiveSize.minWidth}px`;
    this.tooltip.style.fontSize = adaptiveSize.fontSize;
    let referenceCenterX;
    let referenceCenterY;
    if (mousePosition) {
      referenceCenterX = mousePosition.x;
      referenceCenterY = mousePosition.y;
      Logger.debug(`\u{1F3AF} \uD130\uCE58 \uC704\uCE58 \uAE30\uBC18 \uD234\uD301 \uBC30\uCE58: (${mousePosition.x}, ${mousePosition.y})`);
    } else {
      referenceCenterX = targetRect.left + targetRect.width / 2;
      referenceCenterY = targetRect.top + targetRect.height / 2;
      Logger.debug(`\u{1F4CD} \uD0C0\uAC9F \uC694\uC18C \uAE30\uBC18 \uD234\uD301 \uBC30\uCE58: (${referenceCenterX}, ${referenceCenterY})`);
    }
    const cornerThreshold = mousePosition ? 40 : 60;
    const effectiveLeft = Math.max(referenceCenterX - 8, editorLeft);
    const effectiveRight = Math.min(referenceCenterX + 8, editorLeft + editorWidth);
    const effectiveTop = Math.max(referenceCenterY - 10, editorTop);
    const effectiveBottom = Math.min(referenceCenterY + 10, editorTop + editorHeight);
    const isLeftEdge = effectiveLeft - editorLeft < cornerThreshold;
    const isRightEdge = editorLeft + editorWidth - effectiveRight < cornerThreshold;
    const isTopEdge = effectiveTop - editorTop < cornerThreshold;
    const isBottomEdge = editorTop + editorHeight - effectiveBottom < cornerThreshold;
    const fingerOffset = mousePosition ? isPhone ? 35 : 30 : isPhone ? 60 : 50;
    const safeMargin = 16;
    let finalLeft = 0;
    let finalTop = 0;
    if (isLeftEdge) {
      finalLeft = Math.max(safeMargin, editorLeft + safeMargin);
      Logger.debug("\u{1F4F1} \uC67C\uCABD \uAD6C\uC11D \uAC10\uC9C0: \uC5D0\uB514\uD130 \uC601\uC5ED \uB0B4 \uC624\uB978\uCABD\uC73C\uB85C \uC774\uB3D9");
    } else if (isRightEdge) {
      finalLeft = Math.min(viewportWidth - adaptiveSize.width - safeMargin, editorLeft + editorWidth - adaptiveSize.width - safeMargin);
      Logger.debug("\u{1F4F1} \uC624\uB978\uCABD \uAD6C\uC11D \uAC10\uC9C0: \uC5D0\uB514\uD130 \uC601\uC5ED \uB0B4 \uC67C\uCABD\uC73C\uB85C \uC774\uB3D9");
    } else {
      if (mousePosition) {
        finalLeft = Math.max(safeMargin, Math.min(
          referenceCenterX - adaptiveSize.width / 2,
          viewportWidth - adaptiveSize.width - safeMargin
        ));
      } else {
        const editorCenterX = editorLeft + editorWidth / 2;
        finalLeft = Math.max(safeMargin, Math.min(
          editorCenterX - adaptiveSize.width / 2,
          viewportWidth - adaptiveSize.width - safeMargin
        ));
      }
    }
    const effectiveViewportHeight = Math.min(viewportHeight - keyboardHeight, editorTop + editorHeight);
    const spaceAbove = referenceCenterY - editorTop;
    const spaceBelow = effectiveViewportHeight - referenceCenterY;
    if (isTopEdge && spaceBelow > adaptiveSize.maxHeight + fingerOffset + safeMargin) {
      finalTop = referenceCenterY + fingerOffset;
      Logger.debug(`\u{1F4F1} \uC0C1\uB2E8 \uAD6C\uC11D: \uC544\uB798\uCABD \uBC30\uCE58 (\uC624\uD504\uC14B: ${fingerOffset}px)`);
    } else if (isBottomEdge && spaceAbove > adaptiveSize.maxHeight + fingerOffset + safeMargin) {
      finalTop = referenceCenterY - adaptiveSize.maxHeight - fingerOffset;
      Logger.debug(`\u{1F4F1} \uD558\uB2E8 \uAD6C\uC11D: \uC704\uCABD \uBC30\uCE58 (\uC624\uD504\uC14B: ${fingerOffset}px)`);
    } else if (spaceAbove > adaptiveSize.maxHeight + fingerOffset + safeMargin) {
      finalTop = referenceCenterY - adaptiveSize.maxHeight - (mousePosition ? 20 : 30);
      Logger.debug(`\u{1F4F1} \uC704\uCABD \uBC30\uCE58 (\uD130\uCE58 \uCD5C\uC801\uD654)`);
    } else if (spaceBelow > adaptiveSize.maxHeight + fingerOffset + safeMargin) {
      finalTop = referenceCenterY + (mousePosition ? 20 : 30);
      Logger.debug(`\u{1F4F1} \uC544\uB798\uCABD \uBC30\uCE58 (\uD130\uCE58 \uCD5C\uC801\uD654)`);
    } else {
      const centerY = effectiveViewportHeight / 2;
      if (Math.abs(centerY - referenceCenterY) < adaptiveSize.maxHeight / 2) {
        finalTop = Math.max(editorTop + safeMargin, referenceCenterY - adaptiveSize.maxHeight - 10);
      } else {
        finalTop = Math.max(editorTop + safeMargin, centerY - adaptiveSize.maxHeight / 2);
      }
      Logger.debug("\u{1F4F1} \uACF5\uAC04 \uBD80\uC871: \uD130\uCE58 \uC9C0\uC810 \uC778\uC811 \uBC30\uCE58");
    }
    finalTop = Math.max(
      Math.max(safeMargin, editorTop),
      Math.min(finalTop, effectiveViewportHeight - adaptiveSize.maxHeight - safeMargin)
    );
    finalLeft = Math.max(safeMargin, Math.min(finalLeft, viewportWidth - adaptiveSize.width - safeMargin));
    this.tooltip.style.position = "fixed";
    this.tooltip.style.left = `${finalLeft}px`;
    this.tooltip.style.top = `${finalTop}px`;
    this.tooltip.style.zIndex = "1000";
    this.tooltip.style.visibility = "visible";
    this.tooltip.style.boxShadow = "0 8px 32px rgba(0, 0, 0, 0.3)";
    this.tooltip.style.borderRadius = "12px";
    Logger.log(`\u{1F4F1} \uCD5C\uC885 \uBAA8\uBC14\uC77C \uD234\uD301 \uC704\uCE58: ${adaptiveSize.width}x${adaptiveSize.maxHeight} at (${finalLeft}, ${finalTop})`, {
      corners: { isLeftEdge, isRightEdge, isTopEdge, isBottomEdge },
      keyboard: { visible: keyboardHeight > 0, height: keyboardHeight },
      spaces: { above: spaceAbove, below: spaceBelow },
      editor: editorContainerRect ? `${editorWidth}x${editorHeight} at (${editorLeft}, ${editorTop})` : "none",
      adaptive: `${adaptiveSize.width}px (\uB0B4\uC6A9 \uB9DE\uCDA4)`,
      touchMode: mousePosition ? `touch (${mousePosition.x}, ${mousePosition.y})` : "element center",
      reference: `(${referenceCenterX}, ${referenceCenterY})`
    });
  }
  /**
   * Îç∞Ïä§ÌÅ¨ÌÜ± Ìà¥ÌåÅ ÏúÑÏπò Í≥ÑÏÇ∞ (Í∞úÏÑ†Îêú Íµ¨ÏÑù Ï≤òÎ¶¨)
   */
  positionTooltipDesktop(targetElement, targetRect, viewportWidth, viewportHeight, editorContainerRect = null, mousePosition) {
    if (!this.tooltip)
      return;
    const editorLeft = (editorContainerRect == null ? void 0 : editorContainerRect.left) || 0;
    const editorTop = (editorContainerRect == null ? void 0 : editorContainerRect.top) || 0;
    const editorWidth = (editorContainerRect == null ? void 0 : editorContainerRect.width) || viewportWidth;
    const editorHeight = (editorContainerRect == null ? void 0 : editorContainerRect.height) || viewportHeight;
    const adaptiveSize = this.calculateAdaptiveTooltipSize(
      viewportWidth,
      viewportHeight,
      0,
      false,
      editorWidth,
      editorHeight
    );
    this.tooltip.style.width = `${adaptiveSize.width}px`;
    this.tooltip.style.maxHeight = `${adaptiveSize.maxHeight}px`;
    this.tooltip.style.minWidth = `${adaptiveSize.minWidth}px`;
    this.tooltip.style.fontSize = adaptiveSize.fontSize;
    const gap = 8;
    const minSpacing = 12;
    let referenceRect;
    let referenceCenterX;
    let referenceCenterY;
    if (mousePosition) {
      referenceCenterX = mousePosition.x;
      referenceCenterY = mousePosition.y;
      referenceRect = new DOMRect(
        mousePosition.x - 8,
        mousePosition.y - 10,
        16,
        20
      );
      Logger.debug(`\u{1F3AF} \uB9C8\uC6B0\uC2A4 \uC704\uCE58 \uAE30\uBC18 \uD234\uD301 \uBC30\uCE58: (${mousePosition.x}, ${mousePosition.y})`);
    } else {
      referenceRect = targetRect;
      referenceCenterX = targetRect.left + targetRect.width / 2;
      referenceCenterY = targetRect.top + targetRect.height / 2;
      Logger.debug(`\u{1F4CD} \uD0C0\uAC9F \uC694\uC18C \uAE30\uBC18 \uD234\uD301 \uBC30\uCE58: (${referenceCenterX}, ${referenceCenterY})`);
    }
    const cornerThreshold = mousePosition ? 60 : 100;
    const isLeftEdge = referenceCenterX - editorLeft < cornerThreshold;
    const isRightEdge = editorLeft + editorWidth - referenceCenterX < cornerThreshold;
    const isTopEdge = referenceCenterY - editorTop < cornerThreshold;
    const isBottomEdge = editorTop + editorHeight - referenceCenterY < cornerThreshold;
    let finalLeft = 0;
    let finalTop = 0;
    const smallOffset = mousePosition ? 5 : gap;
    const availableSpaceBelow = Math.min(viewportHeight, editorTop + editorHeight) - referenceCenterY;
    const availableSpaceAbove = referenceCenterY - editorTop;
    if (isBottomEdge) {
      finalTop = referenceCenterY - adaptiveSize.maxHeight - smallOffset;
      Logger.debug(`\u{1F5A5}\uFE0F \uD558\uB2E8 \uAD6C\uC11D: \uC704\uCABD \uBC30\uCE58 (\uC624\uD504\uC14B: ${smallOffset}px)`);
    } else if (availableSpaceBelow >= adaptiveSize.maxHeight + smallOffset + minSpacing) {
      finalTop = referenceCenterY + smallOffset;
      Logger.debug(`\u{1F5A5}\uFE0F \uC544\uB798\uCABD \uBC30\uCE58 (\uC624\uD504\uC14B: ${smallOffset}px)`);
    } else if (availableSpaceAbove >= adaptiveSize.maxHeight + smallOffset + minSpacing) {
      finalTop = referenceCenterY - adaptiveSize.maxHeight - smallOffset;
      Logger.debug(`\u{1F5A5}\uFE0F \uC704\uCABD \uBC30\uCE58 (\uC624\uD504\uC14B: ${smallOffset}px)`);
    } else {
      if (availableSpaceBelow > availableSpaceAbove) {
        finalTop = referenceCenterY + 2;
      } else {
        finalTop = referenceCenterY - adaptiveSize.maxHeight - 2;
      }
      Logger.debug(`\u{1F5A5}\uFE0F \uACF5\uAC04 \uBD80\uC871: \uB9C8\uC6B0\uC2A4 \uC778\uC811 \uBC30\uCE58`);
    }
    if (isLeftEdge) {
      finalLeft = Math.max(referenceCenterX + 5, editorLeft);
      Logger.debug("\u{1F5A5}\uFE0F \uC67C\uCABD \uAD6C\uC11D: \uB9C8\uC6B0\uC2A4 \uC624\uB978\uCABD \uC778\uC811");
    } else if (isRightEdge) {
      finalLeft = Math.min(referenceCenterX - adaptiveSize.width - 5, editorLeft + editorWidth - adaptiveSize.width);
      Logger.debug("\u{1F5A5}\uFE0F \uC624\uB978\uCABD \uAD6C\uC11D: \uB9C8\uC6B0\uC2A4 \uC67C\uCABD \uC778\uC811");
    } else {
      finalLeft = referenceCenterX - adaptiveSize.width / 2;
    }
    finalLeft = Math.max(
      Math.max(minSpacing, editorLeft),
      Math.min(finalLeft, Math.min(viewportWidth, editorLeft + editorWidth) - adaptiveSize.width - minSpacing)
    );
    finalTop = Math.max(
      Math.max(minSpacing, editorTop),
      Math.min(finalTop, Math.min(viewportHeight, editorTop + editorHeight) - adaptiveSize.maxHeight - minSpacing)
    );
    this.tooltip.style.position = "fixed";
    this.tooltip.style.left = `${finalLeft}px`;
    this.tooltip.style.top = `${finalTop}px`;
    this.tooltip.style.zIndex = "1000";
    this.tooltip.style.visibility = "visible";
    Logger.log(`\u{1F5A5}\uFE0F \uB370\uC2A4\uD06C\uD1B1 \uD234\uD301 \uC704\uCE58: ${adaptiveSize.width}x${adaptiveSize.maxHeight} at (${finalLeft}, ${finalTop})`, {
      corners: { isLeftEdge, isRightEdge, isTopEdge, isBottomEdge },
      editor: editorContainerRect ? `${editorWidth}x${editorHeight} at (${editorLeft}, ${editorTop})` : "none",
      adaptive: `${adaptiveSize.width}px (\uB0B4\uC6A9 \uB9DE\uCDA4)`,
      mouseMode: mousePosition ? `mouse (${mousePosition.x}, ${mousePosition.y})` : "element center",
      reference: `(${referenceCenterX}, ${referenceCenterY})`
    });
  }
  /**
   * Î≥ëÌï©Îêú Ïò§Î•òÏö© Ìà¥ÌåÅ ÏÉùÏÑ±
   */
  createMergedErrorTooltip(mergedError, targetElement) {
    if (!this.tooltip || !mergedError.originalErrors)
      return;
    const isMobileDevice = import_obsidian10.Platform.isMobile;
    const isPhoneDevice = import_obsidian10.Platform.isPhone || window.innerWidth <= 480;
    const header = this.tooltip.createEl("div", { cls: "tooltip-header" });
    header.style.cssText = `
      padding: ${isMobileDevice ? isPhoneDevice ? "10px 12px" : "11px 13px" : "8px 12px"};
      border-bottom: 1px solid var(--background-modifier-border);
      background: var(--background-secondary);
      font-weight: 600;
      font-size: ${isMobileDevice ? isPhoneDevice ? "11px" : "12px" : "12px"};
      color: var(--text-muted);
      text-align: center;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    `;
    const headerText = header.createEl("span", {
      text: `${mergedError.originalErrors.length}\uAC1C \uC624\uB958 \uBCD1\uD569\uB428`,
      cls: "header-text"
    });
    headerText.style.cssText = `
      flex: 1;
      text-align: center;
    `;
    const headerCloseButton = header.createEl("button", {
      text: "\u2715",
      cls: "header-close-button"
    });
    headerCloseButton.style.cssText = `
      position: absolute;
      right: ${isMobileDevice ? isPhoneDevice ? "12px" : "10px" : "8px"};
      top: 50%;
      transform: translateY(-50%);
      background: none;
      border: none;
      outline: none;
      box-shadow: none;
      cursor: pointer;
      font-size: ${isMobileDevice ? isPhoneDevice ? "18px" : "16px" : "16px"};
      color: var(--text-muted);
      padding: 0;
      margin: 0;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: auto;
      min-height: auto;
      width: auto;
      height: auto;
      z-index: 10;
      font-weight: 500;
      line-height: 1;
      opacity: 0.7;
      font-family: inherit;
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      ${isMobileDevice ? "touch-action: manipulation;" : ""}
    `;
    headerCloseButton.addEventListener("mouseenter", () => {
      headerCloseButton.style.opacity = "1";
      headerCloseButton.style.color = "var(--text-normal)";
      headerCloseButton.style.transform = "translateY(-50%) scale(1.2)";
    });
    headerCloseButton.addEventListener("mouseleave", () => {
      headerCloseButton.style.opacity = "0.7";
      headerCloseButton.style.color = "var(--text-muted)";
      headerCloseButton.style.transform = "translateY(-50%) scale(1)";
    });
    if (isMobileDevice) {
      headerCloseButton.addEventListener("touchstart", (e) => {
        e.preventDefault();
        headerCloseButton.style.opacity = "1";
        headerCloseButton.style.color = "var(--text-normal)";
        headerCloseButton.style.transform = "translateY(-50%) scale(1.2)";
        if ("vibrate" in navigator) {
          navigator.vibrate(10);
        }
      }, { passive: false });
      headerCloseButton.addEventListener("touchend", (e) => {
        e.preventDefault();
        e.stopPropagation();
        headerCloseButton.style.opacity = "0.7";
        headerCloseButton.style.color = "var(--text-muted)";
        headerCloseButton.style.transform = "translateY(-50%) scale(1)";
        this.hide();
      }, { passive: false });
    }
    headerCloseButton.addEventListener("click", (e) => {
      e.stopPropagation();
      this.hide();
    });
    const scrollContainer = this.tooltip.createEl("div", { cls: "tooltip-scroll-container" });
    scrollContainer.style.cssText = `
      flex: 1;
      overflow-y: auto;
      max-height: ${isMobileDevice ? isPhoneDevice ? "280px" : "320px" : "250px"};
      min-height: ${isMobileDevice ? isPhoneDevice ? "120px" : "140px" : "auto"};
    `;
    mergedError.originalErrors.forEach((originalError, index) => {
      const errorSection = scrollContainer.createEl("div", { cls: "error-section" });
      errorSection.style.cssText = `
        padding: ${isMobileDevice ? isPhoneDevice ? "10px 12px" : "11px 13px" : "8px 12px"};
        ${index > 0 ? "border-top: 1px solid var(--background-modifier-border-hover);" : ""}
      `;
      const errorLine = errorSection.createEl("div", { cls: "error-line" });
      errorLine.style.cssText = `
        display: flex;
        align-items: center;
        gap: ${isMobileDevice ? isPhoneDevice ? "6px" : "7px" : "8px"};
        flex-wrap: nowrap;
        min-height: ${isMobileDevice ? isPhoneDevice ? "32px" : "34px" : "28px"};
      `;
      const errorWord = errorLine.createEl("span", {
        text: originalError.correction.original,
        cls: "error-word"
      });
      errorWord.style.cssText = `
        color: var(--text-error);
        font-weight: 600;
        background: rgba(255, 0, 0, 0.1);
        padding: ${isMobileDevice ? isPhoneDevice ? "4px 7px" : "4px 8px" : "3px 6px"};
        border-radius: 3px;
        font-size: ${isMobileDevice ? isPhoneDevice ? "11px" : "12px" : "12px"};
        white-space: nowrap;
        flex-shrink: 0;
        min-width: ${isMobileDevice ? "70px" : "60px"};
        max-width: ${isMobileDevice ? isPhoneDevice ? "100px" : "110px" : "120px"};
        overflow: hidden;
        text-overflow: ellipsis;
        line-height: ${isMobileDevice ? "1.3" : "1.2"};
      `;
      const arrow = errorLine.createEl("span", { text: "\u2192" });
      arrow.style.cssText = `
        color: var(--text-muted);
        font-weight: bold;
        flex-shrink: 0;
        font-size: ${isMobileDevice ? isPhoneDevice ? "12px" : "13px" : "14px"};
      `;
      const suggestionsList = errorLine.createEl("div", { cls: "suggestions-list" });
      suggestionsList.style.cssText = `
        display: flex;
        align-items: center;
        gap: ${isMobileDevice ? isPhoneDevice ? "3px" : "4px" : "4px"};
        flex: 1;
        flex-wrap: wrap;
        overflow: hidden;
      `;
      originalError.correction.corrected.forEach((suggestion, index2) => {
        const suggestionButton = suggestionsList.createEl("button", {
          text: suggestion,
          cls: "suggestion-button"
        });
        suggestionButton.style.cssText = `
            color: var(--text-normal);
            font-weight: 600;
            background: rgba(59, 130, 246, 0.1);
            padding: ${isMobileDevice ? isPhoneDevice ? "4px 7px" : "4px 8px" : "3px 6px"};
            border: none;
            border-radius: 3px;
            font-size: ${isMobileDevice ? isPhoneDevice ? "11px" : "12px" : "12px"};
            white-space: nowrap;
            flex-shrink: 0;
            min-width: ${isMobileDevice ? "70px" : "60px"};
            max-width: ${isMobileDevice ? isPhoneDevice ? "100px" : "110px" : "120px"};
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: ${isMobileDevice ? "1.3" : "1.2"};
            cursor: pointer;
            transition: all 0.2s;
            outline: none;
            margin: 0;
            font-family: inherit;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            ${isMobileDevice ? "touch-action: manipulation;" : ""}
          `;
        const onActivate = () => {
          suggestionButton.style.background = "rgba(59, 130, 246, 0.15)";
          suggestionButton.style.transform = "translateY(-0.5px)";
          if (isMobileDevice && "vibrate" in navigator) {
            navigator.vibrate(10);
          }
        };
        const onDeactivate = () => {
          suggestionButton.style.background = "rgba(59, 130, 246, 0.1)";
          suggestionButton.style.transform = "translateY(0)";
        };
        suggestionButton.addEventListener("mouseenter", onActivate);
        suggestionButton.addEventListener("mouseleave", onDeactivate);
        if (isMobileDevice) {
          suggestionButton.addEventListener("touchstart", (e) => {
            e.preventDefault();
            onActivate();
          }, { passive: false });
          suggestionButton.addEventListener("touchend", (e) => {
            e.preventDefault();
            onDeactivate();
            Logger.log(`\u{1F4F1} \uBAA8\uBC14\uC77C \uD130\uCE58\uB85C \uC81C\uC548 \uC801\uC6A9: "${suggestion}"`);
            this.applySuggestionKeepOpen(mergedError, suggestion, targetElement);
          }, { passive: false });
        }
        suggestionButton.addEventListener("click", (e) => {
          e.stopPropagation();
          this.applySuggestionKeepOpen(mergedError, suggestion, targetElement);
        });
      });
      if (originalError.correction.help) {
        const helpContainer = errorLine.createEl("div", { cls: "help-container" });
        helpContainer.style.cssText = `
          display: flex;
          align-items: center;
          margin-left: 4px;
          flex-shrink: 0;
        `;
        this.createInlineHelpIcon(originalError.correction.help, helpContainer, () => {
          let helpArea = this.tooltip.querySelector(".tooltip-help-area");
          if (!helpArea) {
            helpArea = this.tooltip.createEl("div", { cls: "tooltip-help-area" });
            helpArea.style.cssText = `
              padding: 8px 12px;
              border-top: 1px solid var(--background-modifier-border);
              background: var(--background-secondary);
              font-size: 11px;
              color: var(--text-muted);
              line-height: 1.4;
              white-space: pre-wrap;
              word-break: break-word;
            `;
            helpArea.textContent = originalError.correction.help;
          } else {
            const isHidden = helpArea.style.display === "none";
            helpArea.style.display = isHidden ? "block" : "none";
            if (!isHidden) {
              helpArea.textContent = originalError.correction.help;
            }
          }
        });
      }
    });
    const actionsContainer = this.tooltip.createEl("div", { cls: "tooltip-actions" });
    actionsContainer.style.cssText = `
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: ${isMobileDevice ? isPhoneDevice ? "8px 12px 10px 12px" : "7px 11px 9px 11px" : "8px 12px"};
      border-top: 1px solid var(--background-modifier-border);
      background: var(--background-secondary);
      gap: ${isMobileDevice ? isPhoneDevice ? "8px" : "7px" : "6px"};
      min-height: ${isMobileDevice ? isPhoneDevice ? "48px" : "44px" : "auto"};
      border-bottom-left-radius: 12px;
      border-bottom-right-radius: 12px;
    `;
    const infoText = actionsContainer.createEl("span", {
      text: isMobileDevice ? isPhoneDevice ? "\uAC1C\uBCC4 \uC218\uC815" : "\uAC1C\uBCC4 \uD074\uB9AD \uC218\uC815" : "\uAC1C\uBCC4 \uD074\uB9AD\uC73C\uB85C \uD558\uB098\uC529 \uC218\uC815",
      cls: "info-text"
    });
    infoText.style.cssText = `
      font-size: ${isMobileDevice ? isPhoneDevice ? "11px" : "12px" : "11px"};
      color: var(--text-muted);
      flex: 1;
      line-height: 1.3;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      padding-right: ${isMobileDevice ? "4px" : "0"};
    `;
    const actionButtons = actionsContainer.createEl("div", { cls: "action-buttons" });
    actionButtons.style.cssText = `
      display: flex;
      align-items: center;
      gap: ${isMobileDevice ? isPhoneDevice ? "6px" : "5px" : "6px"};
      flex-shrink: 0;
      min-height: ${isMobileDevice ? isPhoneDevice ? "32px" : "30px" : "auto"};
    `;
    const ignoreAllButton = actionButtons.createEl("button", { cls: "ignore-all-button" });
    ignoreAllButton.innerHTML = "\u2715";
    ignoreAllButton.title = "\uC774 \uC624\uB958\uB4E4 \uBAA8\uB450 \uBB34\uC2DC";
    ignoreAllButton.style.cssText = `
      background: #ef4444;
      color: white;
      border: 1px solid #ef4444;
      border-radius: ${isMobileDevice ? "6px" : "4px"};
      padding: ${isMobileDevice ? isPhoneDevice ? "8px" : "7px" : "6px"};
      cursor: pointer;
      font-size: ${isMobileDevice ? isPhoneDevice ? "16px" : "15px" : "16px"};
      font-weight: 700;
      transition: all 0.2s;
      min-height: ${isMobileDevice ? isPhoneDevice ? "32px" : "30px" : "auto"};
      min-width: ${isMobileDevice ? isPhoneDevice ? "32px" : "30px" : "auto"};
      max-height: ${isMobileDevice ? isPhoneDevice ? "32px" : "30px" : "none"};
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      white-space: nowrap;
      box-shadow: 0 2px 4px rgba(239, 68, 68, 0.2);
      ${isMobileDevice ? "touch-action: manipulation;" : ""}
    `;
    ignoreAllButton.addEventListener("mouseenter", () => {
      ignoreAllButton.style.background = "#dc2626";
      ignoreAllButton.style.borderColor = "#dc2626";
      ignoreAllButton.style.transform = "translateY(-1px)";
      ignoreAllButton.style.boxShadow = "0 4px 8px rgba(239, 68, 68, 0.3)";
    });
    ignoreAllButton.addEventListener("mouseleave", () => {
      ignoreAllButton.style.background = "#ef4444";
      ignoreAllButton.style.borderColor = "#ef4444";
      ignoreAllButton.style.transform = "translateY(0)";
      ignoreAllButton.style.boxShadow = "0 2px 4px rgba(239, 68, 68, 0.2)";
    });
    if (import_obsidian10.Platform.isMobile) {
      ignoreAllButton.addEventListener("touchstart", (e) => {
        e.preventDefault();
        ignoreAllButton.style.background = "#dc2626";
        ignoreAllButton.style.borderColor = "#dc2626";
        ignoreAllButton.style.transform = "translateY(-1px)";
        ignoreAllButton.style.boxShadow = "0 4px 8px rgba(239, 68, 68, 0.3)";
        if ("vibrate" in navigator) {
          navigator.vibrate(15);
        }
      }, { passive: false });
      ignoreAllButton.addEventListener("touchend", (e) => {
        e.preventDefault();
        e.stopPropagation();
        ignoreAllButton.style.background = "#ef4444";
        ignoreAllButton.style.borderColor = "#ef4444";
        ignoreAllButton.style.transform = "translateY(0)";
        ignoreAllButton.style.boxShadow = "0 2px 4px rgba(239, 68, 68, 0.2)";
        this.ignoreError(mergedError);
      }, { passive: false });
    }
    ignoreAllButton.addEventListener("click", (e) => {
      e.stopPropagation();
      this.ignoreError(mergedError);
    });
    const applyAllButton = actionButtons.createEl("button", {
      text: "\u2713",
      cls: "apply-all-button"
    });
    applyAllButton.title = "\uBAA8\uB4E0 \uC218\uC815 \uC0AC\uD56D \uC801\uC6A9";
    applyAllButton.style.cssText = `
      background: #10b981;
      color: white;
      border: 1px solid #10b981;
      border-radius: ${isMobileDevice ? "6px" : "4px"};
      padding: ${isMobileDevice ? isPhoneDevice ? "8px" : "7px" : "6px"};
      cursor: pointer;
      font-size: ${isMobileDevice ? isPhoneDevice ? "16px" : "15px" : "16px"};
      font-weight: 700;
      transition: all 0.2s;
      min-height: ${isMobileDevice ? isPhoneDevice ? "32px" : "30px" : "auto"};
      min-width: ${isMobileDevice ? isPhoneDevice ? "32px" : "30px" : "auto"};
      max-height: ${isMobileDevice ? isPhoneDevice ? "32px" : "30px" : "none"};
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      white-space: nowrap;
      box-shadow: 0 2px 4px rgba(16, 185, 129, 0.2);
      ${isMobileDevice ? "touch-action: manipulation;" : ""}
    `;
    applyAllButton.addEventListener("mouseenter", () => {
      applyAllButton.style.background = "#059669";
      applyAllButton.style.borderColor = "#059669";
      applyAllButton.style.transform = "translateY(-1px)";
      applyAllButton.style.boxShadow = "0 4px 8px rgba(16, 185, 129, 0.3)";
    });
    applyAllButton.addEventListener("mouseleave", () => {
      applyAllButton.style.background = "#10b981";
      applyAllButton.style.borderColor = "#10b981";
      applyAllButton.style.transform = "translateY(0)";
      applyAllButton.style.boxShadow = "0 2px 4px rgba(16, 185, 129, 0.2)";
    });
    if (isMobileDevice) {
      applyAllButton.addEventListener("touchstart", (e) => {
        e.preventDefault();
        applyAllButton.style.background = "#059669";
        applyAllButton.style.borderColor = "#059669";
        applyAllButton.style.transform = "translateY(-1px)";
        applyAllButton.style.boxShadow = "0 4px 8px rgba(16, 185, 129, 0.3)";
        if ("vibrate" in navigator) {
          navigator.vibrate(15);
        }
      }, { passive: false });
      applyAllButton.addEventListener("touchend", (e) => {
        e.preventDefault();
        e.stopPropagation();
        applyAllButton.style.background = "#10b981";
        applyAllButton.style.borderColor = "#10b981";
        applyAllButton.style.transform = "translateY(0)";
        applyAllButton.style.boxShadow = "0 2px 4px rgba(16, 185, 129, 0.2)";
        if (mergedError.originalErrors) {
          mergedError.originalErrors.forEach((originalError) => {
            if (originalError.correction.corrected.length > 0) {
              InlineModeService.applySuggestion(originalError, originalError.correction.corrected[0]);
            }
          });
        }
        this.hide();
      }, { passive: false });
    }
    applyAllButton.addEventListener("click", (e) => {
      e.stopPropagation();
      if (mergedError.originalErrors) {
        mergedError.originalErrors.forEach((originalError) => {
          if (originalError.correction.corrected.length > 0) {
            InlineModeService.applySuggestion(originalError, originalError.correction.corrected[0]);
          }
        });
      }
      this.hide();
    });
    this.setupHoverEvents(targetElement);
  }
  /**
   * Ìò∏Î≤Ñ Ïù¥Î≤§Ìä∏ ÏÑ§Ï†ï (Í∞úÏÑ†Îêú ÏïàÏ†ïÏÑ±)
   */
  setupHoverEvents(targetElement) {
    let hideTimeout;
    let isHoveringTarget = false;
    let isHoveringTooltip = false;
    const startHideTimer = () => {
      if (hideTimeout) {
        clearTimeout(hideTimeout);
      }
      hideTimeout = setTimeout(() => {
        if (!isHoveringTarget && !isHoveringTooltip) {
          Logger.debug("\u{1F50D} \uD234\uD301 \uC790\uB3D9 \uC228\uAE40 \uD0C0\uC774\uBA38 \uC2E4\uD589");
          this.hide();
        }
      }, 800);
    };
    const cancelHideTimer = () => {
      if (hideTimeout) {
        clearTimeout(hideTimeout);
        hideTimeout = void 0;
      }
    };
    const onTargetMouseEnter = () => {
      Logger.debug("\u{1F50D} \uD0C0\uAC9F \uC694\uC18C \uB9C8\uC6B0\uC2A4 \uC9C4\uC785");
      isHoveringTarget = true;
      cancelHideTimer();
    };
    const onTargetMouseLeave = () => {
      Logger.debug("\u{1F50D} \uD0C0\uAC9F \uC694\uC18C \uB9C8\uC6B0\uC2A4 \uC774\uD0C8");
      isHoveringTarget = false;
      setTimeout(() => {
        if (!isHoveringTarget && !isHoveringTooltip) {
          startHideTimer();
        }
      }, 200);
    };
    const onTooltipMouseEnter = () => {
      Logger.debug("\u{1F50D} \uD234\uD301 \uB9C8\uC6B0\uC2A4 \uC9C4\uC785");
      isHoveringTooltip = true;
      cancelHideTimer();
    };
    const onTooltipMouseLeave = () => {
      Logger.debug("\u{1F50D} \uD234\uD301 \uB9C8\uC6B0\uC2A4 \uC774\uD0C8");
      isHoveringTooltip = false;
      setTimeout(() => {
        if (!isHoveringTarget && !isHoveringTooltip) {
          startHideTimer();
        }
      }, 200);
    };
    const onDocumentMouseMove = (e) => {
      if (!this.tooltip || !targetElement)
        return;
      const tooltipRect = this.tooltip.getBoundingClientRect();
      const targetRect = targetElement.getBoundingClientRect();
      const bridgeMargin = 20;
      const combinedRect = {
        left: Math.min(tooltipRect.left, targetRect.left) - bridgeMargin,
        right: Math.max(tooltipRect.right, targetRect.right) + bridgeMargin,
        top: Math.min(tooltipRect.top, targetRect.top) - bridgeMargin,
        bottom: Math.max(tooltipRect.bottom, targetRect.bottom) + bridgeMargin
      };
      const isInCombinedArea = e.clientX >= combinedRect.left && e.clientX <= combinedRect.right && e.clientY >= combinedRect.top && e.clientY <= combinedRect.bottom;
      if (!isInCombinedArea && (isHoveringTarget || isHoveringTooltip)) {
        Logger.debug("\u{1F50D} \uB9C8\uC6B0\uC2A4\uAC00 \uBE0C\uB9BF\uC9C0 \uC601\uC5ED\uC744 \uC644\uC804\uD788 \uBC97\uC5B4\uB0A8 - \uC0C1\uD0DC \uCD08\uAE30\uD654");
        isHoveringTarget = false;
        isHoveringTooltip = false;
        startHideTimer();
      }
    };
    targetElement.addEventListener("mouseenter", onTargetMouseEnter);
    targetElement.addEventListener("mouseleave", onTargetMouseLeave);
    setTimeout(() => {
      if (this.tooltip) {
        this.tooltip.addEventListener("mouseenter", onTooltipMouseEnter);
        this.tooltip.addEventListener("mouseleave", onTooltipMouseLeave);
      }
    }, 50);
    document.addEventListener("mousemove", onDocumentMouseMove);
    this.tooltip._cleanup = () => {
      var _a, _b;
      targetElement.removeEventListener("mouseenter", onTargetMouseEnter);
      targetElement.removeEventListener("mouseleave", onTargetMouseLeave);
      (_a = this.tooltip) == null ? void 0 : _a.removeEventListener("mouseenter", onTooltipMouseEnter);
      (_b = this.tooltip) == null ? void 0 : _b.removeEventListener("mouseleave", onTooltipMouseLeave);
      document.removeEventListener("mousemove", onDocumentMouseMove);
      if (hideTimeout)
        clearTimeout(hideTimeout);
    };
  }
  /**
   * Îã®Ïùº Ïò§Î•òÏö© Ìà¥ÌåÅ ÏÉùÏÑ± (Í∏∞Ï°¥ Î°úÏßÅ Ïú†ÏßÄ)
   */
  createSingleErrorTooltip(error, targetElement, triggerType) {
    if (!this.tooltip)
      return;
    const isMobile = import_obsidian10.Platform.isMobile;
    const isPhone = import_obsidian10.Platform.isPhone || window.innerWidth <= 480;
    const mainContent = this.tooltip.createEl("div", { cls: "tooltip-main-content" });
    mainContent.style.cssText = `
      display: flex;
      align-items: center;
      gap: ${isMobile ? isPhone ? "6px" : "7px" : "8px"};
      padding: ${isMobile ? isPhone ? "6px 10px" : "7px 11px" : "8px 12px"};
      white-space: nowrap;
    `;
    const errorWord = mainContent.createEl("span", {
      text: error.correction.original,
      cls: "error-word"
    });
    errorWord.style.cssText = `
      color: var(--text-error);
      font-weight: 600;
      background: rgba(255, 0, 0, 0.1);
      padding: ${isMobile ? isPhone ? "1px 4px" : "2px 5px" : "2px 6px"};
      border-radius: 3px;
      font-size: ${isMobile ? isPhone ? "11px" : "12px" : "12px"};
    `;
    const arrow = mainContent.createEl("span", { text: "\u2192" });
    arrow.style.cssText = `
      color: var(--text-muted);
      font-weight: bold;
      font-size: ${isMobile ? isPhone ? "11px" : "12px" : "12px"};
    `;
    const suggestionsList = mainContent.createEl("div", { cls: "suggestions-list" });
    suggestionsList.style.cssText = `
      display: flex;
      align-items: center;
      gap: ${isMobile ? isPhone ? "4px" : "5px" : "6px"};
      flex-wrap: wrap;
    `;
    error.correction.corrected.forEach((suggestion, index) => {
      const suggestionButton = suggestionsList.createEl("span", {
        text: suggestion,
        cls: "suggestion-button"
      });
      const isMobile2 = import_obsidian10.Platform.isMobile;
      const isPhone2 = import_obsidian10.Platform.isPhone;
      suggestionButton.style.cssText = `
        color: var(--text-normal);
        font-weight: 600;
        background: rgba(59, 130, 246, 0.1);
        padding: ${isMobile2 ? isPhone2 ? "1px 4px" : "2px 5px" : "2px 6px"};
        border-radius: 3px;
        font-size: ${isMobile2 ? isPhone2 ? "11px" : "12px" : "12px"};
        cursor: pointer;
        ${isMobile2 ? "touch-action: manipulation;" : ""}
      `;
      const onActivate = () => {
        suggestionButton.style.background = "rgba(59, 130, 246, 0.15)";
        if (isMobile2 && "vibrate" in navigator) {
          navigator.vibrate(10);
        }
      };
      const onDeactivate = () => {
        suggestionButton.style.background = "rgba(59, 130, 246, 0.1)";
      };
      suggestionButton.addEventListener("mouseenter", onActivate);
      suggestionButton.addEventListener("mouseleave", onDeactivate);
      if (isMobile2) {
        suggestionButton.addEventListener("touchstart", (e) => {
          e.preventDefault();
          onActivate();
        }, { passive: false });
        suggestionButton.addEventListener("touchend", (e) => {
          e.preventDefault();
          onDeactivate();
          Logger.log(`\u{1F4F1} \uBAA8\uBC14\uC77C \uD130\uCE58\uB85C \uC81C\uC548 \uC801\uC6A9: "${suggestion}"`);
          this.applySuggestion(error, suggestion, targetElement);
        }, { passive: false });
      }
      suggestionButton.addEventListener("click", (e) => {
        e.stopPropagation();
        this.applySuggestion(error, suggestion, targetElement);
      });
    });
    const actionsContainer = mainContent.createEl("div", { cls: "actions-container" });
    actionsContainer.style.cssText = `
      display: flex;
      align-items: center;
      gap: ${isMobile ? isPhone ? "8px" : "7px" : "6px"};
      margin-left: auto;
      flex-shrink: 0;
      min-height: ${isMobile ? isPhone ? "28px" : "26px" : "auto"};
    `;
    const exceptionButton = actionsContainer.createEl("button", { cls: "exception-button" });
    exceptionButton.innerHTML = "\u{1F4DA}";
    exceptionButton.title = "\uC608\uC678 \uB2E8\uC5B4\uB85C \uCD94\uAC00";
    exceptionButton.style.cssText = `
      background: var(--interactive-normal);
      border: 1px solid var(--background-modifier-border);
      border-radius: ${isMobile ? "5px" : "4px"};
      padding: ${isMobile ? isPhone ? "5px" : "6px" : "6px"};
      cursor: pointer;
      transition: all 0.2s;
      font-size: ${isMobile ? isPhone ? "13px" : "14px" : "14px"};
      min-height: ${isMobile ? isPhone ? "26px" : "28px" : "auto"};
      min-width: ${isMobile ? isPhone ? "26px" : "28px" : "auto"};
      max-height: ${isMobile ? isPhone ? "26px" : "28px" : "none"};
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      ${isMobile ? "touch-action: manipulation;" : ""}
    `;
    exceptionButton.addEventListener("mouseenter", () => {
      exceptionButton.style.background = "var(--interactive-hover)";
      exceptionButton.style.transform = "translateY(-1px)";
    });
    exceptionButton.addEventListener("mouseleave", () => {
      exceptionButton.style.background = "var(--interactive-normal)";
      exceptionButton.style.transform = "translateY(0)";
    });
    if (isMobile) {
      exceptionButton.addEventListener("touchstart", (e) => {
        e.preventDefault();
        exceptionButton.style.background = "var(--interactive-hover)";
        if ("vibrate" in navigator) {
          navigator.vibrate(10);
        }
      }, { passive: false });
      exceptionButton.addEventListener("touchend", (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.addToExceptionWords(error);
      }, { passive: false });
    }
    exceptionButton.addEventListener("click", (e) => {
      e.stopPropagation();
      this.addToExceptionWords(error);
    });
    const ignoreButton = actionsContainer.createEl("button", { cls: "ignore-button" });
    ignoreButton.innerHTML = "\u274C";
    ignoreButton.title = "\uC774 \uC624\uB958 \uBB34\uC2DC (\uC77C\uC2DC\uC801)";
    ignoreButton.style.cssText = `
      background: var(--interactive-normal);
      border: 1px solid var(--background-modifier-border);
      border-radius: ${isMobile ? "5px" : "4px"};
      padding: ${isMobile ? isPhone ? "5px" : "6px" : "6px"};
      cursor: pointer;
      transition: all 0.2s;
      font-size: ${isMobile ? isPhone ? "11px" : "12px" : "12px"};
      min-height: ${isMobile ? isPhone ? "26px" : "28px" : "auto"};
      min-width: ${isMobile ? isPhone ? "26px" : "28px" : "auto"};
      max-height: ${isMobile ? isPhone ? "26px" : "28px" : "none"};
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      ${isMobile ? "touch-action: manipulation;" : ""}
    `;
    ignoreButton.addEventListener("mouseenter", () => {
      ignoreButton.style.background = "var(--interactive-hover)";
      ignoreButton.style.transform = "translateY(-1px)";
    });
    ignoreButton.addEventListener("mouseleave", () => {
      ignoreButton.style.background = "var(--interactive-normal)";
      ignoreButton.style.transform = "translateY(0)";
    });
    if (isMobile) {
      ignoreButton.addEventListener("touchstart", (e) => {
        e.preventDefault();
        ignoreButton.style.background = "var(--interactive-hover)";
        if ("vibrate" in navigator) {
          navigator.vibrate(10);
        }
      }, { passive: false });
      ignoreButton.addEventListener("touchend", (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.ignoreError(error);
      }, { passive: false });
    }
    ignoreButton.addEventListener("click", (e) => {
      e.stopPropagation();
      this.ignoreError(error);
    });
    let helpArea = null;
    if (error.correction.help) {
      this.createInlineHelpIcon(error.correction.help, actionsContainer, () => {
        if (!helpArea) {
          helpArea = this.tooltip.createEl("div", { cls: "tooltip-help-area" });
          helpArea.style.cssText = `
            padding: 8px 12px;
            border-top: 1px solid var(--background-modifier-border);
            background: var(--background-secondary);
            font-size: 11px;
            color: var(--text-muted);
            line-height: 1.4;
            white-space: pre-wrap;
            word-break: break-word;
          `;
          helpArea.textContent = error.correction.help;
        } else {
          const isHidden = helpArea.style.display === "none";
          helpArea.style.display = isHidden ? "block" : "none";
        }
      });
    }
    if (triggerType === "hover") {
      this.setupHoverEvents(targetElement);
    } else {
      setTimeout(() => {
        document.addEventListener("click", this.handleOutsideClick.bind(this), { once: true });
      }, 0);
    }
  }
  /**
   * ÏàòÏ†ï Ï†úÏïà Ï†ÅÏö© (ÌÅ¥Î¶≠ ÌõÑ Ìà¥ÌåÅ Ïú†ÏßÄ)
   */
  applySuggestionKeepOpen(mergedError, suggestion, targetElement) {
    Logger.log(`\uC778\uB77C\uC778 \uBAA8\uB4DC: \uC218\uC815 \uC81C\uC548 \uC801\uC6A9 (\uD074\uB9AD \uD6C4 \uD234\uD301 \uC720\uC9C0) - "${mergedError.correction.original}" \u2192 "${suggestion}"`);
    window.tooltipKeepOpenMode = true;
    try {
      InlineModeService.applySuggestion(mergedError, suggestion);
      Logger.log(`\u2705 \uBCD1\uD569\uB41C \uC624\uB958 \uC218\uC815 \uC801\uC6A9 \uC131\uACF5: "${mergedError.correction.original}" \u2192 "${suggestion}"`);
    } catch (error) {
      Logger.error("\u274C \uC218\uC815 \uC81C\uC548 \uC801\uC6A9 \uC911 \uC624\uB958:", error);
    }
    setTimeout(() => {
      window.tooltipKeepOpenMode = false;
    }, 200);
    Logger.debug("\uD234\uD301 \uC720\uC9C0 \uBAA8\uB4DC\uB85C \uAD50\uC815 \uC801\uC6A9 \uC644\uB8CC");
  }
  /**
   * ÏàòÏ†ï Ï†úÏïà Ï†ÅÏö© (ÏùºÎ∞ò Î™®Îìú)
   */
  applySuggestion(error, suggestion, targetElement) {
    Logger.log(`\uC778\uB77C\uC778 \uBAA8\uB4DC: \uC218\uC815 \uC81C\uC548 \uC801\uC6A9 - "${error.correction.original}" \u2192 "${suggestion}"`);
    try {
      InlineModeService.applySuggestion(error, suggestion);
      Logger.log(`\u2705 \uC77C\uBC18 \uC624\uB958 \uC218\uC815 \uC801\uC6A9 \uC131\uACF5: "${error.correction.original}" \u2192 "${suggestion}"`);
      this.hide();
    } catch (error2) {
      Logger.error("\u274C \uC218\uC815 \uC81C\uC548 \uC801\uC6A9 \uC911 \uC624\uB958:", error2);
    }
  }
  /**
   * üìö ÏòàÏô∏ Îã®Ïñ¥Î°ú Ï∂îÍ∞Ä (IgnoredWordsServiceÏôÄ Ïó∞Îèô)
   */
  addToExceptionWords(error) {
    const word = error.correction.original;
    try {
      const app = window.app;
      if (app && app.plugins && app.plugins.plugins["korean-grammar-assistant"]) {
        const plugin = app.plugins.plugins["korean-grammar-assistant"];
        const settings = plugin.settings;
        if (!settings.ignoredWords) {
          settings.ignoredWords = [];
        }
        if (settings.ignoredWords.includes(word)) {
          Logger.warn(`"${word}"\uB294 \uC774\uBBF8 \uC608\uC678 \uB2E8\uC5B4 \uBAA9\uB85D\uC5D0 \uC788\uC2B5\uB2C8\uB2E4.`);
          new import_obsidian10.Notice(`"${word}"\uB294 \uC774\uBBF8 \uC608\uC678 \uB2E8\uC5B4\uB85C \uB4F1\uB85D\uB418\uC5B4 \uC788\uC2B5\uB2C8\uB2E4.`);
          return;
        }
        settings.ignoredWords.push(word);
        plugin.saveSettings();
        Logger.log(`\u{1F4DA} \uC608\uC678 \uB2E8\uC5B4 \uCD94\uAC00: "${word}"`);
        new import_obsidian10.Notice(`"${word}"\uB97C \uC608\uC678 \uB2E8\uC5B4\uB85C \uCD94\uAC00\uD588\uC2B5\uB2C8\uB2E4.`);
        if (window.InlineModeService) {
          window.InlineModeService.removeError(null, error.uniqueId);
          Logger.debug(`\u2705 \uC608\uC678 \uB2E8\uC5B4 \uB4F1\uB85D\uC73C\uB85C \uC778\uD55C \uC624\uB958 \uC81C\uAC70: ${error.uniqueId}`);
        }
        this.hide();
      } else {
        Logger.error("Korean Grammar Assistant \uD50C\uB7EC\uADF8\uC778\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
        new import_obsidian10.Notice("\uC608\uC678 \uB2E8\uC5B4 \uCD94\uAC00\uC5D0 \uC2E4\uD328\uD588\uC2B5\uB2C8\uB2E4.");
      }
    } catch (error2) {
      Logger.error("\uC608\uC678 \uB2E8\uC5B4 \uCD94\uAC00 \uC911 \uC624\uB958:", error2);
      new import_obsidian10.Notice("\uC608\uC678 \uB2E8\uC5B4 \uCD94\uAC00\uC5D0 \uC2E4\uD328\uD588\uC2B5\uB2C8\uB2E4.");
    }
  }
  /**
   * ‚ùå Ïò§Î•ò ÏùºÏãúÏ†Å Î¨¥Ïãú (Ìï¥Îãπ Ïò§Î•òÎßå Ïà®ÍπÄ, ÏòàÏô∏ Îã®Ïñ¥ÏóêÎäî Ï∂îÍ∞ÄÎêòÏßÄ ÏïäÏùå)
   */
  ignoreError(error) {
    try {
      Logger.log(`\u274C \uC624\uB958 \uBB34\uC2DC: "${error.correction.original}"`);
      if (window.InlineModeService) {
        window.InlineModeService.removeError(null, error.uniqueId);
        Logger.debug(`\u2705 \uC77C\uC2DC\uC801 \uBB34\uC2DC\uB85C \uC778\uD55C \uC624\uB958 \uC81C\uAC70: ${error.uniqueId}`);
      }
      this.hide();
      new import_obsidian10.Notice(`"${error.correction.original}" \uC624\uB958\uB97C \uBB34\uC2DC\uD588\uC2B5\uB2C8\uB2E4.`);
    } catch (err) {
      Logger.error("\uC624\uB958 \uBB34\uC2DC \uC911 \uBB38\uC81C \uBC1C\uC0DD:", err);
      new import_obsidian10.Notice("\uC624\uB958 \uBB34\uC2DC\uC5D0 \uC2E4\uD328\uD588\uC2B5\uB2C8\uB2E4.");
    }
  }
  /**
   * Î∞îÍπ• ÌÅ¥Î¶≠ Ï≤òÎ¶¨
   */
  handleOutsideClick(event) {
    if (this.tooltip && !this.tooltip.contains(event.target)) {
      this.hide();
    }
  }
  /**
   * Ïò§Î•ò Ïù¥Ïú† ÏÉùÏÑ±
   */
  generateErrorReason(error) {
    const original = error.correction.original;
    const corrected = error.correction.corrected;
    if (corrected.length === 0) {
      return "\uC218\uC815 \uC81C\uC548\uC774 \uC5C6\uB294 \uC624\uB958\uC785\uB2C8\uB2E4";
    }
    if (original.includes(" ") !== corrected[0].includes(" ")) {
      return "\uB744\uC5B4\uC4F0\uAE30 \uC624\uB958";
    }
    if (Math.abs(original.length - corrected[0].length) <= 2) {
      return "\uB9DE\uCDA4\uBC95 \uC624\uB958";
    }
    if (original.length !== corrected[0].length) {
      return "\uBB38\uBC95 \uC624\uB958";
    }
    return "\uC5B8\uC5B4 \uD45C\uD604 \uAC1C\uC120";
  }
  /**
   * ÎèÑÏõÄÎßê ÏïÑÏù¥ÏΩò ÏÉùÏÑ± (Inline Î™®ÎìúÏö©) - Î™®Î∞îÏùº ÏµúÏ†ÅÌôî
   */
  createInlineHelpIcon(helpText, container, onIconClick) {
    const helpIcon = container.createEl("span", { text: "?" });
    const isMobile = import_obsidian10.Platform.isMobile;
    const isPhone = import_obsidian10.Platform.isPhone || window.innerWidth <= 480;
    helpIcon.style.cssText = `
      color: var(--text-muted);
      cursor: pointer;
      width: ${isMobile ? isPhone ? "16px" : "18px" : "18px"};
      height: ${isMobile ? isPhone ? "16px" : "18px" : "18px"};
      display: flex;
      align-items: center;
      justify-content: center;
      border: 1px solid var(--text-muted);
      border-radius: 50%;
      font-size: ${isMobile ? isPhone ? "8px" : "9px" : "10px"};
      font-weight: bold;
      transition: all 0.2s;
      background: var(--background-primary);
      flex-shrink: 0;
      line-height: 1;
    `;
    helpIcon.title = helpText;
    helpIcon.addEventListener("mouseenter", () => {
      helpIcon.style.background = "var(--interactive-hover)";
      helpIcon.style.borderColor = "var(--text-normal)";
      helpIcon.style.color = "var(--text-normal)";
      helpIcon.style.transform = "scale(1.1)";
    });
    helpIcon.addEventListener("mouseleave", () => {
      helpIcon.style.background = "var(--background-primary)";
      helpIcon.style.borderColor = "var(--text-muted)";
      helpIcon.style.color = "var(--text-muted)";
      helpIcon.style.transform = "scale(1)";
    });
    if (isMobile) {
      helpIcon.addEventListener("touchstart", (e) => {
        e.preventDefault();
        helpIcon.style.background = "var(--interactive-hover)";
        helpIcon.style.borderColor = "var(--text-normal)";
        helpIcon.style.color = "var(--text-normal)";
        if ("vibrate" in navigator) {
          navigator.vibrate(10);
        }
      }, { passive: false });
      helpIcon.addEventListener("touchend", (e) => {
        e.preventDefault();
        e.stopPropagation();
        onIconClick();
      }, { passive: false });
    }
    helpIcon.addEventListener("click", (e) => {
      e.stopPropagation();
      onIconClick();
    });
  }
  /**
   * Ìà¥ÌåÅ ÎÇ¥Ïö©Ïóê Îî∞Î•∏ Ï†ÅÏùëÌòï ÌÅ¨Í∏∞ Í≥ÑÏÇ∞
   */
  calculateAdaptiveTooltipSize(viewportWidth, viewportHeight, keyboardHeight, isPhone, editorWidth, editorHeight) {
    if (!this.tooltip) {
      return { width: 250, maxHeight: 200, minWidth: 200, fontSize: "14px" };
    }
    const originalDisplay = this.tooltip.style.display;
    const originalVisibility = this.tooltip.style.visibility;
    const originalPosition = this.tooltip.style.position;
    const originalWidth = this.tooltip.style.width;
    this.tooltip.style.position = "absolute";
    this.tooltip.style.visibility = "hidden";
    this.tooltip.style.display = "block";
    this.tooltip.style.width = "auto";
    this.tooltip.style.maxWidth = "none";
    this.tooltip.style.minWidth = "none";
    const naturalWidth = this.tooltip.scrollWidth;
    const naturalHeight = this.tooltip.scrollHeight;
    Logger.debug(`\u{1F4CF} \uD234\uD301 \uC790\uC5F0 \uD06C\uAE30: ${naturalWidth}x${naturalHeight}`);
    let minWidth, maxWidth, maxHeight, fontSize;
    if (import_obsidian10.Platform.isMobile) {
      fontSize = isPhone ? "13px" : "14px";
      minWidth = isPhone ? 240 : 280;
      maxWidth = Math.min(
        isPhone ? 340 : 400,
        // ÏµúÎåÄ ÎÑàÎπÑ Ï¶ùÍ∞Ä
        Math.min(viewportWidth, editorWidth) - 24
        // Îçî ÏïàÏ†ÑÌïú Ïó¨Î∞±
      );
      const availableHeight = Math.min(viewportHeight, editorHeight) - keyboardHeight - 80;
      maxHeight = Math.min(
        isPhone ? 240 : 280,
        // ÏµúÎåÄ ÎÜíÏù¥ Ï¶ùÍ∞Ä 
        Math.max(160, availableHeight * 0.65)
        // ÏµúÏÜå 160px Î≥¥Ïû•
      );
    } else {
      fontSize = "14px";
      minWidth = 180;
      maxWidth = Math.min(500, Math.min(viewportWidth, editorWidth) - 40);
      maxHeight = Math.min(300, Math.min(viewportHeight, editorHeight) - 40);
    }
    let optimalWidth = naturalWidth + (import_obsidian10.Platform.isMobile ? isPhone ? 32 : 28 : 24);
    optimalWidth = Math.max(minWidth, optimalWidth);
    optimalWidth = Math.min(maxWidth, optimalWidth);
    this.tooltip.style.display = originalDisplay;
    this.tooltip.style.visibility = originalVisibility;
    this.tooltip.style.position = originalPosition;
    this.tooltip.style.width = originalWidth;
    const result = {
      width: optimalWidth,
      maxHeight,
      minWidth: optimalWidth,
      // Í≥ÑÏÇ∞Îêú ÎÑàÎπÑÎ°ú Í≥†Ï†ï
      fontSize
    };
    Logger.log(`\u{1F3AF} \uC801\uC751\uD615 \uD234\uD301 \uD06C\uAE30:`, {
      natural: `${naturalWidth}x${naturalHeight}`,
      calculated: `${optimalWidth}x${maxHeight}`,
      range: `${minWidth}-${maxWidth}`,
      platform: import_obsidian10.Platform.isMobile ? isPhone ? "phone" : "tablet" : "desktop"
    });
    return result;
  }
  /**
   * Î∞∞Í≤Ω Ïª§ÏÑú Ïà®Í∏∞Í∏∞
   */
  hideCursorInBackground() {
    const editorElements = document.querySelectorAll(".cm-editor");
    editorElements.forEach((editor) => {
      editor.classList.add("korean-tooltip-cursor-hidden");
    });
    if (!document.getElementById("korean-tooltip-cursor-style")) {
      const style = document.createElement("style");
      style.id = "korean-tooltip-cursor-style";
      style.textContent = `
        .korean-tooltip-cursor-hidden .cm-cursor {
          display: none !important;
        }
        .korean-tooltip-cursor-hidden .cm-focused {
          caret-color: transparent !important;
        }
      `;
      document.head.appendChild(style);
    }
  }
  /**
   * Î∞∞Í≤Ω Ïª§ÏÑú Îã§Ïãú Î≥¥Ïù¥Í∏∞
   */
  showCursorInBackground() {
    const editorElements = document.querySelectorAll(".cm-editor");
    editorElements.forEach((editor) => {
      editor.classList.remove("korean-tooltip-cursor-hidden");
    });
  }
  /**
   * Î™®Î∞îÏùºÏóêÏÑú ÌÇ§Î≥¥Îìú Ïà®Í∏∞Í∏∞ Î∞è ÏóêÎîîÌÑ∞ Ìè¨Ïª§Ïä§ Ìï¥Ï†ú
   */
  hideKeyboardAndBlurEditor() {
    var _a, _b, _c, _d;
    try {
      const obsidianApp = window.app;
      if (obsidianApp) {
        const activeView = obsidianApp.workspace.getActiveViewOfType(import_obsidian10.MarkdownView);
        if (activeView == null ? void 0 : activeView.editor) {
          if ((_b = (_a = activeView.editor).hasFocus) == null ? void 0 : _b.call(_a)) {
            Logger.log("\u{1F4F1} \uBAA8\uBC14\uC77C: \uC5D0\uB514\uD130 \uD3EC\uCEE4\uC2A4 \uD574\uC81C \uC2DC\uC791");
            (_d = (_c = activeView.editor).blur) == null ? void 0 : _d.call(_c);
            const cmEditor = activeView.editor.cm;
            if (cmEditor && cmEditor.dom) {
              cmEditor.dom.blur();
            }
          }
        }
      }
      const focusedElement = document.activeElement;
      if (focusedElement && focusedElement.blur) {
        focusedElement.blur();
        Logger.log("\u{1F4F1} \uBAA8\uBC14\uC77C: DOM \uD3EC\uCEE4\uC2A4 \uD574\uC81C \uC644\uB8CC");
      }
      const cmEditors = document.querySelectorAll(".cm-editor .cm-content");
      cmEditors.forEach((editor) => {
        if (editor instanceof HTMLElement) {
          editor.blur();
        }
      });
      const hiddenInput = document.createElement("input");
      hiddenInput.style.cssText = `
        position: absolute;
        left: -9999px;
        top: -9999px;
        opacity: 0;
        pointer-events: none;
      `;
      document.body.appendChild(hiddenInput);
      setTimeout(() => {
        hiddenInput.focus();
        setTimeout(() => {
          hiddenInput.blur();
          document.body.removeChild(hiddenInput);
          Logger.log("\u{1F4F1} \uBAA8\uBC14\uC77C: \uD0A4\uBCF4\uB4DC \uC228\uAE40 \uCC98\uB9AC \uC644\uB8CC");
        }, 50);
      }, 100);
      if (window.visualViewport) {
        const handleViewportChange = () => {
          if (this.tooltip && this.isVisible) {
            setTimeout(() => {
              var _a2;
              const targetElement = document.querySelector(`[data-error-id="${(_a2 = this.currentError) == null ? void 0 : _a2.uniqueId}"]`);
              if (targetElement) {
                this.positionTooltip(targetElement);
              }
            }, 300);
          }
        };
        window.visualViewport.addEventListener("resize", handleViewportChange, { once: true });
      }
    } catch (error) {
      Logger.warn("\u{1F4F1} \uBAA8\uBC14\uC77C \uD0A4\uBCF4\uB4DC \uC228\uAE40 \uC911 \uC624\uB958:", error);
    }
  }
};
var globalInlineTooltip = new InlineTooltip();
window.globalInlineTooltip = globalInlineTooltip;

// src/services/inlineModeService.ts
var import_obsidian11 = require("obsidian");
var import_obsidian12 = require("obsidian");
var import_obsidian13 = require("obsidian");
var addErrorDecorations = import_state.StateEffect.define({
  map: (val, change) => val
});
var removeErrorDecorations = import_state.StateEffect.define({
  map: (val, change) => val
});
var clearAllErrorDecorations = import_state.StateEffect.define({
  map: (val, change) => val
});
var setFocusedErrorDecoration = import_state.StateEffect.define({
  map: (val, change) => val
});
var setTemporarySuggestionMode = import_state.StateEffect.define({
  map: (val, change) => val
});
var temporarySuggestionModeField = import_state.StateField.define({
  create() {
    return false;
  },
  update(isTemporary, tr) {
    for (let effect of tr.effects) {
      if (effect.is(setTemporarySuggestionMode)) {
        return effect.value;
      }
    }
    return isTemporary;
  }
});
var errorDecorationField = import_state.StateField.define({
  create() {
    return import_view.Decoration.none;
  },
  update(decorations, tr) {
    decorations = decorations.map(tr.changes);
    const isTemporaryMode = tr.state.field(temporarySuggestionModeField);
    if (tr.docChanged && !isTemporaryMode) {
      const changedRanges = [];
      tr.changes.iterChanges((fromA, toA, fromB, toB) => {
        changedRanges.push({ from: fromA, to: toA });
      });
      if (changedRanges.length > 0) {
        decorations = decorations.update({
          filter: (from, to, decoration) => {
            return !changedRanges.some(
              (range) => from >= range.from && from <= range.to || to >= range.from && to <= range.to || from <= range.from && to >= range.to
            );
          }
        });
        InlineModeService.removeErrorsInRanges(changedRanges);
        Logger.debug(`\uC778\uB77C\uC778 \uBAA8\uB4DC: \uD14D\uC2A4\uD2B8 \uBCC0\uACBD\uC73C\uB85C \uC624\uB958 \uC81C\uAC70\uB428 (${changedRanges.length}\uAC1C \uBC94\uC704)`);
      }
    }
    for (let effect of tr.effects) {
      if (effect.is(addErrorDecorations)) {
        const { errors, underlineStyle, underlineColor } = effect.value;
        const newDecorations = errors.map((error) => {
          const isFocused = false;
          return import_view.Decoration.mark({
            class: `korean-grammar-error-inline ${isFocused ? "korean-grammar-focused" : ""}`,
            attributes: {
              "data-error-id": error.uniqueId,
              "data-original": error.correction.original,
              "data-corrected": JSON.stringify(error.correction.corrected),
              "role": "button",
              "tabindex": "0",
              "style": isFocused ? "" : `
                text-decoration-line: underline !important;
                text-decoration-style: ${underlineStyle} !important;
                text-decoration-color: ${underlineColor} !important;
                text-decoration-thickness: 2px !important;
                background-color: rgba(255, 0, 0, 0.05) !important;
                cursor: pointer !important;
              `
            }
          }).range(error.start, error.end);
        });
        newDecorations.sort((a, b) => a.from - b.from);
        decorations = decorations.update({
          add: newDecorations,
          sort: true
        });
      } else if (effect.is(removeErrorDecorations)) {
        const errorIds = effect.value;
        decorations = decorations.update({
          filter: (from, to, decoration) => {
            var _a;
            const errorId = (_a = decoration.spec.attributes) == null ? void 0 : _a["data-error-id"];
            return errorId ? !errorIds.includes(errorId) : true;
          }
        });
      } else if (effect.is(clearAllErrorDecorations)) {
        decorations = import_view.Decoration.none;
      } else if (effect.is(setFocusedErrorDecoration)) {
        const focusedErrorId = effect.value;
        Logger.log(`\u{1F3AF} \uD3EC\uCEE4\uC2A4 decoration \uC5C5\uB370\uC774\uD2B8: ${focusedErrorId}`);
        const activeErrorsArray = InlineModeService.getActiveErrors();
        Logger.debug(`\u{1F3AF} \uD3EC\uCEE4\uC2A4 decoration \uC5C5\uB370\uC774\uD2B8 \uC2DC\uC791: ${activeErrorsArray.length}\uAC1C \uC624\uB958, \uD0C0\uAC9F: ${focusedErrorId}`);
        if (activeErrorsArray.length > 0) {
          const newDecorations = activeErrorsArray.map((error) => {
            const isFocused = error.uniqueId === focusedErrorId;
            if (isFocused) {
              Logger.debug(`\u{1F3AF} \uD3EC\uCEE4\uC2A4 \uB9E4\uCE6D: "${error.correction.original}" (${error.uniqueId}) at ${error.start}-${error.end}`);
            }
            return import_view.Decoration.mark({
              class: `korean-grammar-error-inline ${isFocused ? "korean-grammar-focused" : ""}`,
              attributes: {
                "data-error-id": error.uniqueId,
                "data-original": error.correction.original,
                "data-corrected": JSON.stringify(error.correction.corrected),
                "role": "button",
                "tabindex": "0",
                "style": isFocused ? "" : `
                  text-decoration-line: underline !important;
                  text-decoration-style: wavy !important;
                  text-decoration-color: #ff0000 !important;
                  text-decoration-thickness: 2px !important;
                  background-color: rgba(255, 0, 0, 0.05) !important;
                  cursor: pointer !important;
                `
              }
            }).range(error.start, error.end);
          });
          newDecorations.sort((a, b) => a.from - b.from);
          decorations = import_view.Decoration.set(newDecorations);
        }
      }
    }
    return decorations;
  },
  provide: (field) => import_view.EditorView.decorations.from(field)
});
var InlineModeService = class {
  /**
   * ÏóêÎîîÌÑ∞ Î∑∞ Î∞è ÏÑ§Ï†ï Ï¥àÍ∏∞Ìôî
   */
  static setEditorView(view, settings, app) {
    this.currentView = view;
    if (settings) {
      this.settings = settings;
    }
    if (app) {
      this.app = app;
    }
    this.setupEventListeners(view);
    Logger.debug("\uC778\uB77C\uC778 \uBAA8\uB4DC: Command Palette \uAE30\uBC18 \uD0A4\uBCF4\uB4DC \uB2E8\uCD95\uD0A4 \uC0AC\uC6A9");
    Logger.debug("\uC778\uB77C\uC778 \uBAA8\uB4DC: \uC5D0\uB514\uD130 \uBDF0 \uC124\uC815\uB428");
  }
  /**
   * Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà ÏÑ§Ï†ï (Í≤πÏπòÎäî Ïò§Î•ò ÏòÅÏó≠ Ï≤òÎ¶¨ Í∞úÏÑ†)
   */
  static setupEventListeners(view) {
    const editorDOM = view.dom;
    this.setupCursorMonitoring(view);
    editorDOM.addEventListener("mouseenter", (e) => {
      var _a;
      const target = e.target;
      if (target.classList.contains("korean-grammar-error-inline")) {
        const errorId = target.getAttribute("data-error-id");
        if (errorId && this.activeErrors.has(errorId)) {
          const error = this.activeErrors.get(errorId);
          if (((_a = this.currentHoveredError) == null ? void 0 : _a.uniqueId) === errorId) {
            Logger.debug(`\uC774\uBBF8 \uD638\uBC84 \uC911\uC778 \uC624\uB958: ${error.correction.original}`);
            return;
          }
          this.clearHoverTimeout();
          Logger.debug(`\uC0C8\uB85C\uC6B4 \uC624\uB958 \uD638\uBC84 \uC2DC\uC791: "${error.correction.original}" (ID: ${errorId})`);
          const mousePosition = { x: e.clientX, y: e.clientY };
          this.hoverTimeout = setTimeout(() => {
            this.currentHoveredError = error;
            this.handleErrorHover(error, target, mousePosition);
          }, 300);
        }
      }
    }, true);
    editorDOM.addEventListener("mouseleave", (e) => {
      var _a;
      const target = e.target;
      if (target.classList.contains("korean-grammar-error-inline")) {
        const errorId = target.getAttribute("data-error-id");
        if (((_a = this.currentHoveredError) == null ? void 0 : _a.uniqueId) === errorId) {
          Logger.debug(`\uC624\uB958 \uD638\uBC84 \uC885\uB8CC: "${this.currentHoveredError.correction.original}" (ID: ${errorId})`);
          this.clearHoverTimeout();
          setTimeout(() => {
            var _a2;
            if (((_a2 = this.currentHoveredError) == null ? void 0 : _a2.uniqueId) === errorId) {
              this.currentHoveredError = null;
            }
          }, 150);
        }
      }
    }, true);
    editorDOM.addEventListener("click", (e) => {
      try {
        if (import_obsidian11.Platform.isMobile) {
          Logger.debug("\uBAA8\uBC14\uC77C\uC5D0\uC11C \uD074\uB9AD \uC774\uBCA4\uD2B8 \uBB34\uC2DC (\uD130\uCE58 \uC774\uBCA4\uD2B8 \uC0AC\uC6A9)");
          return;
        }
        const target = e.target;
        if (target && target.classList && target.classList.contains("korean-grammar-error-inline")) {
          e.preventDefault();
          e.stopPropagation();
          const errorId = target.getAttribute("data-error-id");
          if (errorId && this.activeErrors.has(errorId)) {
            const error = this.activeErrors.get(errorId);
            if (error) {
              const mousePosition = { x: e.clientX, y: e.clientY };
              this.handleErrorClick(error, target, mousePosition);
            }
          }
        }
      } catch (err) {
        Logger.error("\uD074\uB9AD \uC774\uBCA4\uD2B8 \uCC98\uB9AC \uC911 \uC624\uB958:", err);
      }
    }, true);
    editorDOM.addEventListener("focus", (e) => {
      const target = e.target;
      if (target.classList.contains("korean-grammar-error-inline")) {
        const errorId = target.getAttribute("data-error-id");
        if (errorId && this.activeErrors.has(errorId)) {
          const error = this.activeErrors.get(errorId);
          if (this.currentFocusedError && this.currentFocusedError.uniqueId === error.uniqueId) {
            Logger.debug(`\uC774\uBBF8 \uD3EC\uCEE4\uC2A4\uB41C \uC624\uB958 \uC2A4\uD0B5: ${error.uniqueId}`);
            return;
          }
          this.setFocusedError(error);
        }
      }
    }, true);
    Logger.debug("\uC778\uB77C\uC778 \uBAA8\uB4DC: \uC774\uBCA4\uD2B8 \uB9AC\uC2A4\uB108 \uC124\uC815\uB428 (\uC815\uD655\uD55C \uD638\uBC84 \uC694\uC18C\uB9CC \uCC98\uB9AC)");
    this.setupMobileTouchEvents(editorDOM);
  }
  /**
   * Î™®Î∞îÏùº ÌÑ∞Ïπò Ïù¥Î≤§Ìä∏ ÏÑ§Ï†ï
   */
  static setupMobileTouchEvents(editorDOM) {
    if (!import_obsidian11.Platform.isMobile) {
      Logger.debug("\uB370\uC2A4\uD06C\uD1B1 \uD658\uACBD: \uD130\uCE58 \uC774\uBCA4\uD2B8 \uB4F1\uB85D\uD558\uC9C0 \uC54A\uC74C");
      return;
    }
    let touchTimer = null;
    let touchTarget = null;
    let touchStartTime = 0;
    const TOUCH_HOLD_DURATION = 600;
    const MAX_TOUCH_MOVE = 10;
    let touchStartPos = { x: 0, y: 0 };
    Logger.log("\u{1F4F1} \uBAA8\uBC14\uC77C \uD130\uCE58 \uC774\uBCA4\uD2B8 \uB4F1\uB85D");
    editorDOM.addEventListener("touchstart", (e) => {
      const target = e.target;
      if (target.classList.contains("korean-grammar-error-inline")) {
        e.preventDefault();
        const touch = e.touches[0];
        touchStartPos = { x: touch.clientX, y: touch.clientY };
        touchStartTime = Date.now();
        touchTarget = target;
        const errorId = target.getAttribute("data-error-id");
        if (errorId && this.activeErrors.has(errorId)) {
          const error = this.activeErrors.get(errorId);
          touchTimer = setTimeout(() => {
            if (touchTarget === target && this.activeErrors.has(errorId)) {
              Logger.log(`\u{1F4F1} \uB871\uD504\uB808\uC2A4\uB85C \uBC14\uB85C \uC218\uC815: ${error.correction.original}`);
              if ("vibrate" in navigator) {
                navigator.vibrate(50);
              }
              if (error.correction.corrected && error.correction.corrected.length > 0) {
                const firstSuggestion = error.correction.corrected[0];
                this.applySuggestion(error, firstSuggestion);
                Logger.log(`\u{1F4F1} \uB871\uD504\uB808\uC2A4 \uC218\uC815 \uC644\uB8CC: "${error.correction.original}" \u2192 "${firstSuggestion}"`);
              }
              touchTarget = null;
              touchTimer = null;
            }
          }, TOUCH_HOLD_DURATION);
          Logger.debug(`\u{1F4F1} \uD130\uCE58 \uC2DC\uC791: ${error.correction.original}`);
        }
      }
    }, { passive: false });
    editorDOM.addEventListener("touchend", (e) => {
      const wasTouchTimer = touchTimer !== null;
      if (touchTimer) {
        clearTimeout(touchTimer);
        touchTimer = null;
      }
      const touchDuration = Date.now() - touchStartTime;
      if (touchDuration < TOUCH_HOLD_DURATION && touchTarget && wasTouchTimer) {
        const target = touchTarget;
        const errorId = target.getAttribute("data-error-id");
        if (errorId && this.activeErrors.has(errorId)) {
          const error = this.activeErrors.get(errorId);
          Logger.log(`\u{1F4F1} \uC9E7\uC740 \uD130\uCE58\uB85C \uD234\uD301 \uD45C\uC2DC (${touchDuration}ms): ${error.correction.original}`);
          e.preventDefault();
          e.stopPropagation();
          setTimeout(() => {
            const touchPosition = { x: touchStartPos.x, y: touchStartPos.y };
            this.handleErrorTooltip(error, target, touchPosition);
          }, 50);
        }
      }
      touchTarget = null;
      touchStartTime = 0;
    }, { passive: false });
    editorDOM.addEventListener("touchcancel", () => {
      if (touchTimer) {
        clearTimeout(touchTimer);
        touchTimer = null;
        Logger.debug("\u{1F4F1} \uD130\uCE58 \uCDE8\uC18C\uB428");
      }
      touchTarget = null;
      touchStartTime = 0;
    }, { passive: true });
    editorDOM.addEventListener("touchmove", (e) => {
      if (touchTimer && touchTarget) {
        const touch = e.touches[0];
        const moveDistance = Math.sqrt(
          Math.pow(touch.clientX - touchStartPos.x, 2) + Math.pow(touch.clientY - touchStartPos.y, 2)
        );
        if (moveDistance > MAX_TOUCH_MOVE) {
          clearTimeout(touchTimer);
          touchTimer = null;
          touchTarget = null;
          Logger.debug(`\u{1F4F1} \uD130\uCE58 \uC774\uB3D9\uC73C\uB85C \uB871\uD504\uB808\uC2A4 \uCDE8\uC18C (${Math.round(moveDistance)}px)`);
        }
      }
    }, { passive: true });
    Logger.log("\u{1F4F1} \uBAA8\uBC14\uC77C \uD130\uCE58 \uC774\uBCA4\uD2B8 \uC124\uC815 \uC644\uB8CC");
    Logger.log("  \u2022 \uD130\uCE58: \uD234\uD301 \uD45C\uC2DC");
    Logger.log("  \u2022 \uB871\uD504\uB808\uC2A4 (600ms): \uCCAB \uBC88\uC9F8 \uC81C\uC548\uC73C\uB85C \uBC14\uB85C \uC218\uC815");
    Logger.log("  \u2022 \uD585\uD2F1 \uD53C\uB4DC\uBC31 \uC9C0\uC6D0");
  }
  /**
   * Ìò∏Î≤Ñ ÌÉÄÏù¥Î®∏ Ï†ïÎ¶¨
   */
  static clearHoverTimeout() {
    if (this.hoverTimeout) {
      clearTimeout(this.hoverTimeout);
      this.hoverTimeout = null;
    }
  }
  /**
   * üéØ Ïª§ÏÑú ÏúÑÏπò Î≥ÄÍ≤Ω Î™®ÎãàÌÑ∞ÎßÅ ÏÑ§Ï†ï
   */
  static setupCursorMonitoring(view) {
    if (!this.app)
      return;
    setInterval(() => {
      this.checkCursorPosition();
    }, 500);
    Logger.debug("\u{1F3AF} \uCEE4\uC11C \uC704\uCE58 \uBAA8\uB2C8\uD130\uB9C1 \uC124\uC815 \uC644\uB8CC");
  }
  /**
   * üéØ Ïª§ÏÑú ÏúÑÏπò Ï≤¥ÌÅ¨ (Ï£ºÍ∏∞Ï†Å Ìò∏Ï∂ú)
   */
  static checkCursorPosition() {
    if (!this.currentFocusedError || !this.app)
      return;
    const view = this.app.workspace.getActiveViewOfType(import_obsidian13.MarkdownView);
    if (!view)
      return;
    const editor = view.editor;
    const cursor = editor.getCursor();
    const cursorOffset = editor.posToOffset(cursor);
    if (cursorOffset < this.currentFocusedError.start || cursorOffset > this.currentFocusedError.end) {
      Logger.debug(`\u{1F3AF} \uCEE4\uC11C\uAC00 \uD3EC\uCEE4\uC2A4 \uC601\uC5ED\uC744 \uBC97\uC5B4\uB0A8: ${cursorOffset} (\uBC94\uC704: ${this.currentFocusedError.start}-${this.currentFocusedError.end})`);
      const focusedErrorId = this.currentFocusedError.uniqueId;
      this.clearFocusedError();
      if (window.globalInlineTooltip) {
        window.globalInlineTooltip.hide();
      }
      if (this.activeErrors.has(focusedErrorId)) {
        this.activeErrors.delete(focusedErrorId);
        if (this.currentView) {
          this.currentView.dispatch({
            effects: [removeErrorDecorations.of([focusedErrorId])]
          });
        }
        Logger.debug(`\u{1F527} \uC218\uC815 \uB864\uB9C1 \uD6C4 \uC624\uB958 \uC644\uC804 \uC81C\uAC70: ${focusedErrorId}`);
      }
    }
  }
  /**
   * üéØ ÌòÑÏû¨ Ïª§ÏÑú ÏúÑÏπòÏóê ÏûàÎäî Ïò§Î•ò Ï∞æÍ∏∞
   */
  static findErrorAtCursor() {
    if (!this.app)
      return null;
    const view = this.app.workspace.getActiveViewOfType(import_obsidian13.MarkdownView);
    if (!view)
      return null;
    const editor = view.editor;
    const cursor = editor.getCursor();
    const cursorOffset = editor.posToOffset(cursor);
    for (const [, error] of this.activeErrors) {
      if (cursorOffset >= error.start && cursorOffset <= error.end) {
        Logger.debug(`\u{1F3AF} \uCEE4\uC11C \uC704\uCE58\uC5D0\uC11C \uC624\uB958 \uBC1C\uACAC: "${error.correction.original}" (${error.start}-${error.end})`);
        return error;
      }
    }
    Logger.debug(`\u{1F3AF} \uCEE4\uC11C \uC704\uCE58\uC5D0 \uC624\uB958 \uC5C6\uC74C: ${cursorOffset}`);
    return null;
  }
  /**
   * ÏÑ§Ï†ï ÏóÖÎç∞Ïù¥Ìä∏
   */
  static updateSettings(settings) {
    this.settings = settings;
    Logger.debug("\uC778\uB77C\uC778 \uBAA8\uB4DC: \uC124\uC815 \uC5C5\uB370\uC774\uD2B8\uB428");
  }
  /**
   * Ïò§Î•ò ÌëúÏãú
   */
  static showErrors(view, corrections, underlineStyle = "wavy", underlineColor = "#ff0000", app) {
    if (!view || !corrections.length) {
      Logger.warn("\uC778\uB77C\uC778 \uBAA8\uB4DC: \uBDF0\uB098 \uAD50\uC815 \uB370\uC774\uD130\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.");
      return;
    }
    this.clearErrors(view);
    const doc = view.state.doc;
    const fullText = doc.toString();
    const errors = [];
    corrections.forEach((correction, index) => {
      const searchText = correction.original;
      let searchIndex = 0;
      let occurrence = 0;
      while (true) {
        const foundIndex = fullText.indexOf(searchText, searchIndex);
        if (foundIndex === -1)
          break;
        const beforeChar = foundIndex > 0 ? fullText[foundIndex - 1] : " ";
        const afterChar = foundIndex + searchText.length < fullText.length ? fullText[foundIndex + searchText.length] : " ";
        const isWordBoundary = this.isValidWordBoundary(beforeChar, afterChar, searchText);
        if (isWordBoundary) {
          const uniqueId = `${index}_${occurrence}_${foundIndex}`;
          const lineInfo = doc.lineAt(foundIndex);
          const error = {
            correction,
            start: foundIndex,
            end: foundIndex + searchText.length,
            line: lineInfo.number,
            ch: foundIndex - lineInfo.from,
            uniqueId,
            isActive: true
          };
          errors.push(error);
          this.activeErrors.set(uniqueId, error);
          Logger.debug(`\u{1F3AF} \uC624\uB958 \uC704\uCE58 \uC124\uC815: "${searchText}" (${uniqueId}) at ${foundIndex}-${foundIndex + searchText.length}`);
          occurrence++;
        }
        searchIndex = foundIndex + 1;
      }
    });
    const mergedErrors = this.mergeOverlappingErrors(errors);
    Logger.debug(`\u{1F527} \uC624\uB958 \uBCD1\uD569: ${errors.length}\uAC1C \u2192 ${mergedErrors.length}\uAC1C`);
    view.dispatch({
      effects: addErrorDecorations.of({ errors: mergedErrors, underlineStyle, underlineColor })
    });
    Logger.log(`\uC778\uB77C\uC778 \uBAA8\uB4DC: ${mergedErrors.length}\uAC1C \uC624\uB958 \uD45C\uC2DC\uB428 (\uBCD1\uD569 \uD6C4)`);
  }
  /**
   * Í≤πÏπòÎäî Ïò§Î•òÎì§ÏùÑ Î≥ëÌï©ÌïòÏó¨ Î∂ÑÏ†àÎêú ÌïòÏù¥ÎùºÏù¥ÌåÖ Î∞©ÏßÄ
   */
  static mergeOverlappingErrors(errors) {
    var _a;
    if (errors.length <= 1)
      return errors;
    const sortedErrors = [...errors].sort((a, b) => {
      if (a.start !== b.start)
        return a.start - b.start;
      return a.end - b.end;
    });
    const merged = [];
    let current = sortedErrors[0];
    for (let i = 1; i < sortedErrors.length; i++) {
      const next = sortedErrors[i];
      const isOverlapping = current.end > next.start;
      const isAdjacent = current.end >= next.start - 1;
      if (isOverlapping || isAdjacent) {
        const doc = (_a = this.currentView) == null ? void 0 : _a.state.doc;
        const mergedStart = Math.min(current.start, next.start);
        const mergedEnd = Math.max(current.end, next.end);
        const mergedText = (doc == null ? void 0 : doc.sliceString(mergedStart, mergedEnd)) || "";
        const currentText = (doc == null ? void 0 : doc.sliceString(current.start, current.end)) || current.correction.original;
        const nextText = (doc == null ? void 0 : doc.sliceString(next.start, next.end)) || next.correction.original;
        const originalErrors = [];
        if (current.isMerged && current.originalErrors) {
          originalErrors.push(...current.originalErrors);
        } else {
          originalErrors.push(current);
        }
        if (next.isMerged && next.originalErrors) {
          originalErrors.push(...next.originalErrors);
        } else {
          originalErrors.push(next);
        }
        const mergedCorrected = [.../* @__PURE__ */ new Set([
          ...current.correction.corrected,
          ...next.correction.corrected
        ])];
        const mergedError = {
          correction: {
            original: mergedText,
            corrected: mergedCorrected,
            help: current.correction.help || next.correction.help
          },
          start: mergedStart,
          end: mergedEnd,
          line: current.line,
          ch: current.ch,
          uniqueId: `merged_${current.uniqueId}_${next.uniqueId}`,
          isActive: true,
          isMerged: true,
          originalErrors
          // ÏõêÎ≥∏ Ïò§Î•òÎì§ Î≥¥Ï°¥
        };
        this.activeErrors.delete(current.uniqueId);
        this.activeErrors.delete(next.uniqueId);
        this.activeErrors.set(mergedError.uniqueId, mergedError);
        current = mergedError;
        Logger.debug(`\u{1F517} \uC624\uB958 \uBCD1\uD569: "${currentText}" (${current.start}-${current.end}) + "${nextText}" (${next.start}-${next.end}) \u2192 "${mergedText}" (${mergedStart}-${mergedEnd}), \uC6D0\uBCF8 \uC624\uB958 ${originalErrors.length}\uAC1C \uBCF4\uC874`);
      } else {
        merged.push(current);
        current = next;
      }
    }
    merged.push(current);
    return merged;
  }
  /**
   * ÌäπÏ†ï Ïò§Î•ò Ï†úÍ±∞
   */
  static removeError(view, errorId) {
    const targetView = view || this.currentView;
    if (!targetView || !this.activeErrors.has(errorId))
      return;
    this.activeErrors.delete(errorId);
    targetView.dispatch({
      effects: removeErrorDecorations.of([errorId])
    });
    Logger.debug(`\uC778\uB77C\uC778 \uBAA8\uB4DC: \uC624\uB958 \uC81C\uAC70\uB428 (${errorId})`);
  }
  /**
   * Î™®Îì† Ïò§Î•ò Ï†úÍ±∞
   */
  static clearErrors(view) {
    if (!view)
      return;
    this.activeErrors.clear();
    view.dispatch({
      effects: clearAllErrorDecorations.of(true)
    });
    Logger.debug("\uC778\uB77C\uC778 \uBAA8\uB4DC: \uBAA8\uB4E0 \uC624\uB958 \uC81C\uAC70\uB428");
  }
  /**
   * ÌäπÏ†ï Î≤îÏúÑÏùò Ïò§Î•òÎì§ÏùÑ activeErrorsÏóêÏÑú Ï†úÍ±∞
   */
  static removeErrorsInRanges(ranges) {
    const errorsToRemove = [];
    this.activeErrors.forEach((error, errorId) => {
      const errorOverlaps = ranges.some(
        (range) => error.start >= range.from && error.start <= range.to || error.end >= range.from && error.end <= range.to || error.start <= range.from && error.end >= range.to
      );
      if (errorOverlaps) {
        errorsToRemove.push(errorId);
      }
    });
    errorsToRemove.forEach((errorId) => {
      this.activeErrors.delete(errorId);
    });
    if (errorsToRemove.length > 0) {
      Logger.debug(`\uC778\uB77C\uC778 \uBAA8\uB4DC: activeErrors\uC5D0\uC11C ${errorsToRemove.length}\uAC1C \uC624\uB958 \uC81C\uAC70\uB428`);
    }
  }
  /**
   * ÌÖçÏä§Ìä∏ Î≤îÏúÑÏùò Ïò§Î•ò Ï†úÍ±∞ (ÏÇ¨Ïö©Ïûê Ìé∏Ïßë Ïãú)
   */
  static removeErrorsInRange(view, from, to) {
    if (!view)
      return;
    const errorsToRemove = [];
    this.activeErrors.forEach((error, errorId) => {
      if (error.start < to && error.end > from) {
        errorsToRemove.push(errorId);
      }
    });
    if (errorsToRemove.length > 0) {
      errorsToRemove.forEach((id) => this.activeErrors.delete(id));
      view.dispatch({
        effects: removeErrorDecorations.of(errorsToRemove)
      });
      Logger.debug(`\uC778\uB77C\uC778 \uBAA8\uB4DC: \uBC94\uC704 \uB0B4 ${errorsToRemove.length}\uAC1C \uC624\uB958 \uC81C\uAC70\uB428`);
    }
  }
  /**
   * Ïò§Î•ò Ìò∏Î≤Ñ Ìï∏Îì§Îü¨
   */
  static handleErrorHover(error, hoveredElement, mousePosition) {
    Logger.debug(`\uC778\uB77C\uC778 \uBAA8\uB4DC: \uC624\uB958 \uD638\uBC84 - ${error.correction.original}`);
    const shouldShowTooltip = this.shouldShowTooltipOnInteraction("hover");
    if (shouldShowTooltip) {
      const targetElement = hoveredElement || this.findErrorElement(error);
      if (targetElement) {
        globalInlineTooltip.show(error, targetElement, "hover", mousePosition);
      }
    }
  }
  /**
   * Ïò§Î•ò ÌÅ¥Î¶≠ Ìï∏Îì§Îü¨
   */
  static handleErrorClick(error, clickedElement, mousePosition) {
    Logger.log(`\uC778\uB77C\uC778 \uBAA8\uB4DC: \uC624\uB958 \uD074\uB9AD - ${error.correction.original}`);
    try {
      if (window.globalInlineTooltip) {
        window.globalInlineTooltip.hide();
      }
      if (error.correction.corrected && error.correction.corrected.length > 0) {
        const firstSuggestion = error.correction.corrected[0];
        this.applySuggestion(error, firstSuggestion);
        Logger.log(`\uC778\uB77C\uC778 \uBAA8\uB4DC: \uCCAB \uBC88\uC9F8 \uC81C\uC548 \uC790\uB3D9 \uC801\uC6A9 - "${error.correction.original}" \u2192 "${firstSuggestion}"`);
      } else {
        Logger.warn(`\uC778\uB77C\uC778 \uBAA8\uB4DC: \uC218\uC815 \uC81C\uC548\uC774 \uC5C6\uC2B5\uB2C8\uB2E4 - ${error.correction.original}`);
      }
    } catch (err) {
      Logger.error("\uC624\uB958 \uD074\uB9AD \uCC98\uB9AC \uC911 \uBB38\uC81C \uBC1C\uC0DD:", err);
      if (window.globalInlineTooltip) {
        window.globalInlineTooltip.hide();
      }
    }
  }
  /**
   * Ïò§Î•ò Ìà¥ÌåÅ ÌëúÏãú Ìï∏Îì§Îü¨ (Î∞îÎ°ú Ï†ÅÏö©ÌïòÏßÄ ÏïäÍ≥† Ìà¥ÌåÅÎßå ÌëúÏãú)
   */
  static handleErrorTooltip(error, targetElement, touchPosition) {
    Logger.log(`\uC778\uB77C\uC778 \uBAA8\uB4DC: \uC624\uB958 \uD234\uD301 \uD45C\uC2DC - ${error.correction.original}`);
    try {
      const element = targetElement || this.findErrorElement(error);
      if (element) {
        globalInlineTooltip.show(error, element, "click", touchPosition);
      } else {
        Logger.warn(`\uC778\uB77C\uC778 \uBAA8\uB4DC: \uD0C0\uAC9F \uC694\uC18C\uB97C \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4 - ${error.correction.original}`);
      }
    } catch (err) {
      Logger.error("\uC624\uB958 \uD234\uD301 \uD45C\uC2DC \uC911 \uBB38\uC81C \uBC1C\uC0DD:", err);
    }
  }
  /**
   * ÌòÑÏû¨ ÌôúÏÑ±ÌôîÎêú Ïò§Î•ò Î™©Î°ù Î∞òÌôò (ÏúÑÏπò Í∏∞Ï§Ä Ï†ïÎ†¨)
   */
  static getActiveErrors() {
    const errors = Array.from(this.activeErrors.values());
    return errors.sort((a, b) => {
      if (a.start !== b.start) {
        return a.start - b.start;
      }
      if (a.end !== b.end) {
        return a.end - b.end;
      }
      return a.uniqueId.localeCompare(b.uniqueId);
    });
  }
  /**
   * ÌäπÏ†ï ÏúÑÏπòÏùò Ïò§Î•ò Ï∞æÍ∏∞
   */
  static getErrorAtPosition(pos) {
    for (const error of this.activeErrors.values()) {
      if (pos >= error.start && pos <= error.end) {
        return error;
      }
    }
    return null;
  }
  /**
   * Ïò§Î•òÏóê Ìï¥ÎãπÌïòÎäî DOM ÏöîÏÜå Ï∞æÍ∏∞ (ÏúÑÏπò Í∏∞Î∞ò Ï†ïÌôïÌïú Îß§Ïπ≠)
   */
  static findErrorElement(error) {
    const exactElement = document.querySelector(`[data-error-id="${error.uniqueId}"]`);
    if (exactElement) {
      return exactElement;
    }
    const errorElements = document.querySelectorAll(".korean-grammar-error-inline");
    for (let i = 0; i < errorElements.length; i++) {
      const element = errorElements[i];
      if (element.textContent === error.correction.original) {
        Logger.warn(`\uC815\uD655\uD55C ID \uB9E4\uCE6D \uC2E4\uD328, \uD14D\uC2A4\uD2B8 \uAE30\uBC18 \uB9E4\uCE6D \uC0AC\uC6A9: ${error.correction.original}`);
        return element;
      }
    }
    Logger.warn(`\uC624\uB958 \uC694\uC18C\uB97C \uCC3E\uC744 \uC218 \uC5C6\uC74C: ${error.correction.original} (ID: ${error.uniqueId})`);
    return null;
  }
  /**
   * ÏàòÏ†ï Ï†úÏïà Ï†ÅÏö©
   */
  static applySuggestion(error, suggestion) {
    if (!this.currentView) {
      Logger.error("\uC5D0\uB514\uD130 \uBDF0\uAC00 \uC124\uC815\uB418\uC9C0 \uC54A\uC74C");
      return;
    }
    try {
      if (error.isMerged && error.originalErrors) {
        this.applyIndividualSuggestion(error, suggestion);
        return;
      }
      this.applySingleSuggestion(error, suggestion);
    } catch (err) {
      Logger.error("\uC218\uC815 \uC81C\uC548 \uC801\uC6A9 \uC911 \uC624\uB958:", err);
    }
  }
  /**
   * Í∞úÎ≥Ñ ÍµêÏ†ï Ï†úÏïà Ï†ÅÏö© (Î≥ëÌï©Îêú Ïò§Î•òÏóêÏÑú ÌäπÏ†ï Î∂ÄÎ∂ÑÎßå ÍµêÏ≤¥)
   */
  static applyIndividualSuggestion(mergedError, suggestion) {
    if (!mergedError.originalErrors || !this.currentView)
      return;
    const targetError = mergedError.originalErrors.find(
      (originalError) => originalError.correction.corrected.includes(suggestion)
    );
    if (!targetError) {
      Logger.warn(`\uC77C\uCE58\uD558\uB294 \uC6D0\uBCF8 \uC624\uB958\uB97C \uCC3E\uC744 \uC218 \uC5C6\uC74C: ${suggestion}`);
      return;
    }
    Logger.debug(`\u{1F3AF} \uAC1C\uBCC4 \uAD50\uC815 \uC801\uC6A9: "${targetError.correction.original}" \u2192 "${suggestion}" (${targetError.start}-${targetError.end})`);
    this.applySingleSuggestion(targetError, suggestion);
    mergedError.originalErrors = mergedError.originalErrors.filter((err) => err.uniqueId !== targetError.uniqueId);
    if (mergedError.originalErrors.length === 0) {
      this.removeError(this.currentView, mergedError.uniqueId);
    } else {
      this.updateMergedErrorAfterIndividualApplication(mergedError);
    }
  }
  /**
   * Îã®Ïùº Ïò§Î•òÏóê ÎåÄÌïú ÍµêÏ†ï Ï†úÏïà Ï†ÅÏö©
   */
  static applySingleSuggestion(error, suggestion) {
    if (!this.currentView)
      return;
    const doc = this.currentView.state.doc;
    const actualText = doc.sliceString(error.start, error.end);
    Logger.debug(`\uD14D\uC2A4\uD2B8 \uAD50\uCCB4 \uC2DC\uB3C4: \uBC94\uC704[${error.start}-${error.end}], \uC608\uC0C1="${error.correction.original}", \uC2E4\uC81C="${actualText}", \uAD50\uCCB4="${suggestion}"`);
    let fromPos = error.start;
    let toPos = error.end;
    if (actualText !== error.correction.original) {
      Logger.warn(`\uD14D\uC2A4\uD2B8 \uBD88\uC77C\uCE58 \uAC10\uC9C0, \uC7AC\uAC80\uC0C9 \uC2DC\uB3C4: "${error.correction.original}"`);
      const fullText = doc.toString();
      const searchIndex = fullText.indexOf(error.correction.original, Math.max(0, error.start - 100));
      if (searchIndex !== -1) {
        fromPos = searchIndex;
        toPos = searchIndex + error.correction.original.length;
        Logger.debug(`\uC7AC\uAC80\uC0C9 \uC131\uACF5: \uC0C8 \uBC94\uC704[${fromPos}-${toPos}]`);
      } else {
        Logger.error(`\uC7AC\uAC80\uC0C9 \uC2E4\uD328: "${error.correction.original}" \uD14D\uC2A4\uD2B8\uB97C \uCC3E\uC744 \uC218 \uC5C6\uC74C`);
        return;
      }
    }
    this.currentView.dispatch({
      changes: {
        from: fromPos,
        to: toPos,
        insert: suggestion
      }
    });
    this.removeError(this.currentView, error.uniqueId);
    const isKeepOpenMode = window.tooltipKeepOpenMode;
    if (!isKeepOpenMode) {
      if (window.globalInlineTooltip) {
        window.globalInlineTooltip.hide();
      }
      this.clearFocusedError();
    } else {
      Logger.debug("\uD234\uD301 \uC720\uC9C0 \uBAA8\uB4DC: \uD234\uD301 \uC228\uAE30\uAE30 \uAC74\uB108\uB700");
    }
    if (this.currentView) {
      this.currentView.dispatch({
        effects: [setTemporarySuggestionMode.of(false)]
      });
      Logger.debug("\u{1F3AF} \uCD5C\uC885 \uC801\uC6A9: \uC784\uC2DC \uC81C\uC548 \uBAA8\uB4DC \uD574\uC81C");
    }
    Logger.log(`\uC778\uB77C\uC778 \uBAA8\uB4DC: \uAD50\uC815 \uC644\uB8CC - "${error.correction.original}" \u2192 "${suggestion}"`);
  }
  /**
   * Í∞úÎ≥Ñ Ï†ÅÏö© ÌõÑ Î≥ëÌï©Îêú Ïò§Î•ò ÏóÖÎç∞Ïù¥Ìä∏
   */
  static updateMergedErrorAfterIndividualApplication(mergedError) {
    if (!mergedError.originalErrors || !this.currentView)
      return;
    const remainingErrors = mergedError.originalErrors;
    const newStart = Math.min(...remainingErrors.map((err) => err.start));
    const newEnd = Math.max(...remainingErrors.map((err) => err.end));
    const doc = this.currentView.state.doc;
    const newText = doc.sliceString(newStart, newEnd);
    const remainingCorrected = [...new Set(
      remainingErrors.flatMap((err) => err.correction.corrected)
    )];
    mergedError.start = newStart;
    mergedError.end = newEnd;
    mergedError.correction.original = newText;
    mergedError.correction.corrected = remainingCorrected;
    this.activeErrors.set(mergedError.uniqueId, mergedError);
    const mergedErrors = [mergedError];
    this.currentView.dispatch({
      effects: addErrorDecorations.of({
        errors: mergedErrors,
        underlineStyle: "wavy",
        underlineColor: "#ff0000"
      })
    });
    if (window.globalInlineTooltip && window.globalInlineTooltip.visible) {
      setTimeout(() => {
        const errorElement = this.findErrorElement(mergedError);
        if (errorElement && window.globalInlineTooltip) {
          window.globalInlineTooltip.hide();
          setTimeout(() => {
            window.globalInlineTooltip.show(mergedError, errorElement, "click");
          }, 50);
        }
      }, 100);
    }
    Logger.debug(`\u{1F504} \uBCD1\uD569\uB41C \uC624\uB958 \uC5C5\uB370\uC774\uD2B8: ${remainingErrors.length}\uAC1C \uC624\uB958 \uB0A8\uC74C, \uC0C8 \uBC94\uC704[${newStart}-${newEnd}], \uD234\uD301 \uC7AC\uD45C\uC2DC \uC608\uC57D`);
  }
  /**
   * üîß Î†àÍ±∞Ïãú Î©îÏÑúÎìú: ÌÇ§Î≥¥Îìú Ïä§ÏΩîÌîÑ Ï¥àÍ∏∞Ìôî (Command Palette Î∞©ÏãùÏúºÎ°ú ÎåÄÏ≤¥Îê®)
   */
  static initializeKeyboardScope() {
    Logger.log("\u{1F527} \uB808\uAC70\uC2DC: initializeKeyboardScope \uD638\uCD9C\uB428 - Command Palette \uBC29\uC2DD\uC73C\uB85C \uBCC0\uACBD\uB428");
    Logger.log('\u{1F4A1} \uC0AC\uC6A9\uBC95: Command Palette (Cmd+P)\uC5D0\uC11C "Korean Grammar Assistant" \uAC80\uC0C9');
    Logger.log("\u{1F4A1} \uB610\uB294 Settings > Hotkeys\uC5D0\uC11C \uC9C1\uC811 \uB2E8\uCD95\uD0A4 \uC124\uC815");
    return;
  }
  /**
   * Ìè¨Ïª§Ïä§Îêú Ïò§Î•ò ÏÑ§Ï†ï
   */
  static setFocusedError(error) {
    if (this.currentFocusedError) {
      this.removeFocusHighlight(this.currentFocusedError);
    }
    this.currentFocusedError = error;
    this.currentSuggestionIndex = 0;
    this.highlightFocusedError(error);
    this.moveEditorCursorToError(error);
    Logger.debug(`\uC624\uB958 \uD3EC\uCEE4\uC2A4 \uC124\uC815: ${error.correction.original}`);
  }
  /**
   * Ìè¨Ïª§Ïä§Îêú Ïò§Î•ò Ìï¥Ï†ú
   */
  static clearFocusedError() {
    if (this.currentFocusedError) {
      this.removeFocusHighlight(this.currentFocusedError);
    }
    this.currentFocusedError = null;
    this.currentSuggestionIndex = 0;
    if (window.globalInlineTooltip) {
      window.globalInlineTooltip.hide();
    }
    Logger.debug("\uC624\uB958 \uD3EC\uCEE4\uC2A4 \uD574\uC81C");
  }
  /**
   * Ìè¨Ïª§Ïä§Îêú Ïò§Î•òÏóê ÎåÄÌïú Ìà¥ÌåÅ ÌëúÏãú
   */
  static showTooltipForFocusedError() {
    if (!this.currentFocusedError)
      return;
    const elements = document.querySelectorAll(`[data-error-id="${this.currentFocusedError.uniqueId}"]`);
    if (elements.length > 0) {
      const targetElement = elements[0];
      globalInlineTooltip.show(this.currentFocusedError, targetElement, "click");
      Logger.debug(`\uD3EC\uCEE4\uC2A4\uB41C \uC624\uB958\uC5D0 \uD234\uD301 \uD45C\uC2DC: ${this.currentFocusedError.correction.original}`);
    }
  }
  /**
   * Ìè¨Ïª§Ïä§Îêú Ïò§Î•ò ÌïòÏù¥ÎùºÏù¥Ìä∏ (CodeMirror 6 decoration ÏÇ¨Ïö©)
   */
  static highlightFocusedError(error) {
    if (!this.currentView) {
      Logger.warn("\uC5D0\uB514\uD130 \uBDF0\uAC00 \uC5C6\uC5B4 \uD3EC\uCEE4\uC2A4 \uD558\uC774\uB77C\uC774\uD2B8 \uC2E4\uD328");
      return;
    }
    Logger.log(`\u{1F3AF} CodeMirror decoration\uC73C\uB85C \uD3EC\uCEE4\uC2A4 \uD558\uC774\uB77C\uC774\uD2B8: "${error.correction.original}" (${error.uniqueId}) at ${error.start}-${error.end}`);
    const allErrors = this.getActiveErrors();
    Logger.debug(`\u{1F3AF} \uD604\uC7AC \uD65C\uC131 \uC624\uB958\uB4E4: ${allErrors.map((e) => `"${e.correction.original}"(${e.uniqueId})[${e.start}-${e.end}]`).join(", ")}`);
    this.currentView.dispatch({
      effects: [setFocusedErrorDecoration.of(error.uniqueId)]
    });
    Logger.log(`\u{1F3AF} \uD3EC\uCEE4\uC2A4 decoration dispatch \uC644\uB8CC: ${error.uniqueId}`);
  }
  /**
   * ÏóêÎîîÌÑ∞ Ïª§ÏÑúÎ•º Ïò§Î•ò ÏúÑÏπòÎ°ú Ïù¥Îèô
   */
  static moveEditorCursorToError(error) {
    if (!this.currentView)
      return;
    try {
      const cursorPos = error.start;
      this.currentView.dispatch({
        selection: { anchor: cursorPos, head: cursorPos },
        scrollIntoView: true
      });
      Logger.debug(`\uCEE4\uC11C \uC774\uB3D9: ${error.correction.original} (\uC704\uCE58: ${error.start})`);
    } catch (e) {
      Logger.warn("\uCEE4\uC11C \uC774\uB3D9 \uC2E4\uD328:", e);
    }
  }
  /**
   * Ìè¨Ïª§Ïä§ ÌïòÏù¥ÎùºÏù¥Ìä∏ Ï†úÍ±∞ (CodeMirror 6 decoration ÏÇ¨Ïö©)
   */
  static removeFocusHighlight(error) {
    if (!this.currentView) {
      Logger.warn("\uC5D0\uB514\uD130 \uBDF0\uAC00 \uC5C6\uC5B4 \uD3EC\uCEE4\uC2A4 \uD558\uC774\uB77C\uC774\uD2B8 \uC81C\uAC70 \uC2E4\uD328");
      return;
    }
    Logger.debug(`\u{1F504} \uD3EC\uCEE4\uC2A4 decoration \uC81C\uAC70: "${error.correction.original}"`);
    this.currentView.dispatch({
      effects: [setFocusedErrorDecoration.of(null)]
    });
    Logger.debug(`\u{1F504} \uD3EC\uCEE4\uC2A4 decoration \uC81C\uAC70 \uC644\uB8CC`);
  }
  /**
   * Îã®Ïñ¥ Í≤ΩÍ≥Ñ Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
   */
  static isValidWordBoundary(beforeChar, afterChar, searchText) {
    const punctuation = /[\s.,;:!?'"()[\]{}<>]/;
    return true;
  }
  /**
   * Ìà¥ÌåÅÏùò ÏàòÏ†ï Ï†úÏïà ÌïòÏù¥ÎùºÏù¥Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏ - Ï†úÍ±∞Îê® (ÏÇ¨Ïö©Ïûê ÏöîÏ≤≠)
   */
  static updateTooltipHighlight() {
    return;
  }
  /**
   * ÏÑúÎπÑÏä§ Ï†ïÎ¶¨ (Î©îÎ™®Î¶¨ ÎàÑÏàò Î∞©ÏßÄ)
   */
  static cleanup() {
    var _a;
    this.activeErrors.clear();
    this.currentView = null;
    this.settings = null;
    this.currentFocusedError = null;
    this.currentSuggestionIndex = 0;
    this.currentHoveredError = null;
    this.clearHoverTimeout();
    if ((_a = window.globalInlineTooltip) == null ? void 0 : _a.visible) {
      window.globalInlineTooltip.hide();
    }
    Logger.debug("\uC778\uB77C\uC778 \uBAA8\uB4DC: \uC11C\uBE44\uC2A4 \uC815\uB9AC\uB428 (\uACB9\uCE58\uB294 \uC601\uC5ED \uCC98\uB9AC \uD3EC\uD568)");
  }
  /**
   * Ïù∏ÎùºÏù∏ Î™®Îìú Î™ÖÎ†πÏñ¥ Îì±Î°ù (Command Palette Î∞©Ïãù)
   */
  static registerCommands(plugin) {
    Logger.log("\u{1F3B9} \uC778\uB77C\uC778 \uBAA8\uB4DC: \uBA85\uB839\uC5B4 \uB4F1\uB85D \uC2DC\uC791");
    plugin.addCommand({
      id: "inline-next-error",
      name: "\uB2E4\uC74C \uBB38\uBC95 \uC624\uB958\uB85C \uC774\uB3D9",
      callback: () => {
        if (this.activeErrors.size === 0) {
          new import_obsidian12.Notice("\uD604\uC7AC \uAC10\uC9C0\uB41C \uBB38\uBC95 \uC624\uB958\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4. \uC778\uB77C\uC778 \uBAA8\uB4DC\uB97C \uD65C\uC131\uD654\uD558\uACE0 \uBB38\uBC95 \uAC80\uC0AC\uB97C \uC2E4\uD589\uD574\uC8FC\uC138\uC694.");
          return;
        }
        const nextError = this.findNextErrorFromCursor();
        if (nextError) {
          if (window.globalInlineTooltip) {
            window.globalInlineTooltip.hide();
          }
          this.moveToError(nextError);
          this.setFocusedError(nextError);
          Logger.log(`\u2705 \uB2E4\uC74C \uC624\uB958\uB85C \uC774\uB3D9: ${nextError.correction.original}`);
        } else {
          new import_obsidian12.Notice("\uB2E4\uC74C \uC624\uB958\uB97C \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
        }
      }
    });
    plugin.addCommand({
      id: "inline-previous-error",
      name: "\uC774\uC804 \uBB38\uBC95 \uC624\uB958\uB85C \uC774\uB3D9",
      callback: () => {
        if (this.activeErrors.size === 0) {
          new import_obsidian12.Notice("\uD604\uC7AC \uAC10\uC9C0\uB41C \uBB38\uBC95 \uC624\uB958\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4. \uC778\uB77C\uC778 \uBAA8\uB4DC\uB97C \uD65C\uC131\uD654\uD558\uACE0 \uBB38\uBC95 \uAC80\uC0AC\uB97C \uC2E4\uD589\uD574\uC8FC\uC138\uC694.");
          return;
        }
        const previousError = this.findPreviousErrorFromCursor();
        if (previousError) {
          if (window.globalInlineTooltip) {
            window.globalInlineTooltip.hide();
          }
          this.moveToError(previousError);
          this.setFocusedError(previousError);
          Logger.log(`\u2705 \uC774\uC804 \uC624\uB958\uB85C \uC774\uB3D9: ${previousError.correction.original}`);
        } else {
          new import_obsidian12.Notice("\uC774\uC804 \uC624\uB958\uB97C \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
        }
      }
    });
    plugin.addCommand({
      id: "inline-next-suggestion",
      name: "\uB2E4\uC74C \uC81C\uC548 \uC120\uD0DD",
      callback: () => {
        if (!this.currentFocusedError) {
          const errorAtCursor = this.findErrorAtCursor();
          if (errorAtCursor) {
            this.setFocusedError(errorAtCursor);
            Logger.log(`\u{1F3AF} \uCEE4\uC11C \uC704\uCE58\uC5D0\uC11C \uC790\uB3D9 \uD3EC\uCEE4\uC2A4: ${errorAtCursor.correction.original}`);
          } else {
            new import_obsidian12.Notice("\uD604\uC7AC \uD3EC\uCEE4\uC2A4\uB41C \uBB38\uBC95 \uC624\uB958\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4. \uCEE4\uC11C\uB97C \uC624\uB958 \uB2E8\uC5B4\uC5D0 \uC704\uCE58\uC2DC\uD0A4\uAC70\uB098 \uBA3C\uC800 \uC624\uB958\uB97C \uC120\uD0DD\uD574\uC8FC\uC138\uC694.");
            return;
          }
        }
        if (!this.currentFocusedError || !this.currentFocusedError.correction) {
          new import_obsidian12.Notice("\uD604\uC7AC \uC624\uB958\uC5D0 \uB300\uD55C \uC81C\uC548\uC774 \uC5C6\uC2B5\uB2C8\uB2E4.");
          return;
        }
        const suggestions = [this.currentFocusedError.correction.original, ...this.currentFocusedError.correction.corrected];
        if (!suggestions || suggestions.length === 0) {
          new import_obsidian12.Notice("\uD604\uC7AC \uC624\uB958\uC5D0 \uB300\uD55C \uC81C\uC548\uC774 \uC5C6\uC2B5\uB2C8\uB2E4.");
          return;
        }
        this.currentSuggestionIndex = (this.currentSuggestionIndex + 1) % suggestions.length;
        this.applyCurrentSuggestionTemporarily();
        Logger.log(`\u2705 \uB2E4\uC74C \uC81C\uC548 \uC801\uC6A9: ${suggestions[this.currentSuggestionIndex]} (${this.currentSuggestionIndex + 1}/${suggestions.length})`);
      }
    });
    plugin.addCommand({
      id: "inline-previous-suggestion",
      name: "\uC774\uC804 \uC81C\uC548 \uC120\uD0DD",
      callback: () => {
        if (!this.currentFocusedError) {
          const errorAtCursor = this.findErrorAtCursor();
          if (errorAtCursor) {
            this.setFocusedError(errorAtCursor);
            Logger.log(`\u{1F3AF} \uCEE4\uC11C \uC704\uCE58\uC5D0\uC11C \uC790\uB3D9 \uD3EC\uCEE4\uC2A4: ${errorAtCursor.correction.original}`);
          } else {
            new import_obsidian12.Notice("\uD604\uC7AC \uD3EC\uCEE4\uC2A4\uB41C \uBB38\uBC95 \uC624\uB958\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4. \uCEE4\uC11C\uB97C \uC624\uB958 \uB2E8\uC5B4\uC5D0 \uC704\uCE58\uC2DC\uD0A4\uAC70\uB098 \uBA3C\uC800 \uC624\uB958\uB97C \uC120\uD0DD\uD574\uC8FC\uC138\uC694.");
            return;
          }
        }
        if (!this.currentFocusedError || !this.currentFocusedError.correction) {
          new import_obsidian12.Notice("\uD604\uC7AC \uC624\uB958\uC5D0 \uB300\uD55C \uC81C\uC548\uC774 \uC5C6\uC2B5\uB2C8\uB2E4.");
          return;
        }
        const suggestions = [this.currentFocusedError.correction.original, ...this.currentFocusedError.correction.corrected];
        if (!suggestions || suggestions.length === 0) {
          new import_obsidian12.Notice("\uD604\uC7AC \uC624\uB958\uC5D0 \uB300\uD55C \uC81C\uC548\uC774 \uC5C6\uC2B5\uB2C8\uB2E4.");
          return;
        }
        this.currentSuggestionIndex = (this.currentSuggestionIndex - 1 + suggestions.length) % suggestions.length;
        this.applyCurrentSuggestionTemporarily();
        Logger.log(`\u2705 \uC774\uC804 \uC81C\uC548 \uC801\uC6A9: ${suggestions[this.currentSuggestionIndex]} (${this.currentSuggestionIndex + 1}/${suggestions.length})`);
      }
    });
    plugin.addCommand({
      id: "inline-apply-suggestion",
      name: "\uC120\uD0DD\uB41C \uC81C\uC548 \uC801\uC6A9",
      callback: () => {
        if (!this.currentFocusedError || !this.currentView || !this.currentFocusedError.correction) {
          new import_obsidian12.Notice("\uD604\uC7AC \uD3EC\uCEE4\uC2A4\uB41C \uBB38\uBC95 \uC624\uB958\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4. \uBA3C\uC800 \uC624\uB958\uB97C \uC120\uD0DD\uD574\uC8FC\uC138\uC694.");
          return;
        }
        const suggestions = [this.currentFocusedError.correction.original, ...this.currentFocusedError.correction.corrected];
        if (!suggestions || suggestions.length === 0) {
          new import_obsidian12.Notice("\uD604\uC7AC \uC624\uB958\uC5D0 \uB300\uD55C \uC81C\uC548\uC774 \uC5C6\uC2B5\uB2C8\uB2E4.");
          return;
        }
        const selectedSuggestion = suggestions[this.currentSuggestionIndex];
        const originalText = this.currentFocusedError.correction.original;
        this.applySuggestion(this.currentFocusedError, selectedSuggestion);
        this.clearFocusedError();
        new import_obsidian12.Notice(`\uC81C\uC548 \uC801\uC6A9: "${originalText}" \u2192 "${selectedSuggestion}"`);
        Logger.log(`\u2705 \uC81C\uC548 \uC801\uC6A9: "${originalText}" \u2192 "${selectedSuggestion}"`);
      }
    });
    plugin.addCommand({
      id: "inline-unfocus",
      name: "\uBB38\uBC95 \uC624\uB958 \uD3EC\uCEE4\uC2A4 \uD574\uC81C",
      callback: () => {
        if (!this.currentFocusedError || !this.currentView) {
          new import_obsidian12.Notice("\uD604\uC7AC \uD3EC\uCEE4\uC2A4\uB41C \uBB38\uBC95 \uC624\uB958\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.");
          return;
        }
        this.clearFocusedError();
        new import_obsidian12.Notice("\uBB38\uBC95 \uC624\uB958 \uD3EC\uCEE4\uC2A4\uB97C \uD574\uC81C\uD588\uC2B5\uB2C8\uB2E4.");
        Logger.log("\u2705 \uD0A4\uBCF4\uB4DC \uB124\uBE44\uAC8C\uC774\uC158 \uD574\uC81C");
      }
    });
    plugin.addCommand({
      id: "toggle-inline-mode",
      name: "\uD55C\uAD6D\uC5B4 \uBB38\uBC95 \uC778\uB77C\uC778 \uBAA8\uB4DC \uD1A0\uAE00",
      callback: () => {
        var _a, _b, _c;
        const currentState = ((_b = (_a = plugin.settings) == null ? void 0 : _a.inlineMode) == null ? void 0 : _b.enabled) || false;
        if ((_c = plugin.settings) == null ? void 0 : _c.inlineMode) {
          plugin.settings.inlineMode.enabled = !currentState;
          plugin.saveSettings();
          if (plugin.settings.inlineMode.enabled) {
            plugin.enableInlineMode();
            Logger.log("\u2705 \uC778\uB77C\uC778 \uBAA8\uB4DC \uD65C\uC131\uD654");
          } else {
            plugin.disableInlineMode();
            Logger.log("\u2705 \uC778\uB77C\uC778 \uBAA8\uB4DC \uBE44\uD65C\uC131\uD654");
          }
        }
      }
    });
    Logger.log("\u{1F3B9} \uC778\uB77C\uC778 \uBAA8\uB4DC: \uBA85\uB839\uC5B4 \uB4F1\uB85D \uC644\uB8CC!");
    Logger.log("\u{1F4CB} \uB4F1\uB85D\uB41C \uBA85\uB839\uC5B4:");
    Logger.log("  \u2022 Korean Grammar Assistant: \uB2E4\uC74C \uBB38\uBC95 \uC624\uB958\uB85C \uC774\uB3D9");
    Logger.log("  \u2022 Korean Grammar Assistant: \uC774\uC804 \uBB38\uBC95 \uC624\uB958\uB85C \uC774\uB3D9");
    Logger.log("  \u2022 Korean Grammar Assistant: \uB2E4\uC74C \uC81C\uC548 \uC120\uD0DD");
    Logger.log("  \u2022 Korean Grammar Assistant: \uC774\uC804 \uC81C\uC548 \uC120\uD0DD");
    Logger.log("  \u2022 Korean Grammar Assistant: \uC120\uD0DD\uB41C \uC81C\uC548 \uC801\uC6A9");
    Logger.log("  \u2022 Korean Grammar Assistant: \uBB38\uBC95 \uC624\uB958 \uD3EC\uCEE4\uC2A4 \uD574\uC81C");
    Logger.log("  \u2022 Korean Grammar Assistant: \uD55C\uAD6D\uC5B4 \uBB38\uBC95 \uC778\uB77C\uC778 \uBAA8\uB4DC \uD1A0\uAE00");
    Logger.log("\u{1F4A1} Command Palette (Cmd+P)\uC5D0\uC11C \uAC80\uC0C9\uD558\uAC70\uB098 Hotkeys\uC5D0\uC11C \uB2E8\uCD95\uD0A4\uB97C \uC124\uC815\uD558\uC138\uC694!");
  }
  /**
   * üéØ ÌÜµÌï© Ìà¥ÌåÅ ÌëúÏãú ÌåêÎã®: ÌîåÎû´ÌèºÍ≥º ÏÑ§Ï†ïÏóê Îî∞Î•∏ Ïä§ÎßàÌä∏ Í≤∞Ï†ï
   */
  static shouldShowTooltipOnInteraction(interactionType) {
    var _a;
    if (!((_a = this.settings) == null ? void 0 : _a.inlineMode))
      return false;
    const { tooltipTrigger } = this.settings.inlineMode;
    if (!tooltipTrigger) {
      return interactionType === "hover" ? this.settings.inlineMode.showTooltipOnHover : this.settings.inlineMode.showTooltipOnClick;
    }
    switch (tooltipTrigger) {
      case "disabled":
        return false;
      case "hover":
        return interactionType === "hover" && !import_obsidian11.Platform.isMobile;
      case "click":
        return interactionType === "click";
      case "auto":
      default:
        if (import_obsidian11.Platform.isMobile) {
          return interactionType === "click";
        } else {
          return true;
        }
    }
  }
  /**
   * üéØ Ïª§ÏÑú ÏúÑÏπò Í∏∞Î∞ò Í∞ÄÏû• Í∞ÄÍπåÏö¥ Îã§Ïùå Ïò§Î•ò Ï∞æÍ∏∞
   */
  static findNextErrorFromCursor() {
    if (!this.app || this.activeErrors.size === 0) {
      return null;
    }
    try {
      const view = this.app.workspace.getActiveViewOfType(import_obsidian13.MarkdownView);
      if (!view || !view.editor) {
        Logger.warn("\uD604\uC7AC \uD65C\uC131 Markdown \uC5D0\uB514\uD130\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4");
        return null;
      }
      const cursor = view.editor.getCursor();
      const cursorOffset = view.editor.posToOffset(cursor);
      Logger.debug(`\uCEE4\uC11C \uC704\uCE58: line ${cursor.line}, ch ${cursor.ch}, offset ${cursorOffset}`);
      const sortedErrors = Array.from(this.activeErrors.values()).sort((a, b) => a.start - b.start);
      for (const error of sortedErrors) {
        if (error.start > cursorOffset) {
          Logger.debug(`\uB2E4\uC74C \uC624\uB958 \uBC1C\uACAC: "${error.correction.original}" at offset ${error.start}`);
          return error;
        }
      }
      if (sortedErrors.length > 0) {
        const firstError = sortedErrors[0];
        Logger.debug(`\uB9C8\uC9C0\uB9C9\uAE4C\uC9C0 \uB3C4\uB2EC, \uCCAB \uBC88\uC9F8 \uC624\uB958\uB85C \uC21C\uD658: "${firstError.correction.original}"`);
        return firstError;
      }
      return null;
    } catch (error) {
      Logger.error("\uB2E4\uC74C \uC624\uB958 \uCC3E\uAE30 \uC911 \uC624\uB958:", error);
      return null;
    }
  }
  /**
   * üéØ Ïª§ÏÑú ÏúÑÏπò Í∏∞Î∞ò Í∞ÄÏû• Í∞ÄÍπåÏö¥ Ïù¥Ï†Ñ Ïò§Î•ò Ï∞æÍ∏∞
   */
  static findPreviousErrorFromCursor() {
    if (!this.app || this.activeErrors.size === 0) {
      return null;
    }
    try {
      const view = this.app.workspace.getActiveViewOfType(import_obsidian13.MarkdownView);
      if (!view || !view.editor) {
        Logger.warn("\uD604\uC7AC \uD65C\uC131 Markdown \uC5D0\uB514\uD130\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4");
        return null;
      }
      const cursor = view.editor.getCursor();
      const cursorOffset = view.editor.posToOffset(cursor);
      Logger.debug(`\uCEE4\uC11C \uC704\uCE58: line ${cursor.line}, ch ${cursor.ch}, offset ${cursorOffset}`);
      const sortedErrors = Array.from(this.activeErrors.values()).sort((a, b) => b.start - a.start);
      for (const error of sortedErrors) {
        if (error.end < cursorOffset) {
          Logger.debug(`\uC774\uC804 \uC624\uB958 \uBC1C\uACAC: "${error.correction.original}" at offset ${error.start}-${error.end}`);
          return error;
        }
      }
      if (sortedErrors.length > 0) {
        const lastError = sortedErrors[0];
        Logger.debug(`\uCC98\uC74C\uAE4C\uC9C0 \uB3C4\uB2EC, \uB9C8\uC9C0\uB9C9 \uC624\uB958\uB85C \uC21C\uD658: "${lastError.correction.original}"`);
        return lastError;
      }
      return null;
    } catch (error) {
      Logger.error("\uC774\uC804 \uC624\uB958 \uCC3E\uAE30 \uC911 \uC624\uB958:", error);
      return null;
    }
  }
  /**
   * üéØ Ïò§Î•ò ÏúÑÏπòÎ°ú Ïª§ÏÑú Ïù¥Îèô Î∞è Î∑∞ Ïä§ÌÅ¨Î°§
   */
  static moveToError(error) {
    if (!this.app) {
      Logger.warn("App \uC778\uC2A4\uD134\uC2A4\uAC00 \uC5C6\uC5B4 \uC624\uB958 \uC704\uCE58\uB85C \uC774\uB3D9\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4");
      return;
    }
    try {
      const view = this.app.workspace.getActiveViewOfType(import_obsidian13.MarkdownView);
      if (!view || !view.editor) {
        Logger.warn("\uD604\uC7AC \uD65C\uC131 Markdown \uC5D0\uB514\uD130\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4");
        return;
      }
      const editor = view.editor;
      const startPos = editor.offsetToPos(error.start);
      const endPos = editor.offsetToPos(error.end);
      Logger.debug(`\uC624\uB958 \uC704\uCE58\uB85C \uC774\uB3D9: "${error.correction.original}" at line ${startPos.line}, ch ${startPos.ch}`);
      editor.setCursor(startPos);
      const range = { from: startPos, to: endPos };
      editor.scrollIntoView(range, true);
      editor.focus();
    } catch (error2) {
      Logger.error("\uC624\uB958 \uC704\uCE58\uB85C \uC774\uB3D9 \uC911 \uBB38\uC81C \uBC1C\uC0DD:", error2);
    }
  }
  /**
   * üéØ Ìè¨Ïª§Ïä§Îêú Ïò§Î•òÏóê ÌòÑÏû¨ Ï†úÏïàÏùÑ ÏûÑÏãúÎ°ú Î∞òÏòÅ
   */
  static applyCurrentSuggestionTemporarily() {
    if (!this.currentFocusedError || !this.app) {
      return;
    }
    try {
      const view = this.app.workspace.getActiveViewOfType(import_obsidian13.MarkdownView);
      if (!view || !view.editor) {
        Logger.warn("\uD604\uC7AC \uD65C\uC131 Markdown \uC5D0\uB514\uD130\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4");
        return;
      }
      const suggestions = [this.currentFocusedError.correction.original, ...this.currentFocusedError.correction.corrected];
      if (!suggestions || suggestions.length === 0) {
        return;
      }
      const currentSuggestion = suggestions[this.currentSuggestionIndex];
      const editor = view.editor;
      const actualCurrentText = editor.getRange(
        editor.offsetToPos(this.currentFocusedError.start),
        editor.offsetToPos(this.currentFocusedError.end)
      );
      Logger.debug(`\u{1F50D} \uC2E4\uC81C \uD14D\uC2A4\uD2B8 \uD655\uC778: "${actualCurrentText}" \u2192 "${currentSuggestion}"`);
      if (this.currentView) {
        this.currentView.dispatch({
          effects: [setTemporarySuggestionMode.of(true)]
        });
        Logger.debug(`\u{1F3AF} \uC784\uC2DC \uC81C\uC548 \uBAA8\uB4DC \uD65C\uC131\uD654\uB428`);
      }
      const startPos = editor.offsetToPos(this.currentFocusedError.start);
      const endPos = editor.offsetToPos(this.currentFocusedError.end);
      editor.replaceRange(currentSuggestion, startPos, endPos);
      const lengthDiff = currentSuggestion.length - actualCurrentText.length;
      this.currentFocusedError.end = this.currentFocusedError.start + currentSuggestion.length;
      for (const [, error] of this.activeErrors) {
        if (error.start > this.currentFocusedError.start) {
          error.start += lengthDiff;
          error.end += lengthDiff;
        }
      }
      const newEndPos = editor.offsetToPos(this.currentFocusedError.start + currentSuggestion.length);
      editor.setCursor(newEndPos);
      if (this.currentView && this.currentFocusedError) {
        requestAnimationFrame(() => {
          if (this.currentView && this.currentFocusedError) {
            this.currentView.dispatch({
              effects: [setFocusedErrorDecoration.of(this.currentFocusedError.uniqueId)]
            });
            Logger.debug(`\u{1F3AF} \uD3EC\uCEE4\uC2A4 decoration \uC7AC\uC801\uC6A9 \uC644\uB8CC: ${this.currentFocusedError.uniqueId} (${this.currentFocusedError.start}-${this.currentFocusedError.end})`);
          }
        });
        Logger.debug(`\u{1F3AF} \uC784\uC2DC \uC81C\uC548 \uBAA8\uB4DC\uC5D0\uC11C \uD3EC\uCEE4\uC2A4 \uC720\uC9C0: ${this.currentFocusedError.uniqueId} (${this.currentFocusedError.start}-${this.currentFocusedError.end})`);
      }
    } catch (error) {
      Logger.error("\uC784\uC2DC \uC81C\uC548 \uC801\uC6A9 \uC911 \uC624\uB958:", error);
    }
  }
};
InlineModeService.activeErrors = /* @__PURE__ */ new Map();
InlineModeService.currentView = null;
InlineModeService.settings = null;
InlineModeService.currentFocusedError = null;
InlineModeService.currentSuggestionIndex = 0;
// üîß Î†àÍ±∞Ïãú: Í∏∞Ï°¥ ÌÇ§Î≥¥Îìú Ïä§ÏΩîÌîÑ Î∞©Ïãù (Command Palette Î∞©ÏãùÏúºÎ°ú ÎåÄÏ≤¥Îê®)
// private static keyboardScope: Scope | null = null;
InlineModeService.app = null;
InlineModeService.currentHoveredError = null;
InlineModeService.hoverTimeout = null;

// src/ui/koreanGrammarSuggest.ts
var import_obsidian14 = require("obsidian");
init_logger();
var KoreanGrammarSuggest = class extends import_obsidian14.EditorSuggest {
  constructor(app, settings) {
    var _a, _b;
    super(app);
    this.settings = settings;
    this.corrections = /* @__PURE__ */ new Map();
    this.lastCheckTime = 0;
    this.checkCooldown = 1e3;
    // 1Ï¥à Ïø®Îã§Ïö¥
    // ÌïúÍ∏Ä Ìå®ÌÑ¥ Ï†ïÍ∑úÏãù
    this.koreanPattern = /[\u3131-\u318E\uAC00-\uD7A3]+/g;
    this.wordBoundaryPattern = /[^\u3131-\u318E\uAC00-\uD7A3\s]/;
    this.apiService = new SpellCheckApiService();
    this.limit = ((_b = (_a = this.settings) == null ? void 0 : _a.inlineMode) == null ? void 0 : _b.maxSuggestions) || 5;
    this.setInstructions([
      { command: "\u2191\u2193", purpose: "\uD0D0\uC0C9" },
      { command: "\u21B5", purpose: "\uC120\uD0DD" },
      { command: "esc", purpose: "\uB2EB\uAE30" },
      { command: "Ctrl+Space", purpose: "\uC790\uC138\uD788" }
    ]);
    Logger.debug("KoreanGrammarSuggest \uCD08\uAE30\uD654\uB428");
  }
  /**
   * Ìä∏Î¶¨Í±∞ Ï°∞Í±¥ ÌôïÏù∏
   * ÌïúÍ∏Ä Îã®Ïñ¥ÏóêÏÑú ÎßûÏ∂§Î≤ï Ïò§Î•ò Í∞êÏßÄ Ïãú Ï†úÏïà ÏãúÏä§ÌÖú ÌôúÏÑ±Ìôî
   */
  onTrigger(cursor, editor, file) {
    if (Date.now() - this.lastCheckTime < this.checkCooldown) {
      return null;
    }
    const wordMatch = this.findKoreanWordAtCursor(cursor, editor);
    if (!wordMatch) {
      return null;
    }
    const correction = this.corrections.get(wordMatch.word);
    if (!correction || correction.corrected.length === 0) {
      return null;
    }
    Logger.debug(`\uB9DE\uCDA4\uBC95 \uC81C\uC548 \uD2B8\uB9AC\uAC70: "${wordMatch.word}"`);
    return {
      start: { line: wordMatch.line, ch: wordMatch.start },
      end: { line: wordMatch.line, ch: wordMatch.end },
      query: wordMatch.word
    };
  }
  /**
   * ÏàòÏ†ï Ï†úÏïà ÏÉùÏÑ±
   */
  async getSuggestions(context) {
    const correction = this.corrections.get(context.query);
    if (!correction) {
      return [];
    }
    const suggestion = {
      original: correction.original,
      corrections: correction.corrected,
      help: correction.help,
      range: { start: context.start, end: context.end },
      confidence: this.calculateConfidence(correction)
    };
    Logger.debug(`\uC81C\uC548 \uC0DD\uC131: ${correction.corrected.length}\uAC1C \uC218\uC815\uC548`);
    return [suggestion];
  }
  /**
   * Ï†úÏïà Ìï≠Î™© Î†åÎçîÎßÅ
   */
  renderSuggestion(suggestion, el) {
    const container = el.createDiv({ cls: "kgc-suggestion-container" });
    const header = container.createDiv({ cls: "kgc-suggestion-header" });
    header.createSpan({
      cls: "kgc-suggestion-error-icon",
      text: "\u274C"
    });
    header.createSpan({
      cls: "kgc-suggestion-error-text",
      text: suggestion.original
    });
    if (suggestion.confidence !== void 0) {
      header.createSpan({
        cls: "kgc-suggestion-confidence",
        text: `${suggestion.confidence}%`
      });
    }
    const correctionsList = container.createDiv({ cls: "kgc-suggestion-corrections" });
    suggestion.corrections.forEach((correction, index) => {
      const correctionItem = correctionsList.createDiv({
        cls: "kgc-suggestion-item",
        attr: { "data-index": index.toString() }
      });
      correctionItem.createSpan({
        cls: "kgc-suggestion-check-icon",
        text: "\u2713"
      });
      correctionItem.createSpan({
        cls: "kgc-suggestion-text",
        text: correction
      });
      if (index === 0) {
        correctionItem.addClass("kgc-suggestion-item--primary");
      }
    });
    if (suggestion.help) {
      const helpSection = container.createDiv({ cls: "kgc-suggestion-help" });
      helpSection.createSpan({
        cls: "kgc-suggestion-help-icon",
        text: "\u{1F4A1}"
      });
      helpSection.createSpan({
        cls: "kgc-suggestion-help-text",
        text: suggestion.help
      });
    }
    const footer = container.createDiv({ cls: "kgc-suggestion-footer" });
    footer.createSpan({
      cls: "kgc-suggestion-hint",
      text: "Ctrl+Space: \uC0C1\uC138 \uC635\uC158"
    });
  }
  /**
   * Ï†úÏïà ÏÑ†ÌÉù Ï≤òÎ¶¨
   */
  selectSuggestion(suggestion, evt) {
    var _a;
    const editor = (_a = this.context) == null ? void 0 : _a.editor;
    if (!editor)
      return;
    if (evt.ctrlKey || evt.metaKey || evt.code === "Space") {
      this.showDetailedOptions(suggestion, editor, evt);
      return;
    }
    const selectedCorrection = suggestion.corrections[0];
    this.applySuggestion(suggestion, selectedCorrection, editor);
  }
  /**
   * ÏÉÅÏÑ∏ ÏòµÏÖò Î©îÎâ¥ ÌëúÏãú
   */
  showDetailedOptions(suggestion, editor, evt) {
    const menu = new import_obsidian14.Menu();
    suggestion.corrections.forEach((correction, index) => {
      menu.addItem((item) => {
        item.setTitle(correction).setIcon(index === 0 ? "star" : "edit").onClick(() => {
          this.applySuggestion(suggestion, correction, editor);
        });
        if (index === 0) {
          item.setSection("\uCD94\uCC9C");
        }
      });
    });
    menu.addSeparator();
    menu.addItem((item) => {
      item.setTitle("\uC774 \uC624\uB958 \uBB34\uC2DC").setIcon("x").onClick(() => {
        this.ignoreError(suggestion.original);
      });
    });
    if (suggestion.help) {
      menu.addItem((item) => {
        item.setTitle("\uB3C4\uC6C0\uB9D0 \uBCF4\uAE30").setIcon("help-circle").onClick(() => {
          this.showHelpModal(suggestion.help);
        });
      });
    }
    if (evt instanceof MouseEvent) {
      menu.showAtMouseEvent(evt);
    } else {
      menu.showAtPosition({ x: 0, y: 0 });
    }
  }
  /**
   * ÏàòÏ†ï Ï†úÏïà Ï†ÅÏö©
   */
  applySuggestion(suggestion, selectedCorrection, editor) {
    editor.replaceRange(
      selectedCorrection,
      suggestion.range.start,
      suggestion.range.end
    );
    this.corrections.delete(suggestion.original);
    Logger.log(`\uB9DE\uCDA4\uBC95 \uC218\uC815 \uC801\uC6A9: "${suggestion.original}" \u2192 "${selectedCorrection}"`);
    new import_obsidian14.Notice(`"${suggestion.original}"\uC774(\uAC00) "${selectedCorrection}"\uB85C \uC218\uC815\uB418\uC5C8\uC2B5\uB2C8\uB2E4.`);
  }
  /**
   * Ïò§Î•ò Î¨¥Ïãú
   */
  ignoreError(original) {
    this.corrections.delete(original);
    Logger.log(`\uB9DE\uCDA4\uBC95 \uC624\uB958 \uBB34\uC2DC: "${original}"`);
    new import_obsidian14.Notice(`"${original}" \uC624\uB958\uB97C \uBB34\uC2DC\uD588\uC2B5\uB2C8\uB2E4.`);
  }
  /**
   * ÎèÑÏõÄÎßê Î™®Îã¨ ÌëúÏãú
   */
  showHelpModal(helpText) {
    const modal = new import_obsidian14.Modal(this.app);
    modal.titleEl.setText("\uB9DE\uCDA4\uBC95 \uB3C4\uC6C0\uB9D0");
    const content = modal.contentEl;
    content.createEl("p", { text: helpText });
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    buttonContainer.createEl("button", {
      text: "\uB2EB\uAE30",
      cls: "mod-cta"
    }).addEventListener("click", () => {
      modal.close();
    });
    modal.open();
  }
  /**
   * Ïª§ÏÑú ÏúÑÏπòÏùò ÌïúÍ∏Ä Îã®Ïñ¥ Ï∞æÍ∏∞
   */
  findKoreanWordAtCursor(cursor, editor) {
    const line = editor.getLine(cursor.line);
    const cursorPos = cursor.ch;
    let start = cursorPos;
    let end = cursorPos;
    while (start > 0) {
      const char = line[start - 1];
      if (this.isKoreanChar(char)) {
        start--;
      } else {
        break;
      }
    }
    while (end < line.length) {
      const char = line[end];
      if (this.isKoreanChar(char)) {
        end++;
      } else {
        break;
      }
    }
    if (end - start < 1) {
      return null;
    }
    const word = line.slice(start, end);
    if (!this.isKoreanWord(word)) {
      return null;
    }
    return {
      word,
      start,
      end,
      line: cursor.line
    };
  }
  /**
   * ÌïúÍ∏Ä Î¨∏Ïûê ÌôïÏù∏
   */
  isKoreanChar(char) {
    const code = char.charCodeAt(0);
    return code >= 12593 && code <= 12686 || // ÌïúÍ∏Ä ÏûêÎ™®
    code >= 44032 && code <= 55203;
  }
  /**
   * ÌïúÍ∏Ä Îã®Ïñ¥ ÌôïÏù∏
   */
  isKoreanWord(word) {
    return word.length >= 1 && /[\uAC00-\uD7A3]/.test(word);
  }
  /**
   * Ïã†Î¢∞ÎèÑ Í≥ÑÏÇ∞
   */
  calculateConfidence(correction) {
    let confidence = 80;
    if (correction.corrected.length === 1) {
      confidence += 10;
    }
    if (correction.help && correction.help.trim()) {
      confidence += 10;
    }
    return Math.min(confidence, 100);
  }
  /**
   * ÎßûÏ∂§Î≤ï Í≤ÄÏÇ¨ Í≤∞Í≥º ÏóÖÎç∞Ïù¥Ìä∏
   */
  async updateCorrections(text) {
    try {
      this.lastCheckTime = Date.now();
      const result = await this.apiService.checkSpelling(text, this.settings);
      this.corrections.clear();
      result.corrections.forEach((correction) => {
        this.corrections.set(correction.original, correction);
      });
      Logger.debug(`\uAD50\uC815 \uC815\uBCF4 \uC5C5\uB370\uC774\uD2B8: ${result.corrections.length}\uAC1C \uC624\uB958`);
    } catch (error) {
      Logger.error("\uB9DE\uCDA4\uBC95 \uAC80\uC0AC \uC2E4\uD328:", error);
    }
  }
  /**
   * ÏÑ§Ï†ï ÏóÖÎç∞Ïù¥Ìä∏
   */
  updateSettings(settings) {
    var _a, _b;
    this.settings = settings;
    this.limit = ((_a = settings == null ? void 0 : settings.inlineMode) == null ? void 0 : _a.maxSuggestions) || 5;
    this.checkCooldown = ((_b = settings == null ? void 0 : settings.inlineMode) == null ? void 0 : _b.checkDelay) || 1e3;
  }
  /**
   * ÏÑúÎπÑÏä§ Ï†ïÎ¶¨
   */
  cleanup() {
    this.corrections.clear();
    Logger.debug("KoreanGrammarSuggest \uC815\uB9AC\uB428");
  }
};

// main.ts
(0, import_obsidian15.addIcon)(
  "han-spellchecker",
  `<?xml version="1.0" encoding="UTF-8"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 18 18" fill="currentColor"><path d="M3.6,3.9c1.3,0,2.9,0,4.2,0,.7,0,2.3-.5,2.3.7,0,.3-.3.5-.6.5-2.2,0-4.6.2-6.8,0-.4,0-.7-.4-.8-.8-.2-.7,1.2-.7,1.5-.4h0ZM6.1,11c-4.2,0-3.7-5.8.7-5.2,3.7.2,3.1,5.6-.5,5.2h-.2ZM3.6,1.6c.7,0,1.5.4,2.3.4.8.1,1.6,0,2.4,0,.8,1.2-1.4,1.5-2.9,1.3-.9,0-2.7-.8-1.9-1.7h0ZM6.3,9.7c2.5,0,1.9-3.4-.6-2.8-1.2.2-1.4,1.8-.5,2.4.2.2.9.2,1,.3h0ZM4.9,13.2c-.1-1.2,1.5-.9,1.6.1.4,1.5-.2,2.3,2,2.1,1,0,6.7-.6,5,1.1-2.3.5-5.4.7-7.6-.3-.6-.8-.3-2.2-.9-3h0ZM11.3,1.1c2.6-.3,1.5,3.8,2,5,.6.4,2.6-.5,2.8.7,0,.4-.3.6-.6.7-.7.1-1.6,0-2.3.1-.2.1,0,.5-.1,1.1,0,1,0,4.2-.8,4.2-.2,0-.5-.3-.6-.6-.3-1.4,0-3.4,0-5,0-1.9,0-3.8-.2-4.6-.1-.4-.5-1.2-.1-1.5h.1Z"/></svg>`
);
var KoreanGrammarPlugin = class extends import_obsidian15.Plugin {
  constructor() {
    super(...arguments);
    this.grammarSuggest = null;
  }
  async onload() {
    if (false) {
      Logger.configureForProduction();
    } else {
      Logger.configureForDevelopment();
    }
    Logger.log("Korean Grammar Assistant \uD50C\uB7EC\uADF8\uC778 \uB85C\uB529 \uC2DC\uC791");
    await this.loadSettings();
    this.orchestrator = new SpellCheckOrchestrator(
      this.app,
      this.settings,
      (updatedSettings) => {
        this.settings = updatedSettings;
        this.saveSettings();
      }
    );
    InlineModeService.registerCommands(this);
    this.addRibbonIcon("han-spellchecker", "Check Spelling", async () => {
      await this.orchestrator.execute();
    });
    this.addCommand({
      id: "check-korean-spelling",
      name: "\uD55C\uAD6D\uC5B4 \uB9DE\uCDA4\uBC95 \uAC80\uC0AC",
      callback: async () => {
        await this.orchestrator.execute();
      }
    });
    this.addCommand({
      id: "check-current-paragraph",
      name: "\uD604\uC7AC \uBB38\uB2E8 \uB9DE\uCDA4\uBC95 \uAC80\uC0AC",
      callback: async () => {
        await this.orchestrator.executeCurrentParagraph();
      }
    });
    this.addCommand({
      id: "check-current-word",
      name: "\uD604\uC7AC \uB2E8\uC5B4 \uB9DE\uCDA4\uBC95 \uAC80\uC0AC",
      callback: async () => {
        await this.orchestrator.executeCurrentWord();
      }
    });
    this.addCommand({
      id: "check-current-sentence",
      name: "\uD604\uC7AC \uBB38\uC7A5 \uB9DE\uCDA4\uBC95 \uAC80\uC0AC",
      callback: async () => {
        await this.orchestrator.executeCurrentSentence();
      }
    });
    this.addCommand({
      id: "inline-spell-check",
      name: "\uC778\uB77C\uC778 \uB9DE\uCDA4\uBC95 \uAC80\uC0AC (\uBCA0\uD0C0)",
      callback: async () => {
        if (!this.settings.inlineMode.enabled) {
          new import_obsidian15.Notice("\uC778\uB77C\uC778 \uBAA8\uB4DC\uAC00 \uBE44\uD65C\uC131\uD654\uB418\uC5B4 \uC788\uC2B5\uB2C8\uB2E4. \uC124\uC815\uC5D0\uC11C \uBCA0\uD0C0 \uAE30\uB2A5\uC744 \uD65C\uC131\uD654\uD558\uC138\uC694.");
          return;
        }
        await this.executeInlineSpellCheck();
      }
    });
    this.addCommand({
      id: "inline-spell-check-suggest",
      name: "\uC778\uB77C\uC778 \uB9DE\uCDA4\uBC95 \uAC80\uC0AC (EditorSuggest)",
      callback: async () => {
        if (!this.settings.inlineMode.enabled) {
          new import_obsidian15.Notice("\uC778\uB77C\uC778 \uBAA8\uB4DC\uAC00 \uBE44\uD65C\uC131\uD654\uB418\uC5B4 \uC788\uC2B5\uB2C8\uB2E4. \uC124\uC815\uC5D0\uC11C \uBCA0\uD0C0 \uAE30\uB2A5\uC744 \uD65C\uC131\uD654\uD558\uC138\uC694.");
          return;
        }
        await this.executeInlineSpellCheckWithSuggest();
      }
    });
    if (this.settings.inlineMode.enabled) {
      this.enableInlineMode();
    }
    this.addSettingTab(new ModernSettingsTab(this.app, this));
    Logger.log("Korean Grammar Assistant \uD50C\uB7EC\uADF8\uC778 \uB85C\uB529 \uC644\uB8CC");
  }
  onunload() {
    this.disableInlineMode();
    if (this.orchestrator) {
      this.orchestrator.destroy();
    }
  }
  async loadSettings() {
    const savedData = await this.loadData();
    this.settings = SettingsService.mergeWithDefaults(savedData || {});
  }
  async saveSettings() {
    await this.saveData(this.settings);
    if (this.orchestrator) {
      this.orchestrator.updateSettings(this.settings);
    }
  }
  /**
   * Ïù∏ÎùºÏù∏ ÎßûÏ∂§Î≤ï Í≤ÄÏÇ¨ Ïã§Ìñâ
   */
  async executeInlineSpellCheck() {
    const activeLeaf = this.app.workspace.activeLeaf;
    if (!activeLeaf) {
      new import_obsidian15.Notice("\uD65C\uC131\uD654\uB41C \uD3B8\uC9D1\uAE30\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.");
      return;
    }
    const editor = activeLeaf.view.editor;
    if (!editor) {
      new import_obsidian15.Notice("\uD3B8\uC9D1\uAE30\uB97C \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
      return;
    }
    const editorView = editor.cm;
    if (!editorView) {
      new import_obsidian15.Notice("CodeMirror \uC5D0\uB514\uD130 \uBDF0\uB97C \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
      return;
    }
    Logger.log("\uC778\uB77C\uC778 \uBAA8\uB4DC: \uB9DE\uCDA4\uBC95 \uAC80\uC0AC \uC2DC\uC791");
    try {
      InlineModeService.setEditorView(editorView, this.settings, this.app);
      const fullText = editorView.state.doc.toString();
      if (!fullText.trim()) {
        new import_obsidian15.Notice("\uAC80\uC0AC\uD560 \uD14D\uC2A4\uD2B8\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.");
        return;
      }
      const apiService = new SpellCheckApiService();
      const result = await apiService.checkSpelling(fullText, this.settings);
      if (!result.corrections || result.corrections.length === 0) {
        new import_obsidian15.Notice("\uB9DE\uCDA4\uBC95 \uC624\uB958\uAC00 \uBC1C\uACAC\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4.");
        return;
      }
      InlineModeService.showErrors(
        editorView,
        result.corrections,
        this.settings.inlineMode.underlineStyle,
        this.settings.inlineMode.underlineColor,
        this.app
      );
      new import_obsidian15.Notice(`${result.corrections.length}\uAC1C\uC758 \uB9DE\uCDA4\uBC95 \uC624\uB958\uB97C \uBC1C\uACAC\uD588\uC2B5\uB2C8\uB2E4.`);
      Logger.log(`\uC778\uB77C\uC778 \uBAA8\uB4DC: ${result.corrections.length}\uAC1C \uC624\uB958 \uD45C\uC2DC \uC644\uB8CC`);
    } catch (error) {
      Logger.error("\uC778\uB77C\uC778 \uBAA8\uB4DC \uB9DE\uCDA4\uBC95 \uAC80\uC0AC \uC624\uB958:", error);
      new import_obsidian15.Notice("\uB9DE\uCDA4\uBC95 \uAC80\uC0AC \uC911 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4.");
    }
  }
  /**
   * Ïù∏ÎùºÏù∏ Î™®Îìú ÌôúÏÑ±Ìôî
   */
  enableInlineMode() {
    if (this.grammarSuggest)
      return;
    try {
      this.grammarSuggest = new KoreanGrammarSuggest(this.app, this.settings);
      this.registerEditorSuggest(this.grammarSuggest);
      this.registerEditorExtension([errorDecorationField, temporarySuggestionModeField]);
      const activeLeaf = this.app.workspace.activeLeaf;
      if (activeLeaf && activeLeaf.view && activeLeaf.view.editor) {
        const editorView = activeLeaf.view.editor.cm;
        if (editorView) {
          InlineModeService.setEditorView(editorView, this.settings, this.app);
          Logger.log("\uC778\uB77C\uC778 \uBAA8\uB4DC: InlineModeService \uD0A4\uBCF4\uB4DC \uC2A4\uCF54\uD504 \uCD08\uAE30\uD654\uB428");
        }
      }
      window.InlineModeService = InlineModeService;
      Logger.log("\uC778\uB77C\uC778 \uBAA8\uB4DC \uD65C\uC131\uD654\uB428 (EditorSuggest + \uD0A4\uBCF4\uB4DC \uB2E8\uCD95\uD0A4)");
    } catch (error) {
      Logger.error("\uC778\uB77C\uC778 \uBAA8\uB4DC \uD65C\uC131\uD654 \uC2E4\uD328:", error);
      new import_obsidian15.Notice("\uC778\uB77C\uC778 \uBAA8\uB4DC \uD65C\uC131\uD654\uC5D0 \uC2E4\uD328\uD588\uC2B5\uB2C8\uB2E4.");
    }
  }
  /**
   * Ïù∏ÎùºÏù∏ Î™®Îìú ÎπÑÌôúÏÑ±Ìôî
   */
  disableInlineMode() {
    if (this.grammarSuggest) {
      this.grammarSuggest.cleanup();
      this.grammarSuggest = null;
    }
    if (window.InlineModeService) {
      delete window.InlineModeService;
    }
    Logger.log("\uC778\uB77C\uC778 \uBAA8\uB4DC \uBE44\uD65C\uC131\uD654\uB428");
  }
  /**
   * EditorSuggest Í∏∞Î∞ò Ïù∏ÎùºÏù∏ ÎßûÏ∂§Î≤ï Í≤ÄÏÇ¨ Ïã§Ìñâ
   */
  async executeInlineSpellCheckWithSuggest() {
    if (!this.grammarSuggest) {
      new import_obsidian15.Notice("\uC778\uB77C\uC778 \uBAA8\uB4DC\uAC00 \uD65C\uC131\uD654\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4.");
      return;
    }
    const activeLeaf = this.app.workspace.activeLeaf;
    if (!activeLeaf) {
      new import_obsidian15.Notice("\uD65C\uC131\uD654\uB41C \uD3B8\uC9D1\uAE30\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.");
      return;
    }
    const editor = activeLeaf.view.editor;
    if (!editor) {
      new import_obsidian15.Notice("\uD3B8\uC9D1\uAE30\uB97C \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
      return;
    }
    try {
      const fullText = editor.getValue();
      if (!fullText.trim()) {
        new import_obsidian15.Notice("\uAC80\uC0AC\uD560 \uD14D\uC2A4\uD2B8\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.");
        return;
      }
      Logger.log("EditorSuggest \uAE30\uBC18 \uB9DE\uCDA4\uBC95 \uAC80\uC0AC \uC2DC\uC791");
      await this.grammarSuggest.updateCorrections(fullText);
      new import_obsidian15.Notice("\uB9DE\uCDA4\uBC95 \uAC80\uC0AC\uAC00 \uC644\uB8CC\uB418\uC5C8\uC2B5\uB2C8\uB2E4. \uC624\uD0C0\uC5D0 \uCEE4\uC11C\uB97C \uB193\uC73C\uBA74 \uC218\uC815 \uC81C\uC548\uC774 \uD45C\uC2DC\uB429\uB2C8\uB2E4.");
    } catch (error) {
      Logger.error("EditorSuggest \uAE30\uBC18 \uB9DE\uCDA4\uBC95 \uAC80\uC0AC \uC624\uB958:", error);
      new import_obsidian15.Notice("\uB9DE\uCDA4\uBC95 \uAC80\uC0AC \uC911 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4.");
    }
  }
};
